<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://caldarius.github.io/</id>
    <title>Caldarius</title>
    <updated>2024-11-08T05:55:58.069Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://caldarius.github.io/"/>
    <link rel="self" href="https://caldarius.github.io/atom.xml"/>
    <subtitle>世界上只有一种英雄主义,就是看清生活的真相之后依然热爱生活。</subtitle>
    <logo>https://caldarius.github.io/images/avatar.png</logo>
    <icon>https://caldarius.github.io/favicon.ico</icon>
    <rights>All rights reserved 2024, Caldarius</rights>
    <entry>
        <title type="html"><![CDATA[Annotation]]></title>
        <id>https://caldarius.github.io/post/onjava-annotation/</id>
        <link href="https://caldarius.github.io/post/onjava-annotation/">
        </link>
        <updated>2024-11-07T13:14:07.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>注解（又叫作<strong>元数据</strong>）使我们可以用正式的方式为代码添加信息，这样就可以在将来方便地使用这些数据。</p>
</blockquote>
<p>注解的出现，部分原因是为了迎合将元数据绑定到源代码文件（而非保存在额外的文档中）的趋势。同时Java也受到了来自其他语言（如C#）特性的压力，这也是对此的一个回应。</p>
<p>注解是Java 5的一项重要语言更新。它提供了用<strong>Java无法表达、却是完整表述程序所需的信息</strong>。因此，注解使你可以用某种格式来保存和程序有关的额外信息，编译器会验证该格式的正确性。注解可以生成描述符文件，甚至还可以生成新的类定义，并帮助你减轻编写“样板”代码的负担。通过注解，可以将这些元数据保存在Java源代码中，并拥有以下优势：</p>
<ul>
<li>
<p>更整洁的代码；</p>
</li>
<li>
<p>编译时的类型检查；</p>
</li>
<li>
<p>为注解构建处理工具的注解API。</p>
</li>
</ul>
<p>虽然Java中预定义了几种类型的元数据，但通常来说，要添加什么样的注解类型，以及用它们来做什么，完全由你决定。</p>
<p>注解的语法十分简单，主要是在语言中添加@符号。Java 5引入了第一批定义在java.lang中的3个通用内建注解。</p>
<ul>
<li>@Override：用来声明该方法的定义会重写基类中的某个方法。如果不小心拼错了方法名，或者使用了不恰当的签名，该注解会使编译器报错。2</li>
<li>@Deprecated：如果该元素被使用了，则编译器会发出警告。</li>
<li>@SuppressWarnings：关闭不当的编译警告。</li>
</ul>
<p>以下是Java 7和Java 8新增的注解：</p>
<ul>
<li>@SafeVarargs：Java 7引入，用于在使用泛型作为可变参数的方法或构造器中关闭对调用者的警告。</li>
<li>@FunctionalInterface：Java 8引入，用于表明类型声明是函数式接口。<br>
另外还有5个注解类型用于创建新注解，你将在本章学习它们。<br>
每当你创建涉及重复工作的类或接口时，通常都可以用注解来自动化及简化该过程。例如Enterprise JavaBeans（EJB）中的许多额外工作已被EJB3中的注解替代。</li>
</ul>
<p>注解可以替代一些已有系统，如XDoclet（一个创建注解风格文档的独立文档工具）。对比来看，注解是真正的语言组件，因此是结构化的，并可接受编译时类型检查。将所有信息都保存在真正的代码而不是注释中，会使代码更整洁，且更便于维护。通过直接使用或扩展注解API和工具，或者使用外部的字节码处理库（如本章后面所述），可以对源代码以及字节码执行强大的检查和操作。</p>
<h2 id="41-基本语法">4.1　基本语法</h2>
<p>在下面的示例中，<code>testExecute()</code>方法添加了<code>@Test</code>注解。该注解本身并不会做任何事，只是编译器会确保在<code>CLASSPATH</code>中存在<code>@Test</code>注解的定义。本章稍后会创建一个通过反射来运行该方法的工具。</p>
<pre><code class="language-java">// annotations/Testable.java
package annotations;
import onjava.atunit.*;

public class Testable {
  public void execute() {
    System.out.println(&quot;Executing..&quot;);
  }
  @Test
  void testExecute() { execute(); }
}
</code></pre>
<p>增加了注解的方法和其他方法并无区别，本例中的<code>@Test</code>注解可以和任何修饰符一起配合使用，如<code>public</code>、<code>static</code>和<code>void</code>。从语法角度看，注解的使用方式和修饰符基本相同。</p>
<h3 id="411-定义注解">4.1.1　定义注解</h3>
<p>以下代码是对前文中注解的定义。注解的定义看起来非常像接口的定义。实际上，注解和任何其他Java接口一样，也会编译成类文件。</p>
<pre><code class="language-java">// onjava/atunit/Test.java
// @Test标签
package onjava.atunit;
import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Test {}
</code></pre>
<p>除了<code>@</code>符号外，<code>@Test</code>的定义非常像一个空接口。注解的定义也要求必须有<strong>元注解</strong><code>@Target</code>和<code>@Retention</code>。<code>@Target</code>定义了你可以在何处应用该注解（例如方法或字段）。<code>@Retention</code>定义了该注解在源代码（<code>SOURCE</code>）、类文件（<code>CLASS</code>）或运行时（<code>RUNTIME</code>）中是否可用。</p>
<p>注解通常包含一些可以设定值的<strong>元素</strong>。程序或工具在处理注解时可以使用这些参数。元素看起来比较像接口方法，只不过你可以为其指定默认值。</p>
<p>没有任何元素的注解（如上面的<code>@Test</code>）称为<strong>标记注解</strong>。</p>
<p>下面是一个用于跟踪某项目中用例的简单注解，程序员会给某个特定用例所需的所有方法或方法集都加上注解。项目经理可以通过计算已实现的用例数来了解项目的进度，维护项目的开发人员可以轻松地找到需要更新的用例，或者在系统内调试业务规则。</p>
<pre><code class="language-java">// annotations/UseCase.java
import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface UseCase {
  int id();
  String description() default &quot;no description&quot;;
}
</code></pre>
<p>注意，<code>id</code>和<code>description</code>与方法声明很相似。因为<code>id</code>会受到编译器的类型检查，所以用这种方式将用于跟踪进展的数据库关联到用例文档和源代码，是很可靠的。<code>description</code>元素有个默认值，如果在方法被注解时未指定该元素的值，则注解处理器会使用该默认值。</p>
<p>看一下以下这个类，其中的3个方法被注解为用例：</p>
<pre><code class="language-java">// annotations/PasswordUtils.java
import java.util.*;

public class PasswordUtils {
  @UseCase(id = 47, description =
  &quot;Passwords must contain at least one numeric&quot;)
  public boolean validatePassword(String passwd) {
    return (passwd.matches(&quot;\\w*\\d\\w*&quot;));
  }
  @UseCase(id = 48)
  public String encryptPassword(String passwd) {
   return new StringBuilder(passwd)
    .reverse().toString();
  }
  @UseCase(id = 49, description =
  &quot;New passwords can't equal previously used ones&quot;)
  public boolean checkForNewPassword(
    List&lt;String&gt; prevPasswords, String passwd) {
    return !prevPasswords.contains(passwd);
  }
}
</code></pre>
<p>注解元素定义值的方式是，在<code>@UseCase</code>声明后的圆括号中，用“名-值”对形式来表示。此处<code>encryptPassword()</code>方法的注解并未给<code>description</code>元素传入值，因此当类经过注解处理器的处理后，<code>@interface UseCase</code>中定义的默认值便会出现在此处。</p>
<p>想象一下，你可以先用这种方法来“勾勒”出你的系统，然后在构建时逐渐完善其功能。</p>
<h3 id="412-元注解">4.1.2　元注解</h3>
<p>Java语言中目前只定义了5个标准注解（前面已介绍）和5个元注解（见表4-1）。元注解是为了对注解进行注解。</p>
<p><strong>表4-1</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">注解</th>
<th style="text-align:left">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>@Target</code></td>
<td style="text-align:left">该注解可应用的地方。 可能的<code>ElementType</code>参数包括： - <code>CONSTRUCTOR</code>——构造器声明 - <code>FIELD</code>——字段声明（包括枚举常量） - <code>LOCAL_VARIABLE</code>——本地变量声明 - <code>METHOD</code>——方法声明 - <code>PACKAGE</code>——包声明 - <code>PARAMETRE</code>——参数声明 - <code>TYPE</code>——类、接口（包括注解类型）或枚举的声明</td>
</tr>
<tr>
<td style="text-align:left"><code>@Retention</code></td>
<td style="text-align:left">注解信息可以保存多久。 可能的<code>RetentionPolicy</code>参数包括： - <code>SOURCE</code>——注解会被编译器丢弃 - <code>CLASS</code>——注解在类文件中可被编译器使用，但会被虚拟机丢弃 - <code>RUNTIME</code>——注解在运行时仍被虚拟机保留，因此可以通过反射读取到注解信息</td>
</tr>
<tr>
<td style="text-align:left"><code>@Documented</code></td>
<td style="text-align:left">在Javadoc中引入该注解</td>
</tr>
<tr>
<td style="text-align:left"><code>@Inherited</code></td>
<td style="text-align:left">允许子类继承父注解</td>
</tr>
<tr>
<td style="text-align:left"><code>@Repeatable</code></td>
<td style="text-align:left">可以多次应用于同一个声明（Java 8）</td>
</tr>
</tbody>
</table>
<p>大多数时候，你可以定义自己的注解，然后自行编写处理器来处理它们。</p>
<h2 id="42-编写注解处理器">4.2　编写注解处理器</h2>
<p>如果没有工具来读取注解，那它实际并不会比注释带来更多帮助。使用注解的过程中，很重要的一点是创建并使用<strong>注解处理器</strong>。Java为反射API提供了扩展，以帮助创建这些工具。Java同时还提供了一个<code>javac</code>编译器钩子，用来在编译时使用注解。</p>
<p>以下示例是一个非常简单的注解处理器，它读取被注解的<code>PasswordUtils</code>（密码工具）类，然后利用反射来查找<code>@UseCase</code>标签。通过给定的<code>id</code>值列表，该注解列出了它找到的所有用例，并报告所有丢失的用例。</p>
<pre><code class="language-java">// annotations/UseCaseTracker.java
import java.util.*;
import java.util.stream.*;
import java.lang.reflect.*;

public class UseCaseTracker {
  public static void trackUseCases(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl) {
    for(Method m : cl.getDeclaredMethods()) {
      UseCase uc = m.getAnnotation(UseCase.class);
      if(uc != null) {
        System.out.println(&quot;Found Use Case &quot; +
          uc.id() + &quot;\n  &quot; + uc.description());
        useCases.remove(Integer.valueOf(uc.id()));
      }
    }
    useCases.forEach(i -&gt;
      System.out.println(&quot;Missing use case &quot; + i));
  }
  public static void main(String[] args) {
    List&lt;Integer&gt; useCases = IntStream.range(47, 51)
      .boxed().collect(Collectors.toList());
    trackUseCases(useCases, PasswordUtils.class);
  }
}
/* 输出：
Found Use Case 49
  New passwords can't equal previously used ones
Found Use Case 48
  no description
Found Use Case 47
  Passwords must contain at least one numeric
Missing use case 50
*/
</code></pre>
<p>此处同时使用了反射方法<code>getDeclaredMethods()</code>和从<code>AnnotatedElement</code>接口（诸如<code>Class</code>、<code>Method</code>以及<code>Field</code>等这样的类都会实现该接口）中继承实现的<code>getAnnotation()</code>方法，该方法返回指定类型的注解对象，在本例中即<code>UseCase</code>。如果在此注解方法上没有该指定类型的注解，将会返回<code>null</code>。元素的值通过调用<code>id()</code>和<code>description()</code>方法提取出来。注意，<code>encryptPassword()</code>方法的注解中并未指定<code>description</code>描述，因此当在该注解上调用<code>description()</code>方法时，上述处理器会调取默认值<code>no description</code>。</p>
<h3 id="421-注解元素">4.2.1　注解元素</h3>
<p>在之前的<code>UseCase.java</code>中定义了<code>@UseCase</code>标签，其中包含<code>int</code>元素<code>id</code>和<code>String</code>元素<code>description</code>。以下列出了注解所允许的所有元素类型：</p>
<ul>
<li>所有的基本类型（<code>int</code>、<code>float</code>、<code>boolean</code>等）</li>
<li><code>String</code>（字符串）</li>
<li><code>Class</code>（类）</li>
<li><code>enum</code>（枚举）</li>
<li><code>Annotation</code>（注解）</li>
<li>以上任何类型的数组</li>
</ul>
<p>如果尝试使用任何其他类型，编译器都会报错。注意，任何包装类都是不允许使用的，但由于有自动装箱机制，因此这实际上并不会造成限制。注解也可以作为元素的类型，正如你稍后会看到的，内嵌注解是非常有用的。</p>
<h3 id="422-默认值的限制">4.2.2　默认值的限制</h3>
<p>编译器对元素的默认值要求非常苛刻。所有元素都需要有确定的值，这意味着元素要么有默认值，要么由使用该注解的类来设定值。</p>
<p>还有另一个限制：不论是在源代码中声明时，还是在注解中定义默认值时，任何非基本类型元素都不能赋值为<code>null</code>。这导致很难让处理器去判断某个元素存在与否，因为所有元素在所有注解声明中都是有效存在的。但可以通过检查该元素是否为特殊值（如空字符串或负值）来绕过这个限制：</p>
<pre><code class="language-java">// annotations/SimulatingNull.java
import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface SimulatingNull {
  int id() default -1;
  String description() default &quot;&quot;;
}
</code></pre>
<p>这是定义注解时的一个经典技巧。</p>
<h3 id="423-生成外部文件">4.2.3　生成外部文件</h3>
<p>有些框架要求一些额外信息来配合源代码共同工作，在使用这种框架时，注解特别有用。诸如Enterprise JavaBeans（即EJB）这样的技术（在EJB3出现之前）需要大量的接口和部署描述文件作为“样板”代码，它们以相同的方式为每个bean进行定义。Web服务、自定义标签库，以及Toplink、Hibernate等对象/关系映射工具（ORM）通常也需要代码之外的XML描述文件。每定义一个Java类，程序员都必须经过一个乏味的配置信息的过程，比如配置类名、包名等——这些都是类中本来就有的信息。无论你什么时候使用外部描述符文件，最终都会得到关于一个类的两个独立的信息源，这常常导致代码的信息同步问题。同时这也要求该项目的程序员除了写Java程序外，还必须知道如何编写这些描述符文件。</p>
<p>假如你想实现一套基本的ORM功能来自动化数据库表的创建，你便可以通过XML描述符文件来指定类名、类中的每一个成员，以及数据库映射信息。而如果使用注解，你可以将所有的信息都维护在单个源代码文件中。要实现此功能，你需要注解来定义数据库表名、字段信息，以及要映射到属性的SQL类型。</p>
<p>以下示例是一个注解，它会让注解处理器创建一个数据库表：</p>
<pre><code class="language-java">// annotations/database/DBTable.java
package annotations.database;
import java.lang.annotation.*;

@Target(ElementType.TYPE) // 只适用于类
@Retention(RetentionPolicy.RUNTIME)
public @interface DBTable {
  String name() default &quot;&quot;;
}
</code></pre>
<p>在<code>@Target</code>注解中指定的每个<code>ElementType</code>（元素类型）都是一条约束，它告诉编译器注解只能被应用于该特定类型。你可以指定一个单值的<code>enum</code>元素类型，也可以指定一个用逗号分隔的任意值组成的列表。如果想将注解应用于所有的<code>ElementType</code>，则可以将<code>@Target</code>注解全部去掉，虽然这么做不太常见。</p>
<p>注意，<code>@DBTable</code>中有个<code>name()</code>元素，该注解可以通过它为处理器要创建的数据库表指定表名。</p>
<p>以下示例是表字段的注解：</p>
<pre><code class="language-java">// annotations/database/Constraints.java
package annotations.database;
import java.lang.annotation.*;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Constraints {
  boolean primaryKey() default false;
  boolean allowNull() default true;
  boolean unique() default false;
}
// annotations/database/SQLString.java
package annotations.database;
import java.lang.annotation.*;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface SQLString {
  int value() default 0;
  String name() default &quot;&quot;;
  Constraints constraints() default @Constraints;
}
// annotations/database/SQLInteger.java
package annotations.database;
import java.lang.annotation.*;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface SQLInteger {
  String name() default &quot;&quot;;
  Constraints constraints() default @Constraints;
}
</code></pre>
<p><code>@Constraints</code>注解使得处理器可以提取出数据库表的元数据，这相当于数据库提供的一个小的约束子集，不过它可以帮助你形成一个整体的概念。通过为<code>primaryKey()</code>、<code>allowNull()</code>和<code>unique()</code>元素设置合理的默认值，可以帮使用者减少很多编码工作。</p>
<p>另外两个<code>@interface</code>用于定义SQL的类型。同样，为了使该框架更好用，可以为每个额外的SQL类型都定义一个注解。在本例中，两个注解就足够了。</p>
<p>这些类型都有一个<code>name()</code>元素和一个<code>constraints()</code>元素，后者利用嵌套注解的特性嵌入字段类型的数据库约束信息。注意<code>constraints()</code>元素的默认值是<code>@Constraints</code>。该注解类型后面的圆括号中没有指定元素值，因此<code>constraints()</code>的默认值实际上是一个自身带有一套默认值的<code>@Constraints</code>注解。如果想将内嵌的<code>@Constraints</code>注解的唯一性默认设置为<code>true</code>，可以像下面这样定义它的元素：</p>
<pre><code class="language-java">// annotations/database/Uniqueness.java
// 嵌套注解示例：
package annotations.database;

public @interface Uniqueness {
  Constraints constraints()
  default @Constraints(unique = true);
}
</code></pre>
<p>以下示例是一个使用了该注解的简单类：</p>
<pre><code class="language-java">// annotations/database/Member.java
package annotations.database;

@DBTable(name = &quot;MEMBER&quot;)
public class Member {
  @SQLString(30) 
  String firstName;
  @SQLString(50)
  String lastName;
  @SQLInteger
  Integer age;
  @SQLString(value = 30,
  constraints = @Constraints(primaryKey = true))
  String reference;
  static int memberCount;
  public String getReference() { return reference; }
  public String getFirstName() { return firstName; }
  public String getLastName() { return lastName; }
  @Override public String toString() {
    return reference;
  }
  public Integer getAge() { return age; }
}
</code></pre>
<p>类注解<code>@DBTable</code>被赋值为<code>MEMBER</code>，以用作表名。属性<code>firstName</code>和<code>lastName</code>都被注解为<code>@SQLString</code>，并且分别被赋值为30和50。这些注解很有意思，原因有二：首先，它们都用到了内嵌注解<code>@Constraints</code>中的默认值；其次，它们使用了快捷格式——如果将注解中的元素名定义为<code>value</code>，那么只要它是唯一指定的元素类型，就无须使用“名-值”对的语法，只需要在圆括号内直接指定该值即可。这种方式适用于任何合法的元素类型，该方法限制你必须将元素命名为“value”，不过在如前所述的情况下，这确实促成了有意义且易读的注解规范。</p>
<pre><code class="language-java">@SQLString(30)
</code></pre>
<p>处理器会用该值来设定待创建的SQL字段的长度。</p>
<p>默认值的语法虽然简洁，但很快就会变得复杂起来。来看看字段<code>reference</code>上的注解，其中有一个<code>@SQLString</code>注解，但它同时又必须是数据库的主键，因此在内嵌注解<code>@Constraint</code>中必须设置元素类型<code>primaryKey</code>。麻烦就在这里，现在你不得不在内嵌注解中使用相当冗长的“名-值”对格式，重新指定元素名和<code>@interface</code>的名称。但是因为被特殊命名的元素<code>value</code>不再是唯一被指定的元素值，所以你无法继续使用快捷格式。正如你所看到的，最终结果并不优雅。</p>
<h4 id="替换方案">替换方案</h4>
<p>对于这个问题，还有其他方法来创建注解。举例来说，可以写一个叫<code>@TableColumn</code>的注解类，其中包含一个<code>enum</code>元素，来定义诸如<code>STRING</code>、 <code>INTEGER</code>、<code>FLOAT</code>这样的值。这样就不再需要为每个SQL类型都写一个<code>@interface</code>了，但也使你无法再用<code>size</code>（长度）或<code>precision</code>（精度）等额外的元素来进一步修饰类型，而这些可能会更有用。</p>
<p>你也可以使用<code>String</code>元素来描述实际的SQL类型（比如<code>VARCHAR(30)</code>或<code>INTEGER</code>）。这使得你可以修饰类型，却将Java类型和SQL类型的映射关系在代码中绑定了，这并非好的设计。你肯定不想每当数据库有变化时就重新编译一遍代码。更优雅的方法是，告诉注解处理器你需要什么“口味”（flavor）的SQL，然后处理器在执行时再来处理这些细节。</p>
<p>第三种可行的方法是同时使用两个注解类型来注解目标字段——<code>@Constraints</code>和相应的SQL类型（比如<code>@SQLInteger</code>）。这不太优雅，但是只要你需要，编译器就允许对目标增加任意个注解。在Java 8中使用多注解时，同一个注解可以重复使用。</p>
<h3 id="424-注解不支持继承">4.2.4　注解不支持继承</h3>
<p>我们无法对<code>@interface</code>使用<code>extends</code>关键字。这很可惜，一套优雅的方案应该像之前所建议的一样，定义一个注解<code>@TableColumn</code>，该注解内部包含一个内嵌注解@SQLType，由此就可以从<code>@SQLType</code>继承所有的SQL类型，如<code>@SQLInteger</code>和<code>@SQLString</code>。这样可以减少编码工作，并使语法更简洁。目前看不到Java未来版本中要支持注解继承的迹象，在这种情况下，上面这个例子应该是你目前的最佳选择了。</p>
<h3 id="425-实现处理器">4.2.5　实现处理器</h3>
<p>下面这个示例演示了注解处理器如何读取类文件，检查其数据库注解，并生成SQL命令来创建数据库：</p>
<pre><code class="language-java">// annotations/database/TableCreator.java
// 基于反射的注解处理器
// {java annotations.database.TableCreator
// annotations.database.Member}
package annotations.database;
import java.lang.annotation.*;
import java.lang.reflect.*;
import java.util.*;

public class TableCreator {
  public static void
  main(String[] args) throws Exception {
    if(args.length &lt; 1) {
      System.out.println(
        &quot;arguments: annotated classes&quot;);
      System.exit(0);
    }
    for(String className : args) {
      Class&lt;?&gt; cl = Class.forName(className);
      DBTable dbTable = cl.getAnnotation(DBTable.class);
      if(dbTable == null) {
        System.out.println(
          &quot;No DBTable annotations in class &quot; +
          className);
        continue;
      }
      String tableName = dbTable.name();
      // 如果name为空，则使用Class name：
      if(tableName.length() &lt; 1)
        tableName = cl.getName().toUpperCase();
      List&lt;String&gt; columnDefs = new ArrayList&lt;&gt;();
      for(Field field : cl.getDeclaredFields()) {
        String columnName = null;
        Annotation[] anns =
          field.getDeclaredAnnotations();
        if(anns.length &lt; 1)
          continue; // 不是数据库表字段
        if(anns[0] instanceof SQLInteger) {
          SQLInteger sInt = (SQLInteger) anns[0];
          // 如果name未指定，使用字段名
          if(sInt.name().length() &lt; 1)
            columnName = field.getName().toUpperCase();
          else
            columnName = sInt.name();
          columnDefs.add(columnName + &quot; INT&quot; +
            getConstraints(sInt.constraints()));
        }
        if(anns[0] instanceof SQLString) {
          SQLString sString = (SQLString) anns[0];
          // 如果name未指定，使用字段名
          if(sString.name().length() &lt; 1)
            columnName = field.getName().toUpperCase();
          else
            columnName = sString.name();
          columnDefs.add(columnName + &quot; VARCHAR(&quot; +
            sString.value() + &quot;)&quot; +
            getConstraints(sString.constraints()));
        }
        StringBuilder createCommand = new StringBuilder(
          &quot;CREATE TABLE &quot; + tableName + &quot;(&quot;);
        for(String columnDef : columnDefs)
          createCommand.append(
            &quot;\n    &quot; + columnDef + &quot;,&quot;);
        // 移除尾部的逗号
        String tableCreate = createCommand.substring(
          0, createCommand.length() - 1) + &quot;);&quot;;
        System.out.println(&quot;Table Creation SQL for &quot; +
          className + &quot; is:\n&quot; + tableCreate);
      }
    }
  }
  private static
  String getConstraints(Constraints con) {
    String constraints = &quot;&quot;;
    if(!con.allowNull())
      constraints += &quot; NOT NULL&quot;;
    if(con.primaryKey())
      constraints += &quot; PRIMARY KEY&quot;;
    if(con.unique())
      constraints += &quot; UNIQUE&quot;;
    return constraints;
  }
}
/* 输出：
Table Creation SQL for annotations.database.Member is:
CREATE TABLE MEMBER(
    FIRSTNAME VARCHAR(30));
Table Creation SQL for annotations.database.Member is:
CREATE TABLE MEMBER(
    FIRSTNAME VARCHAR(30),
    LASTNAME VARCHAR(50));
Table Creation SQL for annotations.database.Member is:
CREATE TABLE MEMBER(
    FIRSTNAME VARCHAR(30),
    LASTNAME VARCHAR(50),
    AGE INT);
Table Creation SQL for annotations.database.Member is:
CREATE TABLE MEMBER(
    FIRSTNAME VARCHAR(30),
    LASTNAME VARCHAR(50),
    AGE INT,
    REFERENCE VARCHAR(30) PRIMARY KEY);
*/
</code></pre>
<p><code>main()</code>方法会遍历命令行中的所有类名，<code>forName()</code>方法负责加载所有类，而<code>getAnnotation(DBTable.class)</code>则检查类上是否有<code>@DBTable</code>注解。如果有，则会找到表名并保存下来。然后通过<code>getDeclaredAnnotations()</code>加载和校验类中所有的字段。该方法返回定义在某个方法上的所有注解。<code>instanceof</code>操作符用来确定这些注解是否是<code>@SQLInteger</code>和<code>@SQLString</code>类型，不论是哪种，都会用表字段名来创建相关的<code>String</code>片段。注意，因为无法继承注解接口，所以使用<code>getDeclaredAnnotations()</code>是唯一一种能实现近似多态行为的方式。</p>
<p>内嵌的<code>@Constraint</code>注解会被传入<code>getConstraints()</code>方法，该方法用于创建包含SQL约束的字符串。</p>
<p>值得一提的是，用上述技巧来定义一套ORM是个略不成熟的方案。如果使用将表名作为参数的<code>@DBTable</code>类型，那么只要表名有变更，你就得重新编译Java代码，但你可能并不希望如此。有许多可用框架可以实现关系型数据库的ORM，并且越来越多的框架开始使用注解。</p>
<h2 id="43-用javac处理注解">4.3　用<code>javac</code>处理注解</h2>
<p>通过<code>javac</code>，你可以创建编译时注解处理器，并将注解应用于Java源文件，而不是编译后的类文件。不过这里有个重要的限制：无法通过注解处理器来修改源代码。唯一能影响结果的方法是创建新的文件。</p>
<p>如果注解处理器创建了一个新的源文件，则在新一轮处理中会检查该文件自身的注解。该工具会一轮接着一轮地持续处理，直到不再有新的源文件被创建，然后就编译所有的源文件。</p>
<p>你编写的每个注解都需要自己的处理器，但是<code>javac</code>可以轻松地将若干注解处理器进行组合。你可以指定多个要处理的类，并且还可以添加监听器来接收一轮处理完成的通知。</p>
<p>本节中的示例可带你入门，但是如果你需要深入了解，就要做好刻苦钻研的准备，多从Google和Stack Overflow上查找资料。</p>
<h3 id="431-最简单的处理器">4.3.1　最简单的处理器</h3>
<p>让我们从定义一个能想到的最简单的处理器（只是编译和测试一点东西）开始。下面是该注解的定义：</p>
<pre><code class="language-java">// annotations/simplest/Simple.java
// 一个非常简单的注解
package annotations.simplest;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.annotation.ElementType;

@Retention(RetentionPolicy.SOURCE)
@Target({ElementType.TYPE, ElementType.METHOD,
         ElementType.CONSTRUCTOR,
         ElementType.ANNOTATION_TYPE,
         ElementType.PACKAGE, ElementType.FIELD,
         ElementType.LOCAL_VARIABLE})
public @interface Simple {
    String value() default &quot;-default-&quot;;
}
</code></pre>
<p><code>@Retention</code>现在成了<code>SOURCE</code>，这意味着该注解不会存活到编译后的代码中。对于编译期的注解操作，并不需要这么做——这只是为了表明此时<code>javac</code>是唯一有机会处理注解的代理。</p>
<p><code>@Target</code>声明列举了几乎所有可能的目标类型（除了<code>PACKAGE</code>），这里同样也只是为了演示。</p>
<p>以下是用来测试的示例：</p>
<pre><code class="language-java">// annotations/simplest/SimpleTest.java
// 测试“Simple”注解
// {java annotations.simplest.SimpleTest}
package annotations.simplest;

@Simple
public class SimpleTest {
  @Simple
  int i;
  @Simple
  public SimpleTest() {}
  @Simple
  public void foo() {
    System.out.println(&quot;SimpleTest.foo()&quot;);
  }
  @Simple
  public void bar(String s, int i, float f) {
    System.out.println(&quot;SimpleTest.bar()&quot;);
  }
  @Simple
  public static void main(String[] args) {
    @Simple
    SimpleTest st = new SimpleTest();
    st.foo();
  }
}
/* 输出：
SimpleTest.foo()
*/
</code></pre>
<p>此处，我们用<code>@Simple</code>注解了所有<code>@Target</code>声明所允许的内容。</p>
<p>SimpleTest.java只要求Simple.java能成功编译，虽然编译的过程中什么都没有发生。<code>javac</code>允许使用<code>@Simple</code>注解（只要它还存在），但是并不会对它做任何事，直到我们创建了一个注解处理器，并将其绑定到编译器中。</p>
<p>以下示例是个非常简单的处理器，它所做的只是打印注解的信息：</p>
<pre><code class="language-java">// annotations/simplest/SimpleProcessor.java
// 一个非常简单的注解处理器
package annotations.simplest;
import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import java.util.*;

@SupportedAnnotationTypes(
  &quot;annotations.simplest.Simple&quot;)
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class SimpleProcessor
extends AbstractProcessor {
  @Override public boolean process(
    Set&lt;? extends TypeElement&gt; annotations,
    RoundEnvironment env) {
    for(TypeElement t : annotations)
      System.out.println(t);
    for(Element el :
      env.getElementsAnnotatedWith(Simple.class))
      display(el);
    return false;
  }
  private void display(Element el) {
    System.out.println(&quot;==== &quot; + el + &quot; ====&quot;);
    System.out.println(el.getKind() +
      &quot; : &quot; + el.getModifiers() +
      &quot; : &quot; + el.getSimpleName() +
      &quot; : &quot; + el.asType());
    if(el.getKind().equals(ElementKind.CLASS)) {
      TypeElement te = (TypeElement)el;
      System.out.println(te.getQualifiedName());
      System.out.println(te.getSuperclass());
      System.out.println(te.getEnclosedElements());
    }
    if(el.getKind().equals(ElementKind.METHOD)) {
      ExecutableElement ex = (ExecutableElement)el;
      System.out.print(ex.getReturnType() + &quot; &quot;);
      System.out.print(ex.getSimpleName() + &quot;(&quot;);
      System.out.println(ex.getParameters() + &quot;)&quot;);
    }
  }
}
</code></pre>
<p>已被废弃的旧<code>apt</code>（即Annotation Processing Tool，编译时注解处理器）版本的注解处理器需要额外的方法来确定哪些注解和Java版本可以被支持。而现在你可以简单地通过<code>@SupportedAnnotationTypes</code> 和 <code>@SupportedSourceVersion</code>注解来达到相同的目的（这个示例很好地诠释了注解如何做到简化代码）。</p>
<p>此处唯一需要实现的方法是<code>process()</code>，其中包含了所有的逻辑。第一个参数会告诉你有哪些注解，第二个参数则包含余下的所有信息。此处我们做的只是把注解（只有一个）都打印了出来，要了解其他功能，请参考<code>TypeElement</code>文档。</p>
<p>通过<code>process()</code>方法的第二个参数，我们遍历所有被<code>@Simple</code>注解的元素，并且对每个元素都调用了<code>display()</code>方法。每个<code>Element</code>都可以携带自身的基本信息，例如<code>getModifiers()</code>能够告诉我们它是否是<code>public</code>和<code>static</code>的。</p>
<p><code>Element</code>只能执行编译器解析过的所有基本对象共有的操作，而类和方法等则需要提取出额外的信息。因此（如果你能找到相关的文档，可能发现这是显而易见的，但是我能找到的所有文档都没提到这一点，因此我只能在Stack Overflow上寻找线索）你需要先检查它是哪种<code>ElementKind</code>，然后向下转型为更具体的元素类型——此处指针对<code>CLASS</code>的<code>TypeElement</code>，以及针对<code>METHOD</code>的<code>ExecutableElement</code>。然后，你就可以对这些<code>Element</code>类型调用额外的方法了。</p>
<p>动态向下转型（不会在编译期被检查）是一种“很不Java”的处理方式，因此看起来非常不直观，这也可能是我从来不想这么做的原因。相反，我花了好几天来研究应该如何读取信息，至少用已废弃的<code>apt</code>方式来实现都会多少更直观一些。目前为止，我仍然没有找到任何证据表明上述形式是规范，但在我看来它就是规范了。</p>
<p>如果你只是正常地编译SimpleTest.java，不会得到任何结果。想要得到注解的输出，就需要加上<code>-processor</code>标识和注解处理器类：</p>
<pre><code class="language-text">javac -processor annotations.simplest.SimpleProcessor SimpleTest.java
</code></pre>
<p>然后编译器会输出如下的结果：</p>
<pre><code class="language-text">annotations.simplest.Simple
==== annotations.simplest.SimpleTest ====
CLASS : [public] : SimpleTest : annotations.simplest.SimpleTest
annotations.simplest.SimpleTest
java.lang.Object
i,SimpleTest(),foo(),bar(java.lang.String,int,float),main(java.lang.String[])
==== i ====
FIELD : [] : i : int
==== SimpleTest() ====
CONSTRUCTOR : [public] : &lt;init&gt; : ()void
==== foo() ====
METHOD : [public] : foo : ()void
void foo()
==== bar(java.lang.String,int,float) ====
METHOD : [public] : bar : (java.lang.String,int,float)void
void bar(s,i,f)
==== main(java.lang.String[]) ====
METHOD : [public, static] : main : (java.lang.String[])void
void main(args)
</code></pre>
<p>这可以让你初步了解各种你日后可以探索的内容，包括参数名、类型、返回值等。</p>
<h3 id="432-更复杂的处理器">4.3.2　更复杂的处理器</h3>
<p>当你创建了一个配合<code>javac</code>使用的注解处理器后，便无法使用Java的反射功能，因为此时操作的是源代码，而不是编译后的类。各种<code>mirror</code>（镜子）<strong>3</strong>可以解决该问题，方法是让你在未编译的源代码中查看方法、字段、类型。</p>
<p><strong>3</strong>Java的设计者腼腆地提示，镜子就是指你发现反射的地方。</p>
<p>以下示例是一个注解，它从一个类中提取<code>public</code>方法，以将它们转换为接口：</p>
<pre><code class="language-java">// annotations/ifx/ExtractInterface.java
// 基于javac的注解处理
package annotations.ifx;
import java.lang.annotation.*;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.SOURCE)
public @interface ExtractInterface {
  String interfaceName() default &quot;-!!-&quot;;
}
</code></pre>
<p>其中<code>RetentionPolicy</code>是<code>SOURCE</code>，这是因为从类中提取接口后，就没有必要在类文件中继续保留该注解了。下面的测试类提供了一些可组成接口的<code>public</code>方法：</p>
<pre><code class="language-java">// annotations/ifx/Multiplier.java
// 基于javac的注解处理
// {java annotations.ifx.Multiplier}
package annotations.ifx;

@ExtractInterface(interfaceName=&quot;IMultiplier&quot;)
public class Multiplier {
  public boolean flag = false;
  private int n = 0;
  public int multiply(int x, int y) {
    int total = 0;
    for(int i = 0; i &lt; x; i++)
      total = add(total, y);
    return total;
  }
  public int fortySeven() { return 47; }
  private int add(int x, int y) {
    return x + y;
  }
  public double timesTen(double arg) {
    return arg * 10;
  }
  public static void main(String[] args) {
    Multiplier m = new Multiplier();
    System.out.println(
      &quot;11 * 16 = &quot; + m.multiply(11, 16));
  }
}
/* 输出：
11 * 16 = 176
*/
</code></pre>
<p><code>Multiplier</code>类（只能用于正整型）中有个<code>multiply()</code>方法，它多次调用私有的<code>add()</code>方法，以实现相乘操作。<code>add()</code>方法不是<code>public</code>的，因此并不属于接口。其他方法则提供了一些语法的变体。该注解的<code>interfaceName</code>被赋值为<code>IMultiplier</code>，以作为要创建的接口名。</p>
<p>下面的示例是一个编译期处理器，它会提取出感兴趣的方法，并创建新接口的源代码文件（该源文件之后会作为“编译阶段”的一部分，被自动编译）：</p>
<pre><code class="language-java">// annotations/ifx/IfaceExtractorProcessor.java
// 基于javac的注解处理
package annotations.ifx;
import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import javax.lang.model.util.*;
import java.util.*;
import java.util.stream.*;
import java.io.*;

@SupportedAnnotationTypes(
  &quot;annotations.ifx.ExtractInterface&quot;)
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class IfaceExtractorProcessor
extends AbstractProcessor {
  private ArrayList&lt;Element&gt;
    interfaceMethods = new ArrayList&lt;&gt;();
  Elements elementUtils;
  private ProcessingEnvironment processingEnv;
  @Override public void init(
    ProcessingEnvironment processingEnv) {
    this.processingEnv = processingEnv;
    elementUtils = processingEnv.getElementUtils();
  }
  @Override public boolean process(
    Set&lt;? extends TypeElement&gt; annotations,
    RoundEnvironment env) {
    for(Element elem:env.getElementsAnnotatedWith(
        ExtractInterface.class)) {
      String interfaceName = elem.getAnnotation(
        ExtractInterface.class).interfaceName();
      for(Element enclosed :
          elem.getEnclosedElements()) {
        if(enclosed.getKind()
           .equals(ElementKind.METHOD) &amp;&amp;
           enclosed.getModifiers()
           .contains(Modifier.PUBLIC) &amp;&amp;
           !enclosed.getModifiers()
           .contains(Modifier.STATIC)) {
          interfaceMethods.add(enclosed);
        }
      }
      if(interfaceMethods.size() &gt; 0)
        writeInterfaceFile(interfaceName);
    }
    return false;
  }
  private void
  writeInterfaceFile(String interfaceName) {
    try(
      Writer writer = processingEnv.getFiler()
        .createSourceFile(interfaceName)
        .openWriter()
    ) {
      String packageName = elementUtils
        .getPackageOf(interfaceMethods
                      .get(0)).toString();
      writer.write(
        &quot;package &quot; + packageName + &quot;;\n&quot;);
      writer.write(&quot;public interface &quot; +
        interfaceName + &quot; {\n&quot;);
      for(Element elem : interfaceMethods) {
        ExecutableElement method =
          (ExecutableElement)elem;
        String signature = &quot;  public &quot;;
        signature += method.getReturnType() + &quot; &quot;;
        signature += method.getSimpleName();
        signature += createArgList(
          method.getParameters());
        System.out.println(signature);
        writer.write(signature + &quot;;\n&quot;);
      }
      writer.write(&quot;}&quot;);
    } catch(Exception e) {
      throw new RuntimeException(e);
    }
  }
  private String createArgList(
    List&lt;? extends VariableElement&gt; parameters) {
    String args = parameters.stream()
      .map(p -&gt; p.asType() + &quot; &quot; + p.getSimpleName())
      .collect(Collectors.joining(&quot;, &quot;));
    return &quot;(&quot; + args + &quot;)&quot;;
  }
}
</code></pre>
<p><code>Elements</code>对象<code>elementUtils</code>是个<code>static</code>工具的集合，我们通过它来在<code>writeInterfaceFile()</code>中找到包名。</p>
<p><code>getEnclosedElements()</code>方法生成被某个特定元素“围住”的所有元素。此处，该类围住了其所有的组件。通过<code>getKind()</code>，我们可以找到所有的<code>public</code>和<code>static</code>的方法，并将它们添加到<code>interfaceMethods</code>列表中。然后<code>writeInterfaceFile()</code>通过该列表来生成新的接口定义。注意在<code>writeInterfaceFile()</code>中对<code>ExecutableElement</code>的向下转型使得我们可以提取所有的方法信息。<code>createArgList()</code>则是一个生成参数列表的辅助方法。</p>
<p><code>Filer</code>（由<code>getFiler()</code>生成）是一种创建新文件的<code>PrintWriter</code>。之所以使用<code>Filer</code>对象而非某个普通的<code>PrintWriter</code>，是因为<code>Filer</code>对象允许<code>javac</code>持续跟踪你创建的所有新文件，从而可以检查它们的注解，并在额外的“编译阶段”中编译它们。</p>
<p>如下代码是使用处理器来编译的命令行指令：</p>
<pre><code class="language-text">javac -processor annotations.ifx.IfaceExtractorProcessor Multiplier.java
</code></pre>
<p>它所生成的IMultiplier.java文件，看起来会像下面这样（通过上面的处理器中的<code>println()</code>语句，你也许能够猜到）：</p>
<pre><code class="language-java">package annotations.ifx;
public interface IMultiplier {
  public int multiply(int x, int y);
  public int fortySeven();
  public double timesTen(double arg);
}
</code></pre>
<p>该文件同样也会被<code>javac</code>所编译（作为“编译阶段”的一部分），因此你可以在同一个目录中看到IMultiplier.class文件。</p>
<h2 id="44-基于注解的单元测试">4.4　基于注解的单元测试</h2>
<p><strong>单元测试</strong>是一种常见做法——通过为类中的每个方法都创建一个或多个测试，以定期检测类中各部分的行为是否正确。目前在Java中最流行的单元测试工具是JUnit（参见基础卷第16章）。JUnit 4引入了注解。<strong>4</strong>在加入注解之前，JUnit的一个主要问题是需要大量的额外工作来设置和运行JUnit单元测试。随着时间的推移，这种情况已有所好转，但是注解则使测试更接近“你可能拥有的最简单的单元测试系统”这个目标。</p>
<p><strong>4</strong>我原本想基于这里所述的设计思路实现一个“更好的JUnit”。然而，看起来JUnit 4也同样引入了很多相同的设计思路，因此还是跟随JUnit的原生版本比较简单。</p>
<p>在JUnit 4之前的版本中，你需要创建一个单独的类来持有你的单元测试代码。而在JUnit 4中，你可以将单元测试集成到要测试的类中，从而将各种耗时和故障降到最低值。这种方法还有额外的好处——它测试<code>private</code>方法就和测试<code>public</code>方法一样简单。</p>
<p>下面这个测试框架的示例是基于注解的，因此叫作<code>@Unit</code>。只用一个<code>@Test</code>注解来标识出需要测试的方法，是最基础也可能是你最常用的测试形式。也可以选择让测试方法不接收参数，仅返回一个<code>boolean</code>值来表示测试是成功还是失败。你可以给测试方法起任何你喜欢的名字。同样，<code>@Unit</code>注解的测试方法可以支持任何你想要的访问权限，包括<code>private</code>。</p>
<p>要使用<code>@Unit</code>，你需要引入<code>onjava.atunit</code>，用<code>@Unit</code>注解标签标记出适当的方法和字段（你会在后面的示例中学到），然后让构建系统在结果类上运行<code>@Unit</code>。下面是个简单的示例：</p>
<pre><code class="language-java">// annotations/AtUnitExample1.java
// {java onjava.atunit.AtUnit
// build/classes/java/main/annotations/AtUnitExample1.class}
package annotations;
import onjava.atunit.*;
import onjava.*;

public class AtUnitExample1 {
  public String methodOne() {
    return &quot;This is methodOne&quot;;
  }
  public int methodTwo() {
    System.out.println(&quot;This is methodTwo&quot;);
    return 2;
  }
  @Test
  boolean methodOneTest() {
    return methodOne().equals(&quot;This is methodOne&quot;);
  }
  @Test
  boolean m2() { return methodTwo() == 2; }
  @Test
  private boolean m3() { return true; }
  // 错误输出展示：
  @Test
  boolean failureTest() { return false; }
  @Test
  boolean anotherDisappointment() {
    return false;
  }
}
/* 输出：
annotations.AtUnitExample1
  . anotherDisappointment (failed)
  . methodOneTest
  . failureTest (failed)
  . m2 This is methodTwo

  . m3
(5 tests)

&gt;&gt;&gt; 2 FAILURES &lt;&lt;&lt;
  annotations.AtUnitExample1: anotherDisappointment
  annotations.AtUnitExample1: failureTest
*/
</code></pre>
<p>要用<code>@Unit</code>测试的类必须放在包中。</p>
<p><code>methodOneTest()</code>、<code>m2()</code>、<code>m3()</code>、<code>failureTest()</code>和<code>anotherDisappointment()</code>等方法前面的<code>@Test</code>注解告诉<code>@Unit</code>要将这些方法作为单元测试来运行，它同样也会确保这些方法不接收任何参数，并且返回值为<code>boolean</code>或<code>void</code>。你编写单元测试时，只需要确定测试是成功还是失败，并分别返回<code>true</code>或者<code>false</code>（对于返回<code>boolean</code>值的方法）。</p>
<p>如果你对JUnit很熟悉，同样会注意到<code>@Unit</code>具有更丰富的信息输出。你可以看到正在运行的测试，因此测试产生的输出会更有用，并且最后它会告诉你导致失败的类和测试用例。</p>
<p>如果将测试方法嵌入类中对你来说并不适用，那么你就无须这么做。要创建非嵌入式的测试，最简单的方法是使用继承：</p>
<pre><code class="language-java">// annotations/AUExternalTest.java
// 创建非嵌入的测试
// {java onjava.atunit.AtUnit
// build/classes/java/main/annotations/AUExternalTest.class}
package annotations;
import onjava.atunit.*;
import onjava.*;

public class
AUExternalTest extends AtUnitExample1 {
  @Test
  boolean tMethodOne() {
    return methodOne().equals(&quot;This is methodOne&quot;);
  }
  @Test
  boolean tMethodTwo() {
    return methodTwo() == 2;
  }
}
/* 输出：
annotations.AUExternalTest
  . tMethodOne
  . tMethodTwo This is methodTwo

OK (2 tests)
*/
</code></pre>
<p>以上示例同样展示了灵活命名的好处。这里，直接用于测试某方法的<code>@Test</code>方法以该方法的方法名前面加“t”来命名（我并不是推荐这种命名方式，只是举了个可能的例子）。</p>
<p>你也可以用组合的方式来创建非嵌入的测试：</p>
<pre><code class="language-java">// annotations/AUComposition.java
// 创建非嵌入的测试
// {java onjava.atunit.AtUnit
// build/classes/java/main/annotations/AUComposition.class}
package annotations;
import onjava.atunit.*;
import onjava.*;

public class AUComposition {
  AtUnitExample1 testObject = new AtUnitExample1();
  @Test
  boolean tMethodOne() {
    return testObject.methodOne()
      .equals(&quot;This is methodOne&quot;);
  }
  @Test
  boolean tMethodTwo() {
    return testObject.methodTwo() == 2;
  }
}
/* 输出：
annotations.AUComposition
  . tMethodOne
  . tMethodTwo This is methodTwo

OK (2 tests)
*/
</code></pre>
<p>这里给每个测试都创建了一个<code>AUComposition</code>对象，因此也为每个测试都创建了一个新的<code>testObject</code>成员。</p>
<p>和JUnit不同，这里并没有专门的“assert”（断言）方法，而是使用了<code>@Test</code>方法的第二种形式，返回了<code>void</code>（或者<code>boolean</code>，如果你仍然希望在这里返回<code>true</code>或<code>false</code>）。如果要验证成功，你可以使用Java的断言语句。Java断言一般在<code>java</code>命令行指令中由<code>-ea</code>标签来启用，但是<code>@Unit</code>会自动启用断言。如果要表示失败，你甚至可以使用异常。<code>@Unit</code>的设计目标之一是尽可能不增加语法复杂度，而Java断言和异常则是报告错误所必需的。如果测试方法引发了失败断言或者异常，则会被视为测试失败，但是<code>@Unit</code>并不会因此阻塞——它会持续运行，直到所有的测试都运行完毕。如下例所示：</p>
<pre><code class="language-java">// annotations/AtUnitExample2.java
// 断言和异常可以在@Tests中使用
// {java onjava.atunit.AtUnit
// build/classes/java/main/annotations/AtUnitExample2.class}
package annotations;
import java.io.*;
import onjava.atunit.*;
import onjava.*;

public class AtUnitExample2 {
  public String methodOne() {
    return &quot;This is methodOne&quot;;
  }
  public int methodTwo() {
    System.out.println(&quot;This is methodTwo&quot;);
    return 2;
  }
  @Test
  void assertExample() {
    assert methodOne().equals(&quot;This is methodOne&quot;);
  }
  @Test
  void assertFailureExample() {
    assert 1 == 2: &quot;What a surprise!&quot;;
  }
  @Test
  void exceptionExample() throws IOException {
    try(FileInputStream fis =
        new FileInputStream(&quot;nofile.txt&quot;)) {} // 抛出
  }
  @Test
  boolean assertAndReturn() {
    // 附带消息的断言：
    assert methodTwo() == 2: &quot;methodTwo must equal 2&quot;;
    return methodOne().equals(&quot;This is methodOne&quot;);
  }
}
/* 输出：
annotations.AtUnitExample2
  . assertFailureExample java.lang.AssertionError: What
a surprise!
(failed)
  . assertExample
  . exceptionExample java.io.FileNotFoundException:
nofile.txt (The system cannot find the file specified)
(failed)
  . assertAndReturn This is methodTwo

(4 tests)

&gt;&gt;&gt; 2 FAILURES &lt;&lt;&lt;
  annotations.AtUnitExample2: assertFailureExample
  annotations.AtUnitExample2: exceptionExample
*/
</code></pre>
<p>下面是用断言实现的非嵌入式测试，它对<code>java.util.HashSet</code>做了一些简单的测试：</p>
<pre><code class="language-java">// annotations/HashSetTest.java
// {java onjava.atunit.AtUnit
// build/classes/java/main/annotations/HashSetTest.class}
package annotations;
import java.util.*;
import onjava.atunit.*;
import onjava.*;

public class HashSetTest {
  HashSet&lt;String&gt; testObject = new HashSet&lt;&gt;();
  @Test
  void initialization() {
    assert testObject.isEmpty();
  }
  @Test
  void tContains() {
    testObject.add(&quot;one&quot;);
    assert testObject.contains(&quot;one&quot;);
  }
  @Test
  void tRemove() {
    testObject.add(&quot;one&quot;);
    testObject.remove(&quot;one&quot;);
    assert testObject.isEmpty();
  }
}
/* 输出：
annotations.HashSetTest
  . tContains
  . initialization
  . tRemove
OK (3 tests)
*/
</code></pre>
<p>在没有其他约束的情况下，继承的方式看起来似乎更简单。</p>
<p>在每个单元测试中，<code>@Unit</code>都通过无参数的构造方法，为每个要测试的类创建了一个对象。测试会在该对象上进行，然后该对象会被丢弃，以防止各种副作用渗透到其他单元测试中。这里依赖无参数的构造方法来创建对象。如果没有无参数的构造函数，或者需要更复杂的构造函数，你需要创建一个静态方法来构建对象，并添加<code>@TestObjectCreate</code>注解，就像下面这样：</p>
<pre><code class="language-java">// annotations/AtUnitExample3.java
// {java onjava.atunit.AtUnit
// build/classes/java/main/annotations/AtUnitExample3.class}
package annotations;
import onjava.atunit.*;
import onjava.*;

public class AtUnitExample3 {
  private int n;
  public AtUnitExample3(int n) { this.n = n; }
  public int getN() { return n; }
  public String methodOne() {
    return &quot;This is methodOne&quot;;
  }
  public int methodTwo() {
    System.out.println(&quot;This is methodTwo&quot;);
    return 2;
  }
  @TestObjectCreate
  static AtUnitExample3 create() {
    return new AtUnitExample3(47);
  }
  @Test
  boolean initialization() { return n == 47; }
  @Test
  boolean methodOneTest() {
    return methodOne().equals(&quot;This is methodOne&quot;);
  }
  @Test
  boolean m2() { return methodTwo() == 2; }
}
/* 输出：
annotations.AtUnitExample3
  . initialization
  . methodOneTest
  . m2 This is methodTwo

OK (3 tests)
*/
</code></pre>
<p><code>@TestObjectCreate</code>方法必须是静态的，并且必须返回你测试的类型的对象。<code>@Unit</code>程序会确保这些。</p>
<p>有时你需要额外的字段来支持单元测试。<code>@TestProperty</code>注解可以标识仅用于单元测试的字段（这样在交付给客户前便可以随意移除这些字段）。下面是一个示例，它读取一个被<code>String.split()</code>方法切割后的字符串的值，该值会作为输入来生成测试对象：</p>
<pre><code class="language-java">// annotations/AtUnitExample4.java
// {java onjava.atunit.AtUnit
// build/classes/java/main/annotations/AtUnitExample4.class}
// {VisuallyInspectOutput}
package annotations;
import java.util.*;
import onjava.atunit.*;
import onjava.*;

public class AtUnitExample4 {
  static String theory = &quot;All brontosauruses &quot; +
    &quot;are thin at one end, much MUCH thicker in the &quot; +
    &quot;middle, and then thin again at the far end.&quot;;
  private String word;
  private Random rand = new Random(); // 基于时间因素的随机种子
  public AtUnitExample4(String word) {
    this.word = word;
  }
  public String getWord() { return word; }
  public String scrambleWord() {
    List&lt;Character&gt; chars = Arrays.asList(
      ConvertTo.boxed(word.toCharArray()));
    Collections.shuffle(chars, rand);
    StringBuilder result = new StringBuilder();
    for(char ch : chars)
      result.append(ch);
    return result.toString();
  }
  @TestProperty
  static List&lt;String&gt; input =
    Arrays.asList(theory.split(&quot; &quot;));
  @TestProperty
  static Iterator&lt;String&gt; words = input.iterator();
  @TestObjectCreate
  static AtUnitExample4 create() {
    if(words.hasNext())
      return new AtUnitExample4(words.next());
    else
      return null;
  }
  @Test
  boolean words() {
    System.out.println(&quot;'&quot; + getWord() + &quot;'&quot;);
    return getWord().equals(&quot;are&quot;);
  }
  @Test
  boolean scramble1() {
    // 用指定的种子得到可验证的结果：
    rand = new Random(47);
    System.out.println(&quot;'&quot; + getWord() + &quot;'&quot;);
    String scrambled = scrambleWord();
    System.out.println(scrambled);
    return scrambled.equals(&quot;lAl&quot;);
  }
  @Test
  boolean scramble2() {
    rand = new Random(74);
    System.out.println(&quot;'&quot; + getWord() + &quot;'&quot;);
    String scrambled = scrambleWord();
    System.out.println(scrambled);
    return scrambled.equals(&quot;tsaeborornussu&quot;);
  }
}
/* 输出：
annotations.AtUnitExample4
  . words 'All'
(failed)
  . scramble1 'brontosauruses'
ntsaueorosurbs
(failed)
  . scramble2 'are'
are
(failed)
(3 tests)

&gt;&gt;&gt; 3 FAILURES &lt;&lt;&lt;
  annotations.AtUnitExample4: words
  annotations.AtUnitExample4: scramble1
  annotations.AtUnitExample4: scramble2
*/
</code></pre>
<p><code>@TestProperty</code>同样可以用来标识在测试期间可用，但自身并不是测试的方法。</p>
<p>这个程序依赖于测试执行的顺序，通常来说这并不是一种好的实现方式。</p>
<p>如果测试对象的创建过程需要执行初始化，而且需要在稍后清理对象，你可以选择添加一个静态的<code>@TestObjectCleanup</code>方法，以在使用完测试对象后执行清理工作。在下一个示例中，<code>@TestObjectCreate</code>通过打开一个文件来创建各个测试对象，因此必须在丢弃测试对象前关闭该文件。</p>
<pre><code class="language-java">// annotations/AtUnitExample5.java
// {java onjava.atunit.AtUnit
// build/classes/java/main/annotations/AtUnitExample5.class}
package annotations;
import java.io.*;
import onjava.atunit.*;
import onjava.*;

public class AtUnitExample5 {
  private String text;
  public AtUnitExample5(String text) {
    this.text = text;
  }
  @Override public String toString() { return text; }
  @TestProperty
  static PrintWriter output;
  @TestProperty
  static int counter;
  @TestObjectCreate
  static AtUnitExample5 create() {
    String id = Integer.toString(counter++);
    try {
      output = new PrintWriter(&quot;Test&quot; + id + &quot;.txt&quot;);
    } catch(IOException e) {
      throw new RuntimeException(e);
    }
    return new AtUnitExample5(id);
  }
  @TestObjectCleanup
  static void cleanup(AtUnitExample5 tobj) {
    System.out.println(&quot;Running cleanup&quot;);
    output.close();
  }
  @Test
  boolean test1() {
    output.print(&quot;test1&quot;);
    return true;
  }
  @Test
  boolean test2() {
    output.print(&quot;test2&quot;);
    return true;
  }
  @Test
  boolean test3() {
    output.print(&quot;test3&quot;);
    return true;
  }
}
/* 输出：
annotations.AtUnitExample5
  . test1
Running cleanup
  . test3
Running cleanup
  . test2
Running cleanup
OK (3 tests)
*/
</code></pre>
<p>从以上输出可以看出，在每项测试之后，清理方法都被自动执行了。</p>
<h3 id="441-在unit中使用泛型">4.4.1　在<code>@Unit</code>中使用泛型</h3>
<p>泛型会带来一个特别的问题，因为你无法“笼统地测试”，而只能对特定的类型参数或参数集合进行测试。解决这个问题的办法很简单：从泛型类的某个具体版本继承一个测试类。</p>
<p>下面的示例简单地实现了一个栈：</p>
<pre><code class="language-java">// annotations/StackL.java
// 用LinkedList构建的栈
package annotations;
import java.util.*;

public class StackL&lt;T&gt; {
  private LinkedList&lt;T&gt; list = new LinkedList&lt;&gt;();
  public void push(T v) { list.addFirst(v); }
  public T top() { return list.getFirst(); }
  public T pop() { return list.removeFirst(); }
}
</code></pre>
<p>如果要测试字符串的版本，则从<code>StackL&lt;String&gt;</code>继承一个测试类：</p>
<pre><code class="language-java">// annotations/StackLStringTst.java
// 将@Unit应用于泛型
// {java onjava.atunit.AtUnit
// build/classes/java/main/annotations/StackLStringTst.class}
package annotations;
import onjava.atunit.*;
import onjava.*;

public class
StackLStringTst extends StackL&lt;String&gt; {
  @Test
  void tPush() {
    push(&quot;one&quot;);
    assert top().equals(&quot;one&quot;);
    push(&quot;two&quot;);
    assert top().equals(&quot;two&quot;);
  }
  @Test
  void tPop() {
    push(&quot;one&quot;);
    push(&quot;two&quot;);
    assert pop().equals(&quot;two&quot;);
    assert pop().equals(&quot;one&quot;);
  }
  @Test
  void tTop() {
    push(&quot;A&quot;);
    push(&quot;B&quot;);
    assert top().equals(&quot;B&quot;);
    assert top().equals(&quot;B&quot;);
  }
}
/* 输出：
annotations.StackLStringTst
  . tPop
  . tTop
  . tPush
OK (3 tests)
*/
</code></pre>
<p>继承的唯一潜在缺点是，你会失去访问被测试类中<code>private</code>方法的能力。如果你不希望这样，则可以将该方法设为<code>protected</code>，或者添加一个非私有的<code>@TestProperty</code>方法来调用该私有方法（本章稍后介绍的<code>AtUnitRemover</code>工具会从产品代码中剥离<code>@TestProperty</code>方法）。</p>
<p><code>@Unit</code>会查找包含适当注解的类文件，然后执行<code>@Test</code>方法。对于<code>@Unit</code>测试系统，我的主要目标是使它极度透明，仅需要添加<code>@Test</code>方法即可上手使用，而不需要其他的特殊代码或知识（现代版本的JUnit遵从了这个思路）。要想不添加任何新的障碍就实现测试的编写是基本不可能的，因此<code>@Unit</code>会尽力使过程变得更轻松。只有这样，你才会更愿意编写测试。</p>
<h3 id="442-实现unit">4.4.2　实现<code>@Unit</code></h3>
<p>首先，我们来定义所有的注解类型。这些都是很简单的标签，并没有任何字段。在本章开始已经介绍了<code>@Test</code>标签的定义，接下来是其余的注解：</p>
<pre><code class="language-java">// onjava/atunit/TestObjectCreate.java
// @Unit @TestObjectCreate标签
package onjava.atunit;
import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface TestObjectCreate {}
// onjava/atunit/TestObjectCleanup.java
// @Unit @TestObjectCleanup标签
package onjava.atunit;
import java.lang.annotation.*;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface TestObjectCleanup {}
// onjava/atunit/TestProperty.java
// @Unit @TestProperty标签
package onjava.atunit;
import java.lang.annotation.*;

// 字段（Field）和方法（Method）都可以被标记为属性（property）：
@Target({ElementType.FIELD, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface TestProperty {}
</code></pre>
<p>所有测试的生命周期都限定在<code>RUNTIME</code>内，这是因为<code>@Unit</code>系统必须在编译后的代码中检测到这些测试。</p>
<p>为了实现运行这些测试的系统，我们利用反射来提取注解。程序会利用这些信息来决定如何构建测试对象，并在其上运行测试。注解使得结果出乎意料地简单易懂：</p>
<pre><code class="language-java">// onjava/atunit/AtUnit.java
// 一个基于注解的单元测试框架
// {java onjava.atunit.AtUnit}
package onjava.atunit;
import java.lang.reflect.*;
import java.io.*;
import java.util.*;
import java.nio.file.*;
import java.util.stream.*;
import onjava.*;

public class AtUnit implements ProcessFiles.Strategy {
  static Class&lt;?&gt; testClass;
  static List&lt;String&gt; failedTests= new ArrayList&lt;&gt;();
  static long testsRun = 0;
  static long failures = 0;
  public static void
  main(String[] args) throws Exception {
    ClassLoader.getSystemClassLoader()
      .setDefaultAssertionStatus(true); // 启用断言
    new ProcessFiles(new AtUnit(), &quot;class&quot;).start(args);
    if(failures == 0)
      System.out.println(&quot;OK (&quot; + testsRun + &quot; tests)&quot;);
    else {
      System.out.println(&quot;(&quot; + testsRun + &quot; tests)&quot;);
      System.out.println(
        &quot;\n&gt;&gt;&gt; &quot; + failures + &quot; FAILURE&quot; +
        (failures &gt; 1 ? &quot;S&quot; : &quot;&quot;) + &quot; &lt;&lt;&lt;&quot;);
      for(String failed : failedTests)
        System.out.println(&quot;  &quot; + failed);
    }
  }
  @Override public void process(File cFile) {
    try {
      String cName = ClassNameFinder.thisClass(
        Files.readAllBytes(cFile.toPath()));
      if(!cName.startsWith(&quot;public:&quot;))
        return;
      cName = cName.split(&quot;:&quot;)[1];
      if(!cName.contains(&quot;.&quot;))
        return; // 忽略未包装的类
      testClass = Class.forName(cName);
    } catch(IOException | ClassNotFoundException e) {
      throw new RuntimeException(e);
    }
    TestMethods testMethods = new TestMethods();
    Method creator = null;
    Method cleanup = null;
    for(Method m : testClass.getDeclaredMethods()) {
      testMethods.addIfTestMethod(m);
      if(creator == null)
        creator = checkForCreatorMethod(m);
      if(cleanup == null)
        cleanup = checkForCleanupMethod(m);
    }
    if(testMethods.size() &gt; 0) {
      if(creator == null)
        try {
          if(!Modifier.isPublic(testClass
             .getDeclaredConstructor()
             .getModifiers())) {
            System.out.println(&quot;Error: &quot; + testClass +
              &quot; zero-argument constructor must be public&quot;);
            System.exit(1);
          }
        } catch(NoSuchMethodException e) {
          // 同步的无参构造器，没有问题
        }
      System.out.println(testClass.getName());
    }
    for(Method m : testMethods) {
      System.out.print(&quot;  . &quot; + m.getName() + &quot; &quot;);
      try {
        Object testObject = createTestObject(creator);
        boolean success = false;
        try {
          if(m.getReturnType().equals(boolean.class))
            success = (Boolean)m.invoke(testObject);
          else {
            m.invoke(testObject);
            success = true; // 如果没有断言失败
          }
        } catch(InvocationTargetException e) {
          // 实际的异常在e中：
          System.out.println(e.getCause());
        }
        System.out.println(success ? &quot;&quot; : &quot;(failed)&quot;);
        testsRun++;
        if(!success) {
          failures++;
          failedTests.add(testClass.getName() +
            &quot;: &quot; + m.getName());
        }
        if(cleanup != null)
          cleanup.invoke(testObject, testObject);
      } catch(IllegalAccessException |
              IllegalArgumentException |
              InvocationTargetException e) {
        throw new RuntimeException(e);
      }
    }
  }
  public static
  class TestMethods extends ArrayList&lt;Method&gt; {
    void addIfTestMethod(Method m) {
      if(m.getAnnotation(Test.class) == null)
        return;
      if(!(m.getReturnType().equals(boolean.class) ||
          m.getReturnType().equals(void.class)))
        throw new RuntimeException(&quot;@Test method&quot; +
          &quot; must return boolean or void&quot;);
      m.setAccessible(true); // 如果是private的，等等
      add(m);
    }
  }
  private static
  Method checkForCreatorMethod(Method m) {
    if(m.getAnnotation(TestObjectCreate.class) == null)
      return null;
    if(!m.getReturnType().equals(testClass))
      throw new RuntimeException(&quot;@TestObjectCreate &quot; +
        &quot;must return instance of Class to be tested&quot;);
    if((m.getModifiers() &amp;
         java.lang.reflect.Modifier.STATIC) &lt; 1)
      throw new RuntimeException(&quot;@TestObjectCreate &quot; +
        &quot;must be static.&quot;);
    m.setAccessible(true);
    return m;
  }
  private static
  Method checkForCleanupMethod(Method m) {
    if(m.getAnnotation(TestObjectCleanup.class) == null)
      return null;
    if(!m.getReturnType().equals(void.class))
      throw new RuntimeException(&quot;@TestObjectCleanup &quot; +
        &quot;must return void&quot;);
    if((m.getModifiers() &amp;
        java.lang.reflect.Modifier.STATIC) &lt; 1)
      throw new RuntimeException(&quot;@TestObjectCleanup &quot; +
        &quot;must be static.&quot;);
    if(m.getParameterTypes().length == 0 ||
       m.getParameterTypes()[0] != testClass)
      throw new RuntimeException(&quot;@TestObjectCleanup &quot; +
        &quot;must take an argument of the tested type.&quot;);
    m.setAccessible(true);
    return m;
  }
  private static Object
  createTestObject(Method creator) {
    if(creator != null) {
      try {
        return creator.invoke(testClass);
      } catch(IllegalAccessException |
              IllegalArgumentException |
              InvocationTargetException e) {
        throw new RuntimeException(&quot;Couldn't run &quot; +
          &quot;@TestObject (creator) method.&quot;);
      }
    } else { // 使用无参数的构造器：
      try {
        return testClass
          .getConstructor().newInstance();
      } catch(InstantiationException |
              NoSuchMethodException |
              InvocationTargetException |
              IllegalAccessException e) {
        throw new RuntimeException(
          &quot;Couldn't create a test object. &quot; +
          &quot;Try using a @TestObject method.&quot;);
      }
    }
  }
}
</code></pre>
<p>尽管这可能算是“过早重构”（因为本书中只用过一次），AtUnit.java使用了另一个叫作<code>ProcessFiles</code>的工具来单步遍历命令行中的每个参数，以及确定它是目录还是文件，并进行相应的处理。其中包含了一个可定制的<code>Strategy</code>（策略）接口，因此可应用于多种方案实现。</p>
<pre><code class="language-java">// onjava/ProcessFiles.java
package onjava;
import java.io.*;
import java.nio.file.*;

public class ProcessFiles {
  public interface Strategy {
    void process(File file);
  }
  private Strategy strategy;
  private String ext;
  public ProcessFiles(Strategy strategy, String ext) {
    this.strategy = strategy;
    this.ext = ext;
  }
  public void start(String[] args) {
    try {
      if(args.length == 0)
        processDirectoryTree(new File(&quot;.&quot;));
      else
        for(String arg : args) {
          File fileArg = new File(arg);
          if(fileArg.isDirectory())
            processDirectoryTree(fileArg);
          else {
            // 用户可以去掉后缀名：
            if(!arg.endsWith(&quot;.&quot; + ext))
              arg += &quot;.&quot; + ext;
            strategy.process(
              new File(arg).getCanonicalFile());
          }
        }
    } catch(IOException e) {
      throw new RuntimeException(e);
    }
  }
  public void
  processDirectoryTree(File root) throws IOException {
    PathMatcher matcher = FileSystems.getDefault()
      .getPathMatcher(&quot;glob:**/*.{&quot; + ext + &quot;}&quot;);
    Files.walk(root.toPath())
      .filter(matcher::matches)
      .forEach(p -&gt; strategy.process(p.toFile()));
  }
}
</code></pre>
<p><code>AtUnit</code>类实现了<code>ProcessFiles.Strategy</code>，其中包含<code>process()</code>方法。由此，<code>AtUnit</code>的实例可以传递给<code>ProcessFiles</code>构造器。构造器的第二个参数告诉<code>ProcessFiles</code>去查找所有文件名后缀为.class的文件。</p>
<p>以下是简单的用法示例：</p>
<pre><code class="language-java">// annotations/DemoProcessFiles.java
import onjava.ProcessFiles;

public class DemoProcessFiles {
  public static void main(String[] args) {
    new ProcessFiles(file -&gt; System.out.println(file),
      &quot;java&quot;).start(args);
  }
}
/* 输出：
.\AtUnitExample1.java
.\AtUnitExample2.java
.\AtUnitExample3.java
.\AtUnitExample4.java
.\AtUnitExample5.java
.\AUComposition.java
.\AUExternalTest.java
.\database\Constraints.java
.\database\DBTable.java
.\database\Member.java
.\database\SQLInteger.java
.\database\SQLString.java
.\database\TableCreator.java
.\database\Uniqueness.java
.\DemoProcessFiles.java
.\HashSetTest.java
.\ifx\ExtractInterface.java
.\ifx\IfaceExtractorProcessor.java
.\ifx\Multiplier.java
.\PasswordUtils.java
.\simplest\Simple.java
.\simplest\SimpleProcessor.java
.\simplest\SimpleTest.java
.\SimulatingNull.java
.\StackL.java
.\StackLStringTst.java
.\Testable.java
.\UseCase.java
.\UseCaseTracker.java
*/
</code></pre>
<p>在没有命令行参数的情况下，程序会遍历当前的目录树。你还可以提供多个参数，可以是类文件（不论文件名是否带有.class后缀）或目录。</p>
<p>回到我们关于AtUnit.java的讨论，<code>@Unit</code>会自动找到可测试的类和方法，因此并不需要“套件”机制。</p>
<p>AtUnit.java在寻找类文件时有个必须解决的问题：从类文件名无法确切地得知限定的类名（包括包名）。要获取这个信息，就必须分析类文件。这并非易事，但也并非做不到。<strong>5</strong>当找到一个.class文件时，程序会打开该文件，读取它的二进制数据，并传给<code>ClassNameFinder.thisClass()</code>。此处，我们将进入“字节码工程”的领域，因为我们实际上已经在分析类文件的内容了。</p>
<p><strong>5</strong>我和Jeremy Meyer一起花了几乎一整天才搞清楚这件事。</p>
<pre><code class="language-java">// onjava/atunit/ClassNameFinder.java
// {java onjava.atunit.ClassNameFinder}
package onjava.atunit;
import java.io.*;
import java.nio.file.*;
import java.util.*;
import onjava.*;

public class ClassNameFinder {
  public static String thisClass(byte[] classBytes) {
    Map&lt;Integer,Integer&gt; offsetTable = new HashMap&lt;&gt;();
    Map&lt;Integer,String&gt; classNameTable =
      new HashMap&lt;&gt;();
    try {
      DataInputStream data = new DataInputStream(
        new ByteArrayInputStream(classBytes));
      int magic = data.readInt();  // 0xcafebabe
      int minorVersion = data.readShort();
      int majorVersion = data.readShort();
      int constantPoolCount = data.readShort();
      int[] constantPool = new int[constantPoolCount];
      for(int i = 1; i &lt; constantPoolCount; i++) {
        int tag = data.read();
        // int tableSize;
        switch(tag) {
          case 1: // UTF
            int length = data.readShort();
            char[] bytes = new char[length];
            for(int k = 0; k &lt; bytes.length; k++)
              bytes[k] = (char)data.read();
            String className = new String(bytes);
            classNameTable.put(i, className);
            break;
          case 5: // LONG
          case 6: // DOUBLE
            data.readLong(); // 丢弃8字节
            i++; // 必要的特殊处理，跳过此处
            break;
          case 7: // CLASS
            int offset = data.readShort();
            offsetTable.put(i, offset);
            break;
          case 8: // STRING
            data.readShort(); // 抛弃2字节
            break;
          case 3:  // INTEGER
          case 4:  // FLOAT
          case 9:  // FIELD_REF
          case 10: // METHOD_REF
          case 11: // INTERFACE_METHOD_REF
          case 12: // NAME_AND_TYPE
          case 18: // Invoke Dynamic（动态调用指令）
            data.readInt(); // 抛弃4字节
            break;
          case 15: // Method Handle（方法句柄）
            data.readByte();
            data.readShort();
            break;
          case 16: // Method Type（方法类型）
            data.readShort();
            break;
          default:
            throw
              new RuntimeException(&quot;Bad tag &quot; + tag);
        }
      }
      short accessFlags = data.readShort();
      String access = (accessFlags &amp; 0x0001) == 0 ?
        &quot;nonpublic:&quot; : &quot;public:&quot;;
      int thisClass = data.readShort();
      int superClass = data.readShort();
      return access + classNameTable.get(
        offsetTable.get(thisClass)).replace('/', '.');
    } catch(IOException | RuntimeException e) {
      throw new RuntimeException(e);
    }
  }
  // 示范：
  public static void
  main(String[] args) throws Exception {
    PathMatcher matcher = FileSystems.getDefault()
      .getPathMatcher(&quot;glob:**/*.class&quot;);
    // 遍历整个树：
    Files.walk(Paths.get(&quot;.&quot;))
      .filter(matcher::matches)
      .map(p -&gt; {
          try {
            return thisClass(Files.readAllBytes(p));
          } catch(Exception e) {
            throw new RuntimeException(e);
          }
        })
      .filter(s -&gt; s.startsWith(&quot;public:&quot;))
      // .filter(s -&gt; s.indexOf('$') &gt;= 0)
      .map(s -&gt; s.split(&quot;:&quot;)[1])
      .filter(s -&gt; !s.startsWith(&quot;enums.&quot;))
      .filter(s -&gt; s.contains(&quot;.&quot;))
      .forEach(System.out::println);
  }
}
/* 输出：
onjava.ArrayShow
onjava.atunit.AtUnit$TestMethods
onjava.atunit.AtUnit
onjava.atunit.ClassNameFinder
onjava.atunit.Test
onjava.atunit.TestObjectCleanup
onjava.atunit.TestObjectCreate
onjava.atunit.TestProperty
onjava.BasicSupplier
onjava.CollectionMethodDifferences
onjava.ConvertTo
onjava.Count$Boolean
onjava.Count$Byte
onjava.Count$Character
onjava.Count$Double
onjava.Count$Float
onjava.Count$Integer
onjava.Count$Long
onjava.Count$Pboolean
onjava.Count$Pbyte
onjava.Count$Pchar
onjava.Count$Pdouble
onjava.Count$Pfloat
onjava.Count$Pint
onjava.Count$Plong
onjava.Count$Pshort
onjava.Count$Short
onjava.Count
onjava.CountingIntegerList
onjava.CountMap
onjava.Countries
onjava.Enums
onjava.FillMap
onjava.HTMLColors
onjava.MouseClick
onjava.Nap
onjava.Null
onjava.Operations
onjava.OSExecute
onjava.OSExecuteException
onjava.Pair
onjava.ProcessFiles$Strategy
onjava.ProcessFiles
onjava.Rand$Boolean
onjava.Rand$Byte
onjava.Rand$Character
onjava.Rand$Double
onjava.Rand$Float
onjava.Rand$Integer
onjava.Rand$Long
onjava.Rand$Pboolean
onjava.Rand$Pbyte
onjava.Rand$Pchar
onjava.Rand$Pdouble
onjava.Rand$Pfloat
onjava.Rand$Pint
onjava.Rand$Plong
onjava.Rand$Pshort
onjava.Rand$Short
onjava.Rand$String
onjava.Rand
onjava.Range
onjava.Repeat
onjava.RmDir
onjava.Sets
onjava.Stack
onjava.Suppliers
onjava.TimedAbort
onjava.Timer
onjava.Tuple
onjava.Tuple2
onjava.Tuple3
onjava.Tuple4
onjava.Tuple5
onjava.TypeCounter
*/
</code></pre>
<p>虽然这里不可能深入挖掘所有细节，但每个类文件都已遵从了一种特定的格式，我也已经尽量使用了有意义的字段名来表示从<code>ByteArrayInputStream</code>中取出的数据片段。还可以通过对输入流执行的读取的长度，来得知每个数据片段的大小。举例来说，任何类文件的头32位永远是十六进制的“魔术数字”：0xcafebabe，<strong>6</strong>并且之后的两个短整型位是版本信息。常量池保存了程序所需的常量，因此大小不固定。接下来的短整型则告知了常量池的大小，由此可以分配一个大小合适的数组。常量池中的每个项都可以是固定长度或长度可变的值，因此我们必须检查每个项开头的标签，由此来决定该如何处理它，即例子中的<code>switch</code>语句。此处，我们并不去试图精确地分析类文件中的所有数据，而仅仅是逐步遍历数据，然后保存其中感兴趣的部分，因此你会发现大量的数据被丢弃了。类的信息被保存在<code>classNameTable</code>和<code>offsetTable</code>中，在读取完常量池后，程序会找到<code>thisClass</code>的信息，它是<code>offsetTable</code>的索引，<code>offsetTable</code>则生成<code>classNameTable</code>的索引，而<code>classNameTable</code>则生成类名。</p>
<p><strong>6</strong>关于该魔术数字的意义，衍生了很多版本的传说。</p>
<p>回到AtUnit.java，<code>process()</code>方法现在得到了类名，我们进而可以查看它是否包含<code>.</code>，这代表它是否在包中，不在包中的类会被忽略。如果类在包中，则会由标准的类加载器通过<code>Class.forName()</code>方法来加载该类。现在可以来分析该类中的<code>@Unit</code>注解了。</p>
<p>我们只需要找到三样东西：<code>@Test</code>方法（保存在<code>TestMethods</code>列表中）、<code>@TestObjectCreate</code>方法和<code>@TestObjectCleanup</code>方法。正如你在代码中所见，这几样东西是通过调用相关方法（用于查找注解）找到的。</p>
<p>如果找到了任何<code>@Test</code>方法，便会显示出类名，由此可以看到当前正在发生些什么，接下来便会执行各项测试。这意味着会打印方法名，然后调用<code>createTestObject()</code>方法，后者会使用<code>@TestObjectCreate</code>方法（如果该方法存在；否则会回退到无参数的构造器）。一旦创建了测试对象，便会对该对象执行测试方法。如果测试返回<code>boolean</code>，结果便会被捕获；如果没有，且没有抛出异常（异常会在断言失败或任何其他异常发生时抛出），我们便认为测试成功了。如果抛出了异常，便会打印出异常信息以告知细节。如果发生任何失败，失败数会累加，并且类名和方法名会被追加到<code>failedTests</code>，由此可以在测试结束后报告所有错误信息。</p>
<h2 id="45-总结">4.5　总结</h2>
<p>注解是一个很受欢迎的Java新特性。它是一种结构化且接受类型检查的向代码中添加元数据的方法，并且不会导致代码被渲染得混乱和不可读。它可以帮助我们免除部署描述文件和其他生成文件的编写工作。Javadoc中的<code>@deprecated</code>标签被<code>@Deprecated</code>注解所取代，仅这一点便印证了由合适的注解来描述代码组件的信息优于用注释来做同样的事。</p>
<p>Java中仅有少量的注解，这意味着如果你没有在别处找到相关的库，便需要自行创建注解以及相关逻辑。利用<code>javac</code>附带的注解处理器，只需一步就可以编译新创建的文件，以简化构建过程。</p>
<p>各种API和框架的开发者将逐渐引入注解，使其成为工具包的一部分。通过<code>@Unit</code>系统，你可以想象，注解很可能会给Java的编程体验带来巨大的改变。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BeanFactory和FactoryBean]]></title>
        <id>https://caldarius.github.io/post/beanfactory-and-factorybean/</id>
        <link href="https://caldarius.github.io/post/beanfactory-and-factorybean/">
        </link>
        <updated>2024-11-07T12:36:32.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>BeanFactory是Bean容器。FactoryBean是创建Bean对象的工厂。</p>
</blockquote>
<h2 id="beanfactory">BeanFactory</h2>
<p>Spring 包含并管理应用对象的配置和生命周期，在这个意义上它是一种用于承载对象的容器，你可以配置你的每个 Bean 对象是如何被创建的，这些 Bean 可以创建一个单独的实例或者每次需要时都生成一个新的实例，以及它们是如何相互关联构建和使用的。</p>
<p>如果一个 Bean 对象交给 Spring 容器管理，那么这个 Bean 对象就应该以类似零件的方式被拆解后存放到 Bean 的定义中，这样相当于一种把对象解耦的操作，可以由 Spring 更加容易的管理，就像处理循环依赖等操作。</p>
<p><code>BeanFactory</code>从命名上看是一个生产Bean对象的工厂，作为Spring中容器，最重要的作用是让用户程序员获取到容器中的对象。</p>
<p>BeanFactory只是个接口，并不是IOC容器的具体实现，所以Spring容器给出了很多种实现，如 <strong>DefaultListableBeanFactory</strong>、<strong>XmlBeanFactory</strong>、<strong>ApplicationContext</strong>等，其中XmlBeanFactory就是常用的一个，该实现将以XML方式描述组成应用的对象及对象间的依赖关系。</p>
<p>源码：</p>
<pre><code class="language-java">public interface BeanFactory {
	//对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，
	//如果需要得到工厂本身，需要转义
	String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;

	//根据bean的名字，获取在IOC容器中得到bean实例
	Object getBean(String name) throws BeansException;

	//根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。
	&lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType) throws BeansException;

	Object getBean(String name, Object... args) throws BeansException;

	&lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;

	&lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException;

	//提供对bean的检索，看看是否在IOC容器有这个名字的bean
	boolean containsBean(String name);

	//根据bean名字得到bean实例，并同时判断这个bean是不是单例
	boolean isSingleton(String name) throws NoSuchBeanDefinitionException;

	boolean isPrototype(String name) throws NoSuchBeanDefinitionException;

	boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;

	boolean isTypeMatch(String name, @Nullable Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException;

	//得到bean实例的Class类型
	@Nullable
	Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;

	//得到bean的别名，如果根据别名检索，那么其原名也会被检索出来
	String[] getAliases(String name);
}
</code></pre>
<p>从源码看，BeanFactory主要提供了获取Bean对象，判断Bean对象是否存在，判断Bean对象是否为单例对象，获取Bean的Class对象，获取Bean的别名等基本方法。</p>
<h1 id="factorybean">FactoryBean</h1>
<p>顾名思义，FactoryBean是一个Bean，但又不仅仅是一个Bean，同时它还是一个Factory。</p>
<p>在Spring中，所有的Bean都是由BeanFactory（也就是IOC容器）来进行管理的。但对FactoryBean而言，<strong>这个FactoryBean不是简单的Bean，而是一个能生产Bean的Bean</strong>,它的实现与设计模式中的工厂模式相似。</p>
<p>在Spring 框架下，我们使用的 MyBatis 框架中，它的核心作用是可以满足用户不需要实现 Dao 接口类，就可以通过 xml 或者注解配置的方式完成对数据库执行 CRUD 操作，那么在实现这样的 ORM 框架中，是怎么把一个数据库操作的 Bean 对象交给 Spring 管理的呢。</p>
<p>因为我们在使用 Spring、MyBatis 框架的时候都可以知道，并没有手动的去创建任何操作数据库的 Bean 对象，有的仅仅是一个接口定义，而这个接口定义竟然可以被注入到其他需要使用 Dao 的属性中去了，那么这一过程最核心待解决的问题，就是需要完成把复杂且以代理方式动态变化的对象，注册到 Spring 容器中。而为了满足这样的一个扩展组件开发的需求，就需要我们在现有手写的 Spring 框架中，添加这一能力。</p>
<p>关于提供一个能让使用者定义复杂的 Bean 对象，功能点非常不错，意义也非常大，因为这样做了之后 Spring 的生态种子孵化箱就此提供了，谁家的框架都可以在此标准上完成自己服务的接入。</p>
<p>但这样的功能逻辑设计上并不复杂，因为整个 Spring 框架在开发的过程中就已经提供了各项扩展能力的<code>接茬</code>，你只需要在合适的位置提供一个接茬的处理接口调用和相应的功能逻辑实现即可，像这里的目标实现就是对外提供一个可以二次从 FactoryBean 的 getObject 方法中获取对象的功能即可，这样所有实现此接口的对象类，就可以扩充自己的对象功能了。<em>MyBatis 就是实现了一个 MapperFactoryBean 类，在 getObject 方法中提供 SqlSession 对执行 CRUD 方法的操作</em> 整体设计结构如下图：</p>
<p>一般情况下，Spring通过反射机制利用的class属性指定实现类实例化Bean。至于为什么会有FactoryBean？原因有两个：</p>
<p>1、在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个<code>org.springframework.bean.factory.FactoryBean</code>的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。</p>
<p>2、由于第三方库不能直接注册到spring容器，于是可以实现<code>org.springframework.bean.factory.FactoryBean</code>接口，然后给出自己对象的实例化代码即可。</p>
<pre><code class="language-java">public interface FactoryBean&lt;T&gt; {
	//从工厂中获取bean【这个方法是FactoryBean的核心】
	@Nullable
	T getObject() throws Exception;
	
	//获取Bean工厂创建的对象的类型【注意这个方法主要作用是：该方法返回的类型是在ioc容器中getbean所匹配的类型】
	@Nullable
	Class&lt;?&gt; getObjectType();
	
	//Bean工厂创建的对象是否是单例模式
	default boolean isSingleton() {
		return true;
	}
}
</code></pre>
<p>FactoryBean提供了获取Bean，获取创建Bean对象的类型，判断创建Bean是否为单例接口。<br>
<a href="https://bugstack.cn/md/spring/develop-spring/2021-06-30-%E7%AC%AC10%E7%AB%A0%EF%BC%9A%E6%A8%AA%E5%88%80%E8%B7%83%E9%A9%AC%EF%BC%8C%E5%85%B3%E4%BA%8EBean%E5%AF%B9%E8%B1%A1%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8AFactoryBean%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E4%BD%BF%E7%94%A8.html">第10章：对象作用域和FactoryBean | 小傅哥 bugstack 虫洞栈</a>中的图示：<br>
<img src="https://caldarius.github.io//post-images/1730983057422.png" alt="" loading="lazy"></p>
<p>createBean 执行对象创建、属性填充、依赖加载、前置后置处理、初始化等操作后，就要开始做执行判断整个对象是否是一个 FactoryBean 对象，如果是这样的对象，就需要再继续执行获取 FactoryBean 具体对象中的 <code>getObject</code> 对象了。整个 getBean 过程中都会新增一个单例类型的判断<code>factory.isSingleton()</code>，用于决定是否使用内存存放对象信息。</p>
<p>以上是我在学习Spring过程中了解到的二者的区别。</p>
<blockquote>
<p>建议大家有时间学习下源码，手写一个简单的框架，对了解基本原理很有帮助。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[导致并发Bug的三个问题和解决方案]]></title>
        <id>https://caldarius.github.io/post/th-problems-to-bugs/</id>
        <link href="https://caldarius.github.io/post/th-problems-to-bugs/">
        </link>
        <updated>2024-10-31T13:16:07.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>并发是为了减少等待，合理利用CPU性能。</p>
</blockquote>
<h2 id="可见性-原子性-有序性">可见性、原子性、有序性</h2>
<p>首先定义什么是并发。</p>
<p>并发是一系列聚焦于如何减少等待并提升性能的技术。本定义的关键意义在<strong>等待</strong>上。如果没有等待发生，也就没有提速的可能。如果有等待发生，则有很多方法可以优化，具体取决于很多因素，包括系统配置、要解决的问题类型，以及很多其他方面。</p>
<p>这些年，我们的 CPU、内存、I/O 设备都在不断迭代，不断朝着更快的方向努力。但是，在这个快速发展的过程中，有一个<strong>核心矛盾一直存在，就是这三者的速度差异</strong>。</p>
<p>为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：</p>
<ol>
<li>CPU 增加了缓存，以均衡与内存的速度差异；导致可见性问题</li>
<li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异，操作系统的任务切换可以在任何CPU指令执行完毕的时候触发；导致原子性问题</li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。导致有序性问题</li>
</ol>
<p>一个线程对共享变量的修改，另外一个线程能够立刻看到，称为<strong>可见性</strong>。</p>
<p>一个或者多个操作在 CPU 执行的过程中不被中断的特性称为<strong>原子性</strong>。</p>
<p>是程序按照代码的先后顺序执行的特性称为<strong>有序性</strong>。</p>
<h2 id="java内存模型解决有序性和可见性">Java内存模型——解决有序性和可见性</h2>
<p>你已经知道，导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是<strong>禁用缓存和编译优化</strong>，但是这样问题虽然解决了，我们程序的性能可就堪忧了。</p>
<p>合理的方案应该是<strong>按需禁用缓存以及编译优化</strong>。那么，如何做到“按需禁用”呢？对于并发程序，何时禁用缓存以及编译优化只有程序员知道，那所谓“按需禁用”其实就是指按照程序员的要求来禁用。所以，为了解决可见性和有序性问题，只需要提供给程序员按需禁用缓存和编译优化的方法即可。</p>
<p>Java 内存模型是个很复杂的规范，可以从不同的视角来解读，站在我们这些程序员的视角，本质上可以理解为:</p>
<blockquote>
<p>Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 <strong>volatile</strong>、<strong>synchronized</strong> 和 <strong>final</strong> 三个关键字，以及六项 <strong>Happens-Before 规则</strong></p>
</blockquote>
<h3 id="volatile关键字">volatile关键字</h3>
<p>volatile 关键字并不是 Java 语言的特产，古老的 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。</p>
<h3 id="happens-before规则">Happens-Before规则</h3>
<p>其含义是：前面一个操作的结果对后续操作是可见的。Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则。</p>
<h4 id="1-程序的顺序性规则">1. 程序的顺序性规则</h4>
<p>这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。</p>
<h4 id="2-volatile-变量规则">2. volatile 变量规则</h4>
<p>这条规则是指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。</p>
<h4 id="3-传递性-15版本对volatile的增强">3. 传递性 -&gt;1.5版本对volatile的增强</h4>
<p>这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</p>
<h4 id="4-管程中锁的规则">4. 管程中锁的规则</h4>
<p>这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。</p>
<p>要理解这个规则，就首先要了解“管程指的是什么”。<strong>管程</strong>是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。</p>
<h4 id="5-线程-start-规则">5. 线程 start() 规则</h4>
<p>这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。</p>
<h4 id="6-线程-join-规则">6. 线程 join() 规则</h4>
<p>这条是关于线程等待的。它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对<strong>共享变量</strong>的操作。</p>
<blockquote>
<p>这里的join可以翻译为加入，也可以翻译为连接。</p>
</blockquote>
<p>thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。</p>
<p>比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。</p>
<h3 id="final关键字">final关键字</h3>
<p>前面我们讲 volatile 为的是禁用缓存以及编译优化，我们再从另外一个方面来看，有没有办法告诉编译器优化得更好一点呢？这个可以有，就是<strong>final 关键字</strong>。</p>
<p>**final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。**Java 编译器在 1.5 以前的版本的确优化得很努力，以至于都优化错了。</p>
<p>问题类似于上一期提到的利用双重检查方法创建单例，构造函数的错误重排导致线程可能看到 final 变量的值会变化。</p>
<p>当然了，在 1.5 以后 Java 内存模型对 final 类型变量的重排进行了约束。现在只要我们提供正确构造函数没有“逸出”，就不会出问题了。</p>
<p>“逸出”有点抽象，我们还是举个例子吧，在下面例子中，在构造函数里面将 this 赋值给了全局变量 global.obj，这就是“逸出”，线程通过 global.obj 读取 x 是有可能读到 0 的。因此我们一定要避免“逸出”。</p>
<pre><code class="language-java">final int x;
// 错误的构造函数
public FinalFieldExample() { 
  x = 3;
  y = 4;
  // 此处就是讲 this 逸出，
  global.obj = this;
}
</code></pre>
<p>Happens-Before 的语义是一种因果关系。</p>
<p>在现实世界里，如果 A 事件是导致 B 事件的起因，那么 A 事件一定是先于（Happens-Before）B 事件发生的，这个就是 Happens-Before 语义的现实理解。</p>
<p>在 Java 语言里面，Happens-Before 的语义本质上是一种可见性，A Happens-Before B 意味着 A 事件对 B 事件来说是可见的，无论 A 事件和 B 事件是否发生在同一个线程里。例如 A 事件发生在线程 1 上，B 事件发生在线程 2 上，Happens-Before 规则保证线程 2 上也能看到 A 事件的发生。</p>
<h2 id="互斥锁解决原子性">互斥锁——解决原子性</h2>
<p>原子性问题的源头是<strong>线程切换</strong>，如果能够禁用线程切换那不就能解决这个问题了吗？而操作系统做线程切换是依赖 CPU 中断的，所以禁止 CPU 发生中断就能够禁止线程切换。</p>
<p>在早期单核 CPU 时代，这个方案的确是可行的，而且也有很多应用案例，但是并不适合多核场景。这里我们以 32 位 CPU 上执行 long 型变量的写操作为例来说明这个问题，long 型变量是 64 位，在 32 位 CPU 上执行写操作会被拆分成两次写操作写高 32 位和写低 32 位。</p>
<p>单核 CPU 场景下，同一时刻只有一个线程执行，禁止 CPU 中断，意味着操作系统不会重新调度线程，也就是禁止了线程切换，获得 CPU 使用权的线程就可以不间断地执行，所以两次写操作一定是：要么都被执行，要么都没有被执行，具有原子性。</p>
<p>但是在多核场景下，同一时刻，有可能有两个线程同时在执行，一个线程执行在 CPU-1 上，一个线程执行在 CPU-2 上，此时禁止 CPU 中断，只能保证 CPU 上的线程连续执行，并不能保证同一时刻只有一个线程执行，如果这两个线程同时写 long 型变量高 32 位的话，那就有可能出现我们开头提及的诡异 Bug 了。</p>
<p>“<strong>同一时刻只有一个线程执行</strong>”这个条件非常重要，我们称之为<strong>互斥</strong>。如果我们能够保证对共享变量的修改是互斥的，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性了。</p>
<p>以上描述了导致并发程序错误的三个问题以及其解决方案，这也是如何写出线程安全程序的起点。</p>
<blockquote>
<p>本文参考了王宝令老师的《Java并发编程实战》，《onJava8进阶卷》</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见数据库索引模型]]></title>
        <id>https://caldarius.github.io/post/ds-index/</id>
        <link href="https://caldarius.github.io/post/ds-index/">
        </link>
        <updated>2024-10-31T12:33:37.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>索引是数据库表的目录。</p>
</blockquote>
<p>如果将数据库看作是一本巨大的书，那么索引则是书的目录。如果想不借助目录的情况下找到某一段内容，想必是需要费一些功夫的。而索引就是为了解决这个问题，借助索引可以快速定位到目标数据所在的大致范围，减少需要遍历的数据量。</p>
<p>索引的出现是为了解决查询的时候需要进行全表遍历的问题，实现索引的方式有很多，这里针对其底层数据结构，将其划分为了三种索引模型，分别是Hash表、二叉树、多叉树。下面将简单介绍三种常见的索引模型。</p>
<h2 id="哈希表">哈希表</h2>
<p>还是以一本书为例，哈希表是最容易想到的标记方式。读书时，常常将重要内容的页码和在那一页的大致位置记下来，这样在查找具体内容时直接翻到那一页即可。从这个使用方式出发，可以得出一种，键-值对作为数据组织形式的数据结构。其实现思路较为简单，首先建立一个数组存储Value，通过一个函数把Key换算成一个确定的位置，然后将Value放入对应位置。</p>
<p>如果多个Key经过Hash函数计算之后得到了同一个值，那么就使用链表对其进行处理。</p>
<p>从其实现思路可知，其value的存储通常是没有顺序的，所以哈希表只适用于等值查询的场景，对于范围查询是无能为力的。需要进行全表遍历。</p>
<h2 id="二叉树">二叉树</h2>
<p>那么如何解决范围查询问题呢？</p>
<p>最容易想到的思路是将Hash表中的无序数组变为有序数组，有序数组的优势在于随机读写以及范围查询的性能优秀。但是其插入和删除时设计目标位置之后所有元素的挪动，复杂度较高。有序数组只适合存储静态数据。</p>
<p>如何克服这一问题呢？</p>
<p>将有序数组建立为一棵树，牺牲随机读写能力，保留范围查询能力。</p>
<p>但是二叉树会带来多次IO的问题。假设二叉树的每个节点都对应一条数据，如果数据均存储在内存中，那么二叉树作为索引是各方面比较完善的。但是内存毕竟是有限的，还是有很多数据是存储在磁盘上的。这时候就涉及磁盘IO问题。访问二叉树的每一个节点，需要将其读入内存，如果二叉树较高，那么就会产生多次IO，很大程度影响性能。</p>
<h2 id="多叉树">多叉树</h2>
<p>解决方案是让查询过程访问尽可能多的快，树的节点存放尽可能多的数据。数据的大小应该是与 磁盘块大小相匹配。这样树从二叉树变为多叉树，高度显著降低，IO时间显著降低。</p>
<p>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<p>以上对三种常用索引进行了简要介绍，希望可以帮助大家理解数据库索引选型。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SOLID、KISS、YAGNI、DRY、LOD]]></title>
        <id>https://caldarius.github.io/post/silid-kydl/</id>
        <link href="https://caldarius.github.io/post/silid-kydl/">
        </link>
        <updated>2024-10-31T11:12:54.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>摘录了对以上几大基本设计原则的简介，方便从定义方面对比它们。</p>
</blockquote>
<h1 id="单一职责s">单一职责(S)</h1>
<p>单一职责(SRP,Single Responsibility)，一个类或者模块只负责完成一个职责或者功能。一个类只负责完成一个职责或者功能。</p>
<p>从类的角度来讲，一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p>
<p>不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则:</p>
<ul>
<li>类中的代码行数、函数或者属性过多;</li>
<li>类依赖的其他类过多，或者依赖类的其他类过多;·私有方法过多;</li>
<li>比较难给类起一个合适的名字;</li>
<li>类中大量的方法都是集中操作类中的某几个属性。</li>
</ul>
<p>单一职责原则通过避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性。同时，类职责单一，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的高内聚、低耦合。但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。</p>
<h1 id="开闭原则o">开闭原则(O)</h1>
<p>开闭原则的英文全称是Open Closed Principle，简写为OCP。它的英文描述是: softwareentities (modules, classes, functions, etc.) should be open for extension , but closed for modification。我们把它翻译成中文就是:软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。这个描述比较简略，如果我们详细表述一下，那就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等)。</p>
<p>添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等)，而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”;在细代码粒度下，可能又被认定为“扩展”。</p>
<p>我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、做到最小代码改动的情况下，将新的代码灵活地插入到扩展点上。<br>
很多设计原则、设计思想、设计模式，都是以提高代码的扩展性为最终目的的。特别是23种经典设计模式，大部分都是为了解决代码的扩展性问题而总结出来的，都是以开闭原则为指导原则的。最常用来提高代码扩展性的方法有:多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。</p>
<h1 id="里氏替换原则l">里氏替换原则(L)</h1>
<p>里式替换原则的英文翻译是: Liskov Substitution Principle，缩写为LSP。这个原则最早是在1986年由Barbara Liskov提出，他是这么描述这条原则的:lf S is a subtype of T, then objects of type T may be replaced with objects of type S,without breaking the program。<br>
在1996年，Robert Martin在他的SOLID原则中，重新描述了这个原则，英文原话是这样的:Functions that use pointers of references to base classes must be able to useobjects of derived classes without knowing it。<br>
我们综合两者的描述，将这条原则用中文描述出来，是这样的:子类对象（object of subtype/derived class）能够替换程序(program)中父类对象（(object of base/parentclass）出现的任何地方，并且保证原来程序的逻辑行为(behavior)不变及正确性不被破坏。</p>
<p>实际上，里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是“Design ByContract”，中文翻译就是“按照协议来设计”。<br>
看起来比较抽象，我来进一步解读一下。子类在设计的时候，要遵守父类的行为约定(或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括:函数声明要实现的功能;对输入、输出、异常的约定;甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。<br>
理解这个原则，我们还要弄明白里式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。</p>
<h1 id="接口隔离原则i">接口隔离原则(I)</h1>
<p>接口隔离原则的英文翻译是“ Interface Segregation Principle”，缩写为ISP。RobertMartin在SOLID原则中是这样定义它的: “Clients should not be forced to dependupon interfaces that they do not use。”直译成中文的话就是:客户端不应该强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。<br>
实际上，“接口”这个名词可以用在很多场合中。生活中我们可以用它来指插座接口等。在软件开发中，我们既可以把它看作一组抽象的约定，也可以具体指系统与系统之间的API接口，还可以特指面向对象编程语言中的接口等。<br>
前面我提到，理解接口隔离原则的关键，就是理解其中的“接口”二字。在这条原则中，我们可以把“接口”理解为下面三种东西:</p>
<ul>
<li>一组API接口集合</li>
<li>单个API接口或函数</li>
<li>OOP中的接口概念</li>
</ul>
<p>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</p>
<p>如果把“接口”理解为单个API接口或函数，部分调用者只需要函数中的部分功能,那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</p>
<p>如果把“接口”理解为OOP中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。<br>
单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准:通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p>
<h1 id="依赖反转d">依赖反转(D)</h1>
<h2 id="控制反转">控制反转</h2>
<p>实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。</p>
<h2 id="依赖注入">依赖注入</h2>
<p>依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过new的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递(或注入）给类来使用。</p>
<h2 id="依赖注入框架">依赖注入框架</h2>
<p>我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。</p>
<h2 id="依赖反转原则">依赖反转原则</h2>
<p>依赖反转原则的英文翻译是Dependency lnversion Principle，缩写为DIP。中文翻译有时候也叫依赖倒置原则。<br>
为了追本溯源，我先给出这条原则最原汁原味的英文描述:High-level modules shouldn’t depend on low-level modules.Both modules shoulddepend on abstractions. In addition, abstractions shouldn’t depend on details.</p>
<p>我们将它翻译成中文，大概意思就是:高层模块(high-level modules）不要依赖低层模块(low-level)。高层模块和低层模块应该通过抽象(abstractions)来互相依赖。除此之外，抽象(abstractions）不要依赖具体实现细节(details)，具体实现细节(details）依赖抽象(abstractions)。</p>
<p>所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。我们拿Tomcat这个Servlet容器作为例子来解释一下。</p>
<p>Tomcat是运行Java Web应用程序的容器。我们编写的Web应用程序代码只需要部署在Tomcat容器下，便可以被Tomcat容器调用执行。按照之前的划分原则，Tomcat就是高层模块，我们编写的 Web应用程序代码就是低层模块。Tomcat和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是Sevlet规范。Servlet规范不依赖具体的Tomcat容器和应用程序的实现细节，而Tomcat容器和应用程序依赖Servlet 规范.</p>
<h1 id="kisskeep-it-simple-and-stupid">KISS(Keep It Simple and Stupid)</h1>
<p>KISS, Keep It Simple and Stupid.翻译成中文就是尽量保持简单。KISS原则是保持代码可读和可维护的重要手段。KISS原则中的“简单”并不是以代码行数来考量的。代码行数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。而且，本身就复杂的问题，用复杂的方法解决，并不违背KISS原则。除此之外，同样的代码，在某个业务场景下满足KISS 原则，换一个应用场景可能就不满足了。<br>
对于如何写出满足KISS )原则的代码，我还总结了下面几条指导原则:</p>
<ul>
<li>不要使用同事可能不懂的技术来实现代码;</li>
<li>不要重复造轮子，要善于使用已经有的工具类库;</li>
<li>不要过度优化。</li>
</ul>
<h1 id="yagni">YAGNI</h1>
<p>YAGNI原则的英文全称是: You Ain’ t Gonna Need lt。直译就是:你不会需要它。<br>
这条原则也算是万金油了。当用在软件开发中的时候，它的意思是:不要去设计当前用不到的功能;不要去编写当前用不到的代码。实际上，这条原则的核心思想就是:不要做过度设计比如，我们的系统暂时只用Redis存储配置信息，以后可能会用到ZooKeeper。根据YAGNI原则，在未用到ZooKeeper之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现ZooKeeper存储配置信息这部分代码。再比如，我们不要在项目中提前引入不需要依赖的开发包。对于Java程序员来说，我们经常使用Maven或者Gradle来管理依赖的类库(library)。我发现，有些同事为了避免开发中library包缺失而频繁地修改Maven或者Gradle配置文件，提前往项目里引入大量常用的library包。实际上，这样的做法也是违背YAGNI)原则的。从刚刚的分析我们可以看出，YAGNI原则跟KISS原则并非一回事儿。KISS原则讲的是“如何做”的问题(尽量保持简单)，而YAGNI原则说的是“要不要做”的问题(当前不需要的就不要做)。</p>
<h1 id="dry原则dont-repeat-yourself">DRY原则(Don't Repeat Yourself)</h1>
<p>DRY 原则的定义非常简单，我就不再过度解读。今天，我们主要讲三种典型的代码重复情况，它们分别是:实现逻辑重复、功能语义重复和代码执行重复。这三种代码重复，有的看似违反DRY，实际上并不违反;有的看似不违反，实际上却违反了。实现逻辑重复，但功能语义不重复的代码，并不违反DRY 原则。实现逻辑不重复，但功能语义重复的代码，也算是违反DRY原则。除此之外，代码执行重复也算是违反DRY原则。</p>
<p>提高代码可复用性的一些方法：</p>
<ul>
<li>减少代码耦合</li>
<li>满足单一职责原则</li>
<li>模块化</li>
<li>业务与非业务逻辑分离</li>
<li>通用代码下沉</li>
<li>继承、多态、抽象、封装</li>
<li>应用模板等设计模式</li>
</ul>
<h1 id="lod最小知识原则">LOD(最小知识原则)</h1>
<p>迪米特法则的英文翻译是: Law of Demeter，缩写是LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为: The Least Knowledge Principle。关于这个设计原则，我们先来看一下它最原汁原味的英文定义:Each unit should have only limited knowledge about other units: only units“closely”related to the current unit. Or: Each unit should only talk to its friends;Don’t talk to strangers.<br>
我们把它直译成中文，就是下面这个样子:每个模块(unit）只应该了解那些与它关系密切的模块(units: only units &quot;closely&quot;related to the current unit)的有限知识(knowledge)。或者说，每个模块只和自己的朋友“说话”(talk)，不和陌生人“说话”(talk)。</p>
<p>我们之前讲过，大部分设计原则和思想都非常抽象，有各种各样的解读，要想灵活地应用到实际的开发中，需要有实战经验的积累。迪米特法则也不例外。所以，我结合我自己的理解和经验，对刚刚的定义重新描述一下。注意，为了统一讲解，我把定义描述中的“模块”替换成了“类”。</p>
<p>不该有直接依赖关系的类之间，不要有依赖;有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p>
<p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。<br>
所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象简述]]></title>
        <id>https://caldarius.github.io/post/oop-simple/</id>
        <link href="https://caldarius.github.io/post/oop-simple/">
        </link>
        <updated>2024-10-31T07:19:51.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>编程语言是用于创建应用程序的思维模式。语言本身可以从写作、绘画、雕塑、动画、电影制作等表达方式中获取灵感，而<strong>面向对象编程</strong>（Object-Oriented Programming, OOP）则是用计算机作为表达媒介的一种尝试。</p>
</blockquote>
<p>文章大部分内容来自《OnJava8》和王争老师的《设计模式之美》，有兴趣可以阅读原文~</p>
<h1 id="抽象">抽象</h1>
<p>所有编程语言都是一种抽象。甚至可以说，我们能够解决的问题的复杂程度直接取决于抽象的类型和质量。这里提到的“类型”的含义是“你要抽象的是什么”。比如，汇编语言是对计算机底层的一个极简化的抽象。还有许多所谓的命令式编程语言（比如FORTRAN、BASIC和C语言等）都是各自对汇编语言的抽象。虽然这些语言已经取得了长足的进步，但它们主要的抽象方式依然要求你根据计算机的结构而非问题的结构来思考。于是，程序员必须在机器模型（也叫作“解决方案空间”，即实际解决问题的方式，比如计算机）和实际解决的问题模型（也叫作“问题空间”，即问题实际存在之处，比如来源于某个业务）之间建立关联。建立这种关联需要耗费很大的精力，而且它是与编程语言无关的，这一切都导致程序难以编写且不易维护。</p>
<p>构建机器模型的一种代替方案是针对需要解决的问题构建问题模型。早期的一些编程语言（比如LISP和APL）会采取特定的视角看待周遭问题（例如，“所有问题最终都可以用列表呈现”或者“所有问题都是算法问题”），Prolog语言则会将所有问题都转换为决策链。这些语言要么是基于约束性的编程语言，要么是专门用来操作图形符号的编程语言。这些编程语言都能够出色地解决一些特定的问题，因为它们正是为此而生的。然而，一旦遇到它们专属领域以外的问题，它们就显得无能为力了。</p>
<p>面向对象编程则更进一步，它为程序员提供了一些能够呈现问题空间元素的工具。这种呈现方式具备足够的通用性，使得程序员不再局限于特定的问题。而这些问题空间中的元素及其解决方案空间中的具体呈现，我们称其为“对象”（需要注意的是，有些对象并不支持问题空间的类比）。其背后的理念则是，通过添加各种新的对象，程序可以将自己改编为一种描述问题的语言。于是，你阅读的既是解决方案的代码，也是表述问题的文字。这种灵活且强大的语言抽象能力是前所未有的。因此，面向对象编程描述问题的依据是实际的问题，而非用于执行解决方案的计算机。不过，它们之间依然存在联系，这是因为从某种意义上来说，对象也类似于一台小型计算机——每一个对象都具有状态，并且可以执行一些特定的操作。这一特点与现实中的事物极为相似，它们都具有各自的行为和特征。</p>
<p>面向对象这种描述问题，呈现问题空间的抽象方式也带来了面向对象最大的问题，如何找到和构建需要的对象？如何将现实世界和抽象的对象联系起来？对象之间如何协作？等问题。</p>
<p>SmallTalk是历史上第一门获得成功的面向对象语言，并且为后续出现的Java语言提供了灵感。Alan Kay总结了SmallTalk语言的5个基本特征，这些特征代表了纯粹的面向对象编程的方式。</p>
<ol>
<li>**万物皆对象。**你可以把对象想象为一种神奇的变量，它可以存储数据，同时你可以“发出请求”，让它执行一些操作。对于你想要解决的问题中的任何元素，你都可以在程序中用对象来呈现（比如狗、建筑、服务等）。</li>
<li>**一段程序实际上就是多个对象通过发送消息来通知彼此要干什么。**当你向一个对象“发送消息”时，实际情况是你发送了一个请求去调用该对象的某个方法。</li>
<li>**从内存角度而言，每一个对象都是由其他更为基础的对象组成的。**换句话说，通过将现有的几个对象打包在一起，你就创建了一种新的对象。这种做法展现了对象的简单性，同时隐藏了程序的复杂性。</li>
<li><strong>每一个对象都有类型。<strong>具体而言，每一个对象都是通过某个</strong>类</strong>生成的<strong>实例</strong>，这里说的“类”就（几乎）等同于“类型”。一个类最为显著的特性是“你可以发送什么消息给它”。</li>
<li><strong>同一类型的对象可以接收相同的消息。<strong>稍后你就会意识到这句话的丰富含义。举例来说，因为一个“圆形”对象同样也是一个“形状”对象，所以“圆形”也可以接收“形状”类型的消息。这就意味着，你为“形状”对象编写的代码</strong>自然</strong>可以适用于任何的“形状”子类对象。这种可替换性是面向对象编程的一个基石。</li>
</ol>
<p>Grady Booch对对象做了一种更为简洁的描述：</p>
<blockquote>
<p>对象具有状态、行为及标识。</p>
</blockquote>
<p>这意味着对象可以拥有属于自己的内部数据（赋予其状态）、方法（用于产生行为），同时每一个对象都有别于其他对象。也就是说，每一个对象在内存中都有唯一的地址。</p>
<h1 id="类和对象">类和对象</h1>
<p>创建抽象数据类型（即“类”）是面向对象编程的一个基本概念。抽象数据类型的工作原理和内置类型几乎一样：你可以创建某种类型的变量（在面向对象领域，这些变量叫作“对象”或“实例”），随后你就可以操作这些变量（叫作“发送消息”或“发送请求”，即你发送指令给对象，然后对象自行决定怎么处理）。同一类型的所有成员（或元素）都具有一些共性，比如：每一个账户都有余额，每一位出纳员都能处理存款业务。同时，每一个成员都具有自己的专属状态，比如：每一个账户的余额都是不同的，每一位出纳员都有名字。因此，对于所有这些成员，包括每一位出纳员、每一位顾客、每一个账户，以及每一笔交易等，我们都能够在程序中用一个唯一的实体来表示。这种实体就是对象，同时每一个对象所归属的类决定了对象具有何种行为特征。</p>
<p>虽然我们在面向对象编程中会创建新的数据类型，但实际上所有面向对象编程语言都会使用<code>class</code>这个关键字。所以当你看到“类型”（type）这个词的时候，请第一时间想到“类”（class），反之亦然。有时候我们会将两者加以区分，将类型（type）定义为接口，而类（class）则是接口的具体实现。</p>
<p>因为类描述了一系列具有相同特征（即数据元素）和行为（即功能方法）的对象，而即便是浮点数这种内置数据类型也具有一系列的行为和特征，所以类其实就是数据类型。抽象数据类型和内置数据类型的区别是，程序员可以通过定义一个新的类来解决问题，而非受限于已有的数据类型。这些已有的数据类型其设计本意是为了呈现机器内的存储单元，你可以根据实际的需求创建新的数据类型，同时扩展编程语言的能力。此外，编程系统对于新的类十分友好，比如也会为新的类提供类型检查等功能，就像对待内置数据类型一样。</p>
<p>面向对象编程的作用并不局限于模拟。无论你是否同意“任何程序都是对系统的一种模拟”，面向对象编程技巧都可以帮你将众多复杂的问题简化。</p>
<p>一旦创建了一个类，就可以用它创建任意多个对象，然后在操作这些对象时，可以把它们视为存在于问题空间的元素。实话实说，面向对象编程的一大挑战就是，如何在问题空间的元素和解决方案空间的对象之间建立一对一的关联。</p>
<h1 id="使用对象提供的接口与对象进行交互">使用对象提供的接口与对象进行交互</h1>
<p>那么，如何能让一个对象真正发挥其作用呢？答案是向对象发送请求，比如让它完成一次交易、在屏幕上画个图形或者打开一个开关等。对象能够接受什么请求，是由它的“接口”（interface）决定的，而对象所归属的类定义了这些接口。</p>
<figure data-type="image" tabindex="1"><img src="http://www.ituring.com.cn/figures/2022/OnJava8/01.jpg" alt="img" loading="lazy"></figure>
<pre><code class="language-java">Light lt = new Light();
lt.on();
</code></pre>
<p>图1-1中的接口定义了你能够向这个对象发送的请求。此外，也必然存在一些代码用于响应这些请求。这些代码再加上隐藏的数据，叫作“实现”（implementation）。对于每一个请求，类都有一个方法与之对应。当你向一个对象发送特定的请求时，对应的方法就会被调用。我们通常会这样描述该过程：向对象“发送消息”（即发出请求），然后由对象决定如何处理（即运行对应的代码）。</p>
<p>在上面的例子中，类的名字是<code>Light</code>，<code>Light</code>所生成的对象的名字是<code>lt</code>，我们能够对<code>Light</code>对象发出的请求是开灯（<code>on()</code>）、关灯（<code>off()</code>）、灯光变亮（<code>brighten()</code>）以及灯光变暗（<code>dim()</code>）。通过定义一个“引用”即<code>lt</code>，以及用<code>new</code>关键字生成一个新对象，我们就创建了一个<code>Light</code>对象。此外，如果你需要向对象发送消息，可以用一个英文句号（<code>.</code>）将对象名和请求（即方法）连接起来。如果我们只是使用内置类，那么基本上关于对象编程的内容就是以上了。</p>
<h1 id="对象是服务的提供者">对象是服务的提供者</h1>
<p>当你开发一个面向对象程序或理解其设计时，一个上佳的方法是将对象想象成“服务提供者”。你的程序本身也是为用户提供服务的，它通过使用其他对象提供的服务来做到这一点。所以，你的任务是创建（更好的情况是，从已有的库中找到）一些提供对应服务以解决问题的对象。</p>
<p>可以先从一个问题开始：“如果我能从魔术帽里变出一些对象，究竟什么对象才能解决我的问题呢？”比如，你要创建一个记账系统，于是你可能会需要一些预设的输入页面对象、负责计算的对象，以及连接各种打印机以打印支票和发票的对象。其中有些对象也许已经存在，那么其他不存在的对象应该是什么样的呢？它们应该提供哪些服务，同时它们还需要哪些其他对象的支持呢？如果继续深入的话，到了最后，你要么会说“编写这个对象的代码应该很简单”，要么会说“我确信这个对象早已存在”。这种将问题拆解为一系列对象的方法确实行之有效。</p>
<p>把对象视为服务提供商还有一个额外的好处，即提升了对象的聚合程度。说到这里，就需要提到软件设计领域中一个体现基础品质的术语——“高内聚性”（high cohesion），这指的是设计的组件（比如对象、方法或者对象库等）无论从哪个方面看都整合得很好。人们在设计对象时很容易犯的一个错误就是为对象添加太多的功能。例如，在一个打印支票的程序里，你一开始可能会认为需要一个既能排版又能打印的对象。然后，你发现这些功能对于一个对象而言太多了，其实你需要3个或者更多对象来负责这些功能。比如，一个对象包含了所有可能的打印布局，通过查找它可以知道如何打印一张支票。另一个或一组对象则作为通用打印接口，负责连接所有不同型号的打印机（但不负责记账，也许你需要购买该功能而非自行创建）。还有一个对象负责整合前两个对象提供的服务以完成打印任务。因此，每一个对象都提供了一种配套服务。在面向对象领域，出色的设计往往意味着一个对象只做好一件事，绝不贪多。这条原则不只适用于那些从外部购买的对象（比如打印接口对象），也适用于那些可复用的对象（比如支票排版对象）。</p>
<p>把对象视为服务提供商，不仅对你设计对象的过程有所帮助，也有利于他人阅读你的代码或复用这些对象。换句话说，如果别人因为对象提供的服务而认识到它的价值，那么他就会更加轻松地在自己的设计中使用这个对象。</p>
<h1 id="封装">封装</h1>
<p>我们可以把程序员划分为两大阵营：一是“类的创建者”（负责创建新数据类型的人），二是“客户程序员”（在自己的应用程序里使用现有数据类型的人）。客户程序员的诉求是收集一个装满了各种类的工具箱，以便自己能够快速开发应用程序。而类的创建者则负责在创建新的类时，只暴露必要的接口给客户程序员，同时隐藏其他所有不必要的信息。为什么要这么做呢？这是因为，如果这些信息对于客户程序员而言是不可见的，那么类的创建者就可以任意修改隐藏的信息，而无须担心对其他任何人造成影响。隐藏的代码通常代表着一个对象内部脆弱的部分，如果轻易暴露给粗心或经验不足的客户程序员，就可能在顷刻之间被破坏殆尽。所以，隐藏代码的具体实现可以有效减少程序bug。</p>
<p>所有的关系都需要被相关各方一致遵守的边界。当你创建了一个库，那么你就和使用它的客户程序员建立了一种关系。该客户程序员通过使用你的代码来构建一个应用，也可能将其用于构建成一个更大的库。如果一个类的所有成员都对所有人可见，那么客户程序员就可以恣意妄为，而且我们无法强制他遵守规定。也许你的预期是客户程序员不会直接操作任何类的成员，但是如果没有访问控制的话，你就无法实现这一点，因为所有的一切都暴露在对方面前了。</p>
<p>所以我们<strong>设置访问控制的首要原因就是防止客户程序员接触到他们本不该触碰的内容</strong>，即那些用于数据类型内部运转的代码，而非那些用于解决特定问题的接口部分。这种做法实际上为客户程序员提供了一种服务，因为他们很容易就可以知道哪些信息对他们来说是重要的，哪些则是无须关心的（请注意这也是一个富有哲理的决策。比如有些编程语言认为，如果程序员希望访问底层信息，就应该允许他们访问）。</p>
<p>**设置访问控制的第二个原因则是，让库的设计者在改变类的内部工作机制时，不用担心影响到使用该类的客户程序员。**例如，你为了开发方便而创建了一个简单的类，之后你发现必须重写这个类以提升它的运行效率。如果接口部分和实现部分已经被分离和保护起来了，那么你就可以轻松地重写它。</p>
<h1 id="复用">复用</h1>
<p>如果一个类经过了充分测试，其代码就应该是有效且可复用的（理想情况）。不过，要实现这种复用性并不像想象的那么简单。创建可复用的对象设计需要大量的经验和洞见。然而，一旦你拥有了可复用的设计，不复用就可惜了。代码复用是我们使用面向对象编程的理由之一。</p>
<p>复用一个类最简单的方法是直接使用这个类所生成的对象，不过你也可以把这个对象放到另一个新类里面。新创建的类可以由任意数量和类型的对象组成，也可以任意组合这些对象，以满足想要的功能。因为利用已有的类组合成一个新的类，所以这个概念叫作“组合”（composition）。如果组合是动态的，通常叫作“聚合”（aggregation）。组合通常代表一种“有”（has-a）的关系，比如“汽车有发动机”（见图1-2）。</p>
<figure data-type="image" tabindex="2"><img src="http://www.ituring.com.cn/figures/2022/OnJava8/02.jpg" alt="img" loading="lazy"></figure>
<p><strong>图1-2</strong></p>
<p>图1-2中用箭头表示了一辆汽车的组合关系。而我习惯用一种更简单的方式，即一条没有箭头的直线来表达两者之间的关联。</p>
<p>组合为我们提供了极大的灵活性。这些在你的类内部创建的对象通常具有<code>private</code>属性，所以其他使用这个类的客户程序员无法访问它们。这也意味着，就算我们修改了这些内部对象，也不会影响外部已有的代码。此外，你还可以在运行时改变这些内部对象，从而动态调整程序的行为。下一节要讲述的继承机制则不具备这种灵活性，因为编译器对使用继承创建的类设置了一些编译时的限制。</p>
<p>继承常被视为面向对象编程的重中之重，因此容易给新手程序员留下这样的印象：处处都应该使用继承。而实际上，这种全盘继承的做法会导致设计变得十分别扭和过于复杂。所以相比之下，在创建新类时应该首先考虑组合，因为使用组合更为简单灵活，设计也更为清晰简洁。一旦你拥有了足够的经验，何时使用继承就会变得非常清晰了。</p>
<h1 id="继承">继承</h1>
<p>对象本身的理念是提供一种便捷的工具。对象可以根据定义的概念来封装数据和功能，从而展现给人们对应的问题空间的概念，而不是强迫程序员操作机器底层。在编程语言里，这些基础概念通过关键字<code>class</code>得以呈现。</p>
<p>然而，当我们大费周折才创建了一个类之后，如果不得不再创建一个与之前功能极为相近的类，这种滋味一定不太好受。如果我们能够复制现有的类，并且在该复制类的基础上再做一些增补的话，那就太妙了。实际上，这就是继承给我们带来的好处，除了一点：如果最初的类（叫作“基类”“超类”或“父类”）发生了变化，那么被修改的“复制”类（叫作“派生类”“继承类”或“子类”）同样会发生变化（见图1-3）。</p>
<figure data-type="image" tabindex="3"><img src="http://www.ituring.com.cn/figures/2022/OnJava8/03.jpg" alt="img" loading="lazy"></figure>
<p><strong>图1-3</strong></p>
<p>图1-3中的箭头从子类指向其基类。之后你将看到，子类通常会有多个。</p>
<p>一个类呈现的内容不只是对象能做什么、不能做什么，它还可以关联其他的类。两个类可以拥有相同的行为和特征，但一个类可以比另一个类拥有更多的特征，以及处理更多的消息（或者用不同的方式处理消息）。继承通过基类和子类的概念来表述这种相似性，即基类拥有的所有特征和行为都可以与子类共享。也就是说，你可以通过基类呈现核心思想，从基类所派生出的众多子类则为其核心思想提供了不同的实现方式。</p>
<p>举个例子。一个垃圾收集器需要对垃圾进行分类。我们创建的基类是“垃圾”，具体的每一件垃圾都有各自不同的重量、价值，并且可以被切碎、溶解或者分解等。于是，更为具体的垃圾子类就出现了，并且带有额外的特征（比如，一个瓶子有颜色，一块金属有磁性等）和行为（比如你可以压扁一个铝罐）。此外，有些行为还可以产生不同的效果（比如纸质垃圾的价值取决于它的类型和状态）。通过继承，我们创建了一种“类型层次”（type hierarchy）以表述那些需要根据具体类型来解决的问题。</p>
<p>还有一个常见的例子是形状，你可能在计算机辅助设计系统或模拟游戏中碰过到。具体来说，基类就是“形状”（<code>Shape</code>），而每一个具体的形状都具有大小、颜色、位置等信息，并且可以被绘制（<code>draw()</code>）、清除（<code>erase()</code>）、移动（<code>move()</code>）、着色（<code>getColor</code>或<code>setColor</code>）等。接下来，基类<code>Shape</code>可以派生出特定类型的形状，比如圆形（<code>Circle</code>）、矩形（<code>Square</code>）、三角形（<code>Triangle</code>）等，每一个具体形状都可以拥有额外的行为和特征，比如某些形状可以被翻转（见图1-4）。有些行为背后的逻辑是不同的，比如计算不同形状的面积的方法就各不相同。所以，类型层次既体现了不同类之间的相似性，又展现了它们之间的差异。</p>
<figure data-type="image" tabindex="4"><img src="http://www.ituring.com.cn/figures/2022/OnJava8/04.jpg" alt="img" loading="lazy"></figure>
<p><strong>图1-4</strong></p>
<p>问题和解决方案都使用相同的表达方式是非常有用的，因为这样就不再需要一个中间模型将问题翻译为解决方案。在面向对象领域，类型层次是该模型的一个重要特征，它让你可以方便地从现实世界中的系统转换到代码世界的系统。不过现实情况是，有些人由于习惯了复杂的解决方案，因此对于面向对象的简约性反而会有些不适应。</p>
<p>继承已有的类将产生新类。这个新的子类不但会继承其基类的所有成员（虽然<code>private</code>成员是隐藏且不可访问的），而且更重要的是，子类也会继承基类的接口。也就是说，所有基类对象能够接收的消息，子类对象也一样能够接收。我们可以通过一个类所接收的消息来确定其类型，所以从这一点来说，子类和基类拥有相同的类型。引用之前的例子，就是“圆形是一个形状”。所以，掌握这种通过继承表现出来的类型相同的特性，是理解面向对象编程的基础方法之一。</p>
<p>既然基类和子类拥有相同的基础接口，就必然存在接口的具体实现。这意味着，当一个对象接收到特定的消息时，就会执行对应的代码。如果你继承了一个类并且不做任何修改的话，这个基类的方法就会原封不动地被子类所继承。也就是说，子类的对象不但和基类具有相同的类型，而且不出所料的是，它们的行为也是相同的。</p>
<p>有两种方法可以区分子类和基类。第一种方法非常简单直接：为子类添加新的方法（见图1-5）。因为这些方法并非来自基类，所以背后的逻辑可能是，基类的行为和你的预期不符，于是你添加了新的方法以满足自己的需求。有时候，继承的这种基础用法能够完美地解决你面临的问题。不过，你需要慎重考虑是否基类也需要这些新的方法（还有一个替代方案是考虑使用“组合”）。在面向对象编程领域里，这种对设计进行发现和迭代的情况非常普遍。</p>
<figure data-type="image" tabindex="5"><img src="http://www.ituring.com.cn/figures/2022/OnJava8/05.jpg" alt="img" loading="lazy"></figure>
<p><strong>图1-5</strong></p>
<p>虽然有时候继承意味着需要为子类添加新的方法[Java尤其如此，其用于继承的关键字就是“扩展”（<code>extends</code>）]，但这不是必需的。还有一种让新类产生差异化的方法更为重要，即修改基类已有方法的行为，我们称之为“重写”该方法（见图1-6）。</p>
<figure data-type="image" tabindex="6"><img src="http://www.ituring.com.cn/figures/2022/OnJava8/06.jpg" alt="img" loading="lazy"></figure>
<p><strong>图1-6</strong></p>
<p>如果想要重写一个方法，你可以在子类中对其进行重新定义。也就是说，你的预期是“我想通过相同的接口调用该方法，但是我希望它可以在新的类中实现不同的效果”。</p>
<h3 id="is-a关系与is-like-a关系">is-a关系与is-like-a关系</h3>
<p>继承机制存在一个有待商榷的问题：<strong>只应该</strong>重写基类中定义的方法吗？（并且不能添加基类中不存在的新方法）如果是，就意味着子类和基类的类型是<strong>完全</strong>相同的，因为它们的接口一模一样。结果就是，你可以直接用子类的对象代替基类的对象。这种<strong>纯替换关系</strong>通常叫作“替换原则”<strong>5</strong>。从某种意义上说，这是一种理想的继承方式。这种情况下基类和子类之间的关系通常叫作“is-a”关系，意思是“A是B”，比如“圆形是一个形状”。甚至有一种测试是否是继承关系的方法是，判断你的类之间是否满足这种“is-a”关系。</p>
<p><strong>5</strong>也叫作“里氏替换原则”（Liskov Substitution Principle），这一理论最初由Barbara Liskov提出。</p>
<p>有时候，你会为子类的接口添加新的内容，从而扩展了原有的接口。在这种情况下，子类的对象依然可以代替基类的对象，但是这种代替方案并不完美，因为不能通过基类的接口获取子类的新方法。我将这种关系描述为“is-like-a”关系（这是我自创的词），意思是“A像B”，即子类在拥有基类接口的同时，也拥有一些新的接口，所以不能说两者是完全等同的。以空调为例，假设你的房间里已经安装了空调，也就是拥有能够降低温度的接口。现在发挥一下想象力，万一空调坏了，你还可以用热泵作为替代品，因为热泵既可以制冷也可以制热（见图1-7）。在这种情况下，热泵“就像是”空调，只不过热泵能做的事情更多而已。此外，由于设计房间的温度控制系统时，功能仅限于制冷，所以系统和新对象交互时也只有制冷的功能。虽然新对象的接口有所扩展，但现有系统也只能识别原有的接口。</p>
<figure data-type="image" tabindex="7"><img src="http://www.ituring.com.cn/figures/2022/OnJava8/07.jpg" alt="img" loading="lazy"></figure>
<p><strong>图1-7</strong></p>
<p>观察图1-7你就能知道，基类“制冷系统”通用性并不高，最好可以将其改名为“温度调节系统”，使其同时包含制热功能。这样一来，之前提及的替换原则就可以派上用场了。不过话说回来，这张图也反映了真实世界中的设计方式。</p>
<p>当你充分理解了替换原则之后，可能会认为这种纯替换方式才是唯一正确的方式。如果你的设计能够应用纯替换原则，那就<strong>太棒了</strong>。然而实际情况是，你会发现经常需要为子类的接口添加新方法。只要稍加观察，就很容易分辨出这两种情况的应用场合。</p>
<h1 id="多态">多态</h1>
<p>在编程中涉及类型层次时，我们通常会将一个对象视为其基类的一个实例，而不是对象实际的类。这种方式可以让你在编写代码时不依赖于具体的类。在形状的例子中，方法都是作用于通用的形状，而不需要关心该形状具体是圆形、矩形、三角形，还是一个没有明确定义的形状。因为所有的形状都可以被绘制、清除、移动，所以当这些方法发送消息至对象的时候，就无须关注对象是如何处理这条消息的。</p>
<p>当我们添加新的类时，这些代码是不受影响的，添加新的类可以扩展面向对象程序的能力，从而能够处理一些新的情况。比如，你为基类“形状”创建了一个子类“五边形”，并且不改变那些基于通用形状的方法。这种通过派生子类就可以轻松扩展程序设计的能力，是封装变化的一种基础方式。这种方式在改善设计的同时，也降低了软件维护的成本。</p>
<p>当你尝试用派生的子类替代通用基类（比如，把圆形当作形状，把自行车当作交通工具，把鸬鹚当作鸟等）时会发现一个问题，即调用方法来绘制这个通用的形状、驾驶这辆通用的交通工具或者让这只鸟飞翔时，编译器并不知道在编译时具体需要执行哪一段代码。那么重点来了，当消息被发送时，程序员并不<strong>关心</strong>具体执行的是哪一段代码。也就是说，当负责绘制的方法应用于圆形、矩形或者三角形时，这些对象将能够根据其类型执行对应的正确代码。</p>
<p>如果你并不关心具体执行的是哪一段代码，那么当你添加新的子类时，即使不对其基类的代码做任何修改，该子类实际执行的代码可能也会有所不同。但如果编译器无法得知应该具体执行哪一段代码，它会怎么做呢？比如下图中的<code>BirdController</code>对象，它可以和通用的<code>Bird</code>对象协同工作，同时它并不知道这些对象具体是什么类型的鸟。对于<code>BirdController</code>来说，这种方式非常方便，因为它无须额外编写代码来确定这些对象的具体类型和行为。那么问题来了，当一个<code>Bird</code>对象的<code>move()</code>方法被调用时，如果我们并不清楚其具体的类型，该如何确保最终执行的是符合预期的正确行为呢（比如<code>Goose</code>对象执行的是行走、飞翔或游泳，<code>Penguin</code>对象则是移动或游泳，见图1-8）？</p>
<figure data-type="image" tabindex="8"><img src="http://www.ituring.com.cn/figures/2022/OnJava8/08.jpg" alt="img" loading="lazy"></figure>
<p><strong>图1-8</strong></p>
<p>答案来自继承机制的一种重要技巧：编译器并非通过传统方式来调用方法。对于非面向对象编译器而言，其生成的函数调用会触发“前期绑定”（early binding），这是一个你可能从来都没听说过的词，因为你从未考虑过使用这种方式。前期绑定意味着编译器会生成对一个具体方法名的调用，该方法名决定了被执行代码的绝对地址。但是对于继承而言，程序直到运行时才能明确代码的地址，所以就需要引入其他可行的方案以确保消息可以顺利发送至对象。</p>
<p>为了解决上面提及的问题，面向对象语言使用的机制是“后期绑定”（late binding）。也就是说，当你向某个对象发送消息时，直到运行时才会确定哪一段代码会被调用。编译器会确保被调用的方法是真实存在的，并对该方法的参数和返回值进行类型检查，但是它并不知道具体执行的是哪一段代码。</p>
<p>为了实现后期绑定，Java使用了一些极为特殊的代码以代替直接的函数调用，这段代码使用存储在对象中的信息来计算方法体的地址（第9章会详细地描述这个过程）。其结果就是，在这些特殊代码的作用下，每一个对象会有不同的表现。通俗地讲，当你向一个对象发送消息时，该对象自己会找到解决之道。</p>
<p>顺便一提，在某些编程语言里，你必须显式地为方法赋予这种后期绑定特性。比如，C++使用<code>virtual</code>关键字来达到此目的。在这些编程语言中，方法<strong>并不</strong>默认具备动态绑定特性。不过，Java默认具备动态绑定特性，所以你无须借助于其他关键字或代码来实现多态。</p>
<p>我们再来看一下形状的例子。之前的图中展示了一些形状的类（这些类都基于统一的接口），为了更好地描述多态，我们编写一小段只关注基类而不关注具体子类的代码。由于这段代码<strong>不关注</strong>类的细节，因此非常简单易懂。此外，如果我们通过继承添加了一个新的子类“六边形”，我们的代码仍然适用于这个新的<code>Shape</code>类，就像适用于其他已有子类一样。因此可以说，这段程序具备<strong>扩展性</strong>。</p>
<p>如果你用Java编写一个方法（你马上就会学到具体应该怎么做）：</p>
<pre><code class="language-java">void doSomething(Shape shape) {
  shape.erase();
  // ...
  shape.draw();
}
</code></pre>
<p>这个方法适用于任何<code>Shape</code>对象，所以它不关心进行绘制和清除的对象具体是什么类型。如果程序的其他地方调用了<code>doSomething()</code>方法，比如：</p>
<pre><code class="language-java">Circle circle = new Circle();
Triangle triangle = new Triangle();
Line line = new Line();
doSomething(circle);
doSomething(triangle);
doSomething(line);
</code></pre>
<p>不管对象具体属于哪个类，<code>doSomething()</code>方法都可以正常运行。</p>
<p>简直妙不可言。我们再看这一行代码：</p>
<pre><code class="language-java">doSomething(circle);
</code></pre>
<p>在这段代码里，原本我们需要传递一个<code>Shape</code>对象作为参数，而实际传递的参数却是一个<code>Circle</code>类的对象。因为<code>Circle</code>也是一个<code>Shape</code>，所以<code>doSomething()</code>也可以接受<code>Circle</code>。也就是说，<code>doSomething()</code>发送给<code>Shape</code>对象的任何消息也可以发送给<code>Circle</code>对象。这是一种非常安全且逻辑清晰的做法。</p>
<p>这种将子类视为基类的过程叫作“向上转型”（upcasting）。这里的“转型”指的是转变对象的类型，而“向上”沿用的是继承图的常规构图，即基类位于图的顶部，数个子类则扇形分布于下方。因此，转变为基类在继承图中的路径就是一路向上，也就叫作“向上转型”（见图1-9）。</p>
<figure data-type="image" tabindex="9"><img src="http://www.ituring.com.cn/figures/2022/OnJava8/09.jpg" alt="img" loading="lazy"></figure>
<p><strong>图1-9</strong></p>
<p>面向对象程序总会包含一些向上转型的代码，因为这样就可以让我们无须关心对象具体的类是什么。再看一下<code>doSomething()</code>方法中包含的代码：</p>
<pre><code class="language-java">shape.erase();
// ...
shape.draw();
</code></pre>
<p>需要注意的是，代码并没有告诉我们，“如果是一个<code>Circle</code>请这样做，如果是一个<code>Square</code>请那样做，诸如此类”。如果你真的编写了一段代码用于检查所有可能出现的形状，那么这段代码必然是一团糟，并且每当你为<code>Shape</code>添加一个新的子类时，都必须修改这段代码。所以，上面的代码实际上做的是：“这是一个<code>Shape</code>，我知道它可以进行绘制和清除，那就这么干吧，具体细节交给形状自己处理就好”。</p>
<p><code>doSomething()</code>方法的神奇之处在于，代码运行的结果是符合预期的。如果直接通过<code>Circle</code>、<code>Square</code>或者<code>Line</code>对象调用<code>draw()</code>方法，运行的代码自然是不同的。如果调用<code>draw()</code>方法时并不知道<code>Shape</code>对象的具体类型，它也能正常工作，即执行其实际子类的代码。这一点十分了不起，因为当Java编译器编译<code>doSomething()</code>的代码时，它并不知道对象的类型是什么。通常来说，你可能会想当然地认为被调用的是基类<code>Shape</code>的<code>erase()</code>和<code>draw()</code>方法，而非具体的<code>Circle</code>、<code>Square</code>或者<code>Line</code>子类，然而实际情况是，确实是具体的子类被调用了，这就是多态。编译器和运行时系统负责处理各种细节，你需要了解的就是多态机制的存在，更重要的是要知道如何利用多态进行设计。当你向一个对象发送消息时，哪怕需要用到向上转型，该对象也能够正确地处理该消息。</p>
<h1 id="什么是面向对象编程">什么是面向对象编程？</h1>
<p>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石。</p>
<h1 id="什么是面向对象编程语言">什么是面向对象编程语言？</h1>
<p>面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（(封装、抽象、继承、多态)的编程语言。</p>
<h1 id="什么是面向对象分析和设计">什么是面向对象分析和设计？</h1>
<p>前面我们讲了面向对象编程（OOP)，实际上，跟面向对象编程经常放到一块儿来讲的还有另外两个概念，那就是面向对象分析(OOA）和面向对象设计(OOD)。面向对象分析英文缩写是OOA，全称是Object Oriented Analysis;面向对象设计的英文缩写是OOD，全称是Object Oriented Design。OOA、OOD、OOP三个连在一起就是面向对象分析、设计、编程（实现)，正好是面向对象软件开发要经历的三个阶段。<br>
关于什么是面向对象编程，我们前面已经讲过了。我们现在再来讲一下，什么是面向对象分析和设计。这两个概念相对来说要简单一些。面向对象分析与设计中的“分析”和“设计”这两个词，我们完全可以从字面上去理解，不需要过度解读，简单类比软件开发中的需求分析、系统设计即可。不过，你可能会说，那为啥前面还加了个修饰词“面向对象”呢?有什么特殊的意义吗?<br>
之所以在前面加“面向对象”这几个字，是因为我们是围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[14Stream]]></title>
        <id>https://caldarius.github.io/post/14stream/</id>
        <link href="https://caldarius.github.io/post/14stream/">
        </link>
        <updated>2024-10-23T06:35:48.000Z</updated>
        <content type="html"><![CDATA[<p>“集合优化了对象的存储。而流（stream）与对象的成批处理有关。”</p>
<p>流是一个与任何特定的存储机制都没有关系的元素序列。事实上，我们说流“没有存储”。</p>
<p>不同于在集合中遍历元素，使用流的时候，我们是从一个管道中抽取元素，并对它进行操作。这些管道通常会被串联到一起，形成这个流上的一个操作管线。</p>
<p>大多数的时候，我们将对象存储在一个集合中是为了处理它们，所以你会发现，自己的编程重点将从集合转向流。</p>
<p>流的一个核心优点是，它能使我们的程序更小，也更好理解。当配合流使用的时候，lambda表达式和方法引用就发挥出威力了。</p>
<p>例如，假设我们想按照有序的方式显示随机选择的5~20范围内、不重复的int数。因为要对它们进行排序，所以我们会把注意力放在选择一个有序的几何上，并基于这样的集合来解决问题。但是借助流，只需要说明想做什么即可，开始了声明式编程：</p>
<pre><code class="language-java">package streams;

import java.util.Random;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/18
 * @description:
 */
public class Randoms {
    public static void main(String[] args) {
        new Random(34)
                //ints()方法会生成一个流，两参数的版本可以设置生成值的上下界
                .ints(5,20)
                //这里使用中间流操作distinct()去掉重复的值
                .distinct()
                //再使用limit()选择前七个值
                .limit(7)
                //然后告诉它希望元素是有序的
                .sorted()
                //最后，想显示每一个条目，使用了foreach()，它会根据我们传递的函数，
            	//在每个流对象上执行一个操作。这里传递了方法引用。
                .forEach(System.out::println);
    }
}
/*
Output:
6
7
9
13
16
17
19
*/

</code></pre>
<p>在<code>Randoms.java</code>中没有声明任何变量。流可以对有状态的系统建模，而不需要使用赋值或者可变数据，这一点会非常有用。</p>
<p>声明式编程是一种编程风格，我们说明想要完成什么，而不是指明怎么做。这种清晰的表达是使用流的最有说服力的原因。</p>
<p>用集合存储，循环语句遍历集合的迭代方式称为外部迭代。而在Randoms.java中，我们看不到任何这样的机制，所以被称为内部迭代。</p>
<p>内部迭代是流编程的一个核心特征。</p>
<p>内部迭代产生的代码不仅可读性好，而且容易利用多处理器；通过放宽对具体迭代的方式的控制，我们可以将其交给某种并行化机制。（进阶卷第五章。）</p>
<blockquote>
<p>流的另一个重要方面是惰性求值，这意味着他们只在绝对必要时才会被求值。我们可以把流想象为一个“延迟列表”。因为延迟求值，所以流使我们可以表示非常大的序列，而不用考虑内存问题。</p>
</blockquote>
<p>这一点有点重要的，在数据日益增多的年代。</p>
<h2 id="141java8对流的支持">14.1	Java8对流的支持</h2>
<p>对于形如Random这样简单的例子中，只需要添加更多的方法即可。最大的挑战来源于使用了接口的库，最终设计者使用了默认方法来完成对流的支持。这些操作可分为三种类型：创建流、修改流元素（中间操作）和消费流元素（终结操作）。消费流元素往往意味着收集一个流的元素（通常是将其放进某个集合）。</p>
<h2 id="142流的创建">14.2	流的创建</h2>
<p>使用Stream.of()，可以轻松地将一组条目变成一个流。</p>
<pre><code class="language-java">package streams;

import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/18
 * @description:
 */
public class StreamOf {
    public static void main(String[] args) {
        Stream.of(
                new Bubble(1),new Bubble(2),new Bubble(3)
        ).forEach(System.out::println);

        Stream.of(&quot;We &quot;,&quot;are &quot;,&quot;A-soul, &quot;,&quot;sing &quot;,&quot;with &quot;,&quot;me!&quot;)
                .forEach(System.out::print);
    }
}
/*
Output:
Bubble(1)
Bubble(2)
Bubble(3)
We are A-soul, sing with me!
*/
</code></pre>
<p>对于每个Collection来说，都可以用stream()来生成一个流：</p>
<pre><code class="language-java">package streams;

import java.util.*;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/18
 * @description:
 */
public class CollectionToStream {
    public static void main(String[] args) {
        List&lt;Bubble&gt; bubbles = Arrays.asList(
                new Bubble(1),new Bubble(2),new Bubble(3)
        );
        System.out.println(
                //在创建了一个List之后，只需要调用一下stream()这个所有集合类都有的方法就可以创建一个流
                bubbles.stream()
                        //map()操作接受流中的每个元素，在其上应用一个操作来创建一个新的元素，然后将这个新的元素沿着流继续传递下去。普通的map接受对象并生成对象，但是当希望输出流持有的是数值类型的值的时候，map()还有一组特殊的版本。这里的mapInt()将一个对象流转变为了一个包含Integer地IntStream。对于Float和Double，也有名字类似的操作。
                        .mapToInt(b -&gt; b.i)
                        .sum()
        );

        Set&lt;String&gt; stringSet = new HashSet&lt;&gt;(Arrays.asList(
                &quot;We are A-soul, sing with me!&quot;.split(&quot; &quot;)
        ));
        stringSet.stream()
                .map(x -&gt; x + &quot; &quot;)
                .forEach(System.out::print);
        System.out.println();
    
        Map&lt;String,Double&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;pi&quot; , 3.14159);
        map.put(&quot;e&quot; , 2.718);
        //为了从Map集合生成一个流，首先调用了一个entrySet()来生成一个对象流，其中每个对象都饱含着一个键和与其相关联的值，然后再使用getKey()和getValue()将其分开。
        map.entrySet().stream().map(e -&gt; e.getKey() + &quot; : &quot; + e.getValue()).forEach(System.out::println);

    }
}
/*
Output:
6
with are me! A-soul, sing We
e : 2.718
pi : 3.14159
*/
</code></pre>
<h3 id="1421随机数流">14.2.1	随机数流</h3>
<p>Random类已经得到了增强，有一组可以生成流的方法：</p>
<pre><code class="language-java">package streams;

import java.util.Random;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/18
 * @description:
 */
public class RandomGenerators {
    //这个T出现的位置稍微有点诡异嗷，你们静态类都这么骚的嘛。。。
    public static&lt;T&gt; void show(Stream&lt;T&gt; stream) {
        stream
                .limit(4)
                .forEach(System.out::println);
        System.out.println(&quot;+++++++&quot;);
    }

    public static void main(String[] args) {
        Random random = new Random(34);
        //全随机
        //boxed()流操作会自动将基本类型转换为对应包装器类型，方便show()能够接受这个流
        show(random.ints().boxed());
        show(random.longs().boxed());
        show(random.doubles().boxed());

        //控制上下边界
        show(random.ints(10,20).boxed());
        show(random.longs(50,100).boxed());
        show(random.doubles(20,30).boxed());

        //控制流大小
        show(random.ints(2).boxed());
        show(random.longs(2).boxed());
        show(random.doubles(2).boxed());

        //控制上下边界以及流大小
        show(random.ints(3,3,9).boxed());
        show(random.longs(3,12,22).boxed());
        show(random.doubles(3,11.5,12.3).boxed());



    }
}
/*
Output:
-1167027043
-419156489
1403888695
-1549698677
+++++++
-4679199665380035176
347502940777447066
-5462745394601655097
-8851080134503474781
+++++++
0.7406579108432636
0.6355572211802512
0.9195544072857654
0.8162380681826771
+++++++
15
10
10
10
+++++++
94
59
92
89
+++++++
27.665513893267452
25.731617742628153
24.329712582571936
26.79824204052263
+++++++
504567591
-1942394330
+++++++
499554011265826960
-9043429876051918953
+++++++
0.43264512973348723
0.6179190543130938
+++++++
6
4
4
+++++++
16
15
12
+++++++
12.162698058155284
12.145442409430226
11.962197131927406
+++++++
*/
</code></pre>
<p>我们可以使用Random来创建一个可以用以提供任何一组对象的Supplier。</p>
<pre><code class="language-java">package streams;


import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/18
 * @description:
 */
public class RandomWords implements Supplier {
    List&lt;String&gt; words = new ArrayList&lt;&gt;();
    Random random = new Random(34);
    //构造方法，完成words的初始化
    RandomWords(String fname) throws IOException {
        List&lt;String&gt; lines = Files.readAllLines(Paths.get(fname));
        //跳过第行，在文件中第一行是注释
        for (String line : lines.subList(1,lines.size())){
            for (String word: line.split(&quot;[ .?,]+&quot;))
                words.add(word.toLowerCase());
        }
    }
    @Override
    public String get() {
        return words.get(random.nextInt(words.size()));
    }

    @Override
    public String toString() {
        return words.stream()
                .collect(Collectors.joining(&quot; &quot;));
    }

    public static void main(String[] args) throws IOException {
        System.out.println(
                Stream.generate(new RandomWords(&quot;D:\\IDEAProjectSpace\\ONJava8Study\\OnJavaExample\\src\\streams\\Cheese.dat&quot;))
                        .limit(10)
                        .collect(Collectors.joining(&quot; &quot;))
        );
    }
}
//Output:leads so uncontaminated cheese so of certainly that shop is
</code></pre>
<h3 id="1422int类型的区间范围">14.2.2	int类型的区间范围</h3>
<p>IntStream提供了一个range()方法，可以生成一个流——由int值组成的序列。这在编写循环时非常方便：</p>
<pre><code class="language-java">package streams;

import static java.util.stream.IntStream.range;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/18
 * @description:
 */
public class Ranges {
    public static void main(String[] args) {
        //传统方式
        int result = 0;
        for (int i =10;i&lt;20;i++) {
            result += i;
        }
        System.out.println(result);

        result = 0;
        
        //创建了一个range()，并且将其变为一个可以用在for-in语句中的数组
        for (int i :range(10,20).toArray())
            result += 1;
        System.out.println(result);
        
        //这是目前最好的实现方法
        System.out.println(range(10,20).sum());
    }
}
</code></pre>
<p>有点像python靠拢的感觉了，或许之后学习其他主流语言的时候会更轻松一些。</p>
<h3 id="1423generate">14.2.3	generate()</h3>
<p>RandomWords.java用到了Supplier<T>和Stream.generate()。下面是第二个示例：</p>
<pre><code class="language-java">package streams;

import java.util.Random;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/19
 * @description:
 */
public class Generator implements Supplier&lt;String&gt; {
    Random random = new Random(34);
    char[] letters = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.toCharArray();
    @Override
    public String get() {
        //使用Random.nextInt()来选择字母表中的大写字母。参数告诉它可以接受的最大随机数，这样就不会超出边界了
        return &quot;&quot; + letters[random.nextInt(letters.length)];
    }

    public static void main(String[] args) {
        String word = Stream.generate(new Generator())
                .limit(30)
                .collect(Collectors.joining());
        System.out.println(word);
    }
}
</code></pre>
<p>如果想创建一个完全由相同的对象组成的流，只需要将一个生成这些对象的lambda表达式传给generate()：</p>
<pre><code class="language-java">package streams;

import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/19
 * @description:
 */
public class Duplicator {
    public static void main(String[] args) {
        Stream.generate(() -&gt; &quot;duplicate&quot;)
                .limit(3)
                .forEach(System.out::println);
    }
}
/*
Output:
duplicate
duplicate
duplicate
*/
</code></pre>
<h3 id="1424iterate">14.2.4	iterate()</h3>
<p>Stream.iterate()从一个种子开始（第一个参数），然后将其传给第二个参数所引用的方法，其结果被添加到这个流上，并且保存下来作为下一次iterate()调用的第一个参数，以此类推。我们可以通过迭代生成一个斐波那契数列：</p>
<pre><code class="language-java">package streams;

import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/19
 * @description:
 */
public class Fibonacci {
    //iterate()只会记住结果(result),所以这里用了x来记住另一个元素。x和i构成了闭包。
    int x = 1;
    Stream&lt;Integer&gt; numbers() {
        //0是第一个种子，lambda表达式是第二个参数。0是初始值，lambda表达式是递推式。
        return Stream.iterate(0,i -&gt;{
            int result = x + i;
            x = i;
            return result;
        });
    }

    public static void main(String[] args) {
        new Fibonacci().numbers()
                //skip()会直接丢弃由参数指定的相应数目的流元素。
                .skip(20)
                .limit(10)
                .forEach(System.out::println);
    }
}
/*
Output:
6765
10946
17711
28657
46368
75025
121393
196418
317811
514229
*/
</code></pre>
<h3 id="1425流生成器">14.2.5	流生成器</h3>
<p>在生成器（Builder）设计模式中，我们创建一个生成器对象，为它提供多段构造信息，最后执行“生成”（Build）动作。Stream库提供了这样一个Builder。这里回顾一下读取文件并将其转化为单词流的过程：</p>
<pre><code class="language-java">package streams;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/19
 * @description:
 */
public class FileToWordsBuilder {
    Stream.Builder&lt;String&gt; builder = Stream.builder();
    public FileToWordsBuilder(String filePath) throws IOException {
        //在构造器中完成了对builder的初始化，但是并没有调用build，这意味着还可以继续添加，如果希望这个类更完整的话应该加入一个flag来查看build是否被调用，再加入另一个方法继续添加单词。如果在调用build()之后还尝试向Stream.Builder中添加单词，则会产生异常。
        Files.lines(Paths.get(filePath))
                .skip(1)
                .forEach(line -&gt; {
                    for (String w : line.split(&quot;[ .?,]]+&quot;))
                        builder.add(w);
                });
    }
    Stream&lt;String&gt; stream() {return builder.build(); }

    public static void main(String[] args) throws IOException {
        new FileToWordsBuilder(&quot;D:\\IDEAProjectSpace\\ONJava8Study\\OnJavaExample\\src\\streams\\Cheese.dat&quot;).stream()
                .limit(7)
                .map(w -&gt; w+&quot; &quot;)
                .forEach(System.out::println);
    }
}
/*
Output:
Not much of a cheese shop really, is it? 
Finest in the district, sir. 
And what leads you to that conclusion? 
Well, it's so clean. 
It's certainly uncontaminated by cheese. 
*/
</code></pre>
<h3 id="1426arrays">14.2.6	Arrays</h3>
<p>Arrays类中包含了名为stream()的静态方法，可以将数组转化为流。可以重写interface/MetalWork.java中的main，创建一个流并在每一个元素上应用execute()</p>
<pre><code class="language-java">package streams;

import onjava.Operation;

import java.util.Arrays;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/19
 * @description:
 */
public class MetalWork2 {
    public static void main(String[] args) {
        Arrays.stream(new Operation[] {
                () -&gt; Operation.show(&quot;Heat&quot;),
                () -&gt; Operation.show(&quot;Hammer&quot;),
                () -&gt; Operation.show(&quot;Twist&quot;),
                () -&gt; Operation.show(&quot;Anneal&quot;),
        }).forEach(Operation::execute);
    }
}
/*
Output:
Heat
Hammer
Twist
Anneal
*/
</code></pre>
<p>stream()方法也可以生成IntStream、LongStream和DoubleStream。</p>
<p>stream()，还有一个三参的版本，额外的两个参数分别标识开始和结束的位置，左闭右开。</p>
<h3 id="1427正则表达式">14.2.7	正则表达式</h3>
<p>java的正则表达式（regular express）会在18章介绍。</p>
<p>Java8向java.until.regex.Pattern类中加入了一个新方法splitAsStream()，它能接受一个字符序列，并且根据我们传入的公式将其分割为一个流。这里有一个约束：splitAsStream()的输入应该是一个CharSequence，所以我们不能将一个流传到SplitAsStream()中。</p>
<p>下面，我们先使用流将文件转入一个单独的String，然后再使用正则表达式将这个String切割到一个单词流中：</p>
<pre><code class="language-java">package streams;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/19
 * @description:
 */
public class FileToWordsRegexp {
    private String all;

    public FileToWordsRegexp(String filePath) throws IOException {
        this.all = Files.lines(Paths.get(filePath))
                .skip(1)
                .collect(Collectors.joining(&quot; &quot;));
    }
    public Stream&lt;String&gt; stream() {
        return Pattern.compile(&quot;[ ,.?]+&quot;).splitAsStream(all);
    }

    public static void main(String[] args) throws IOException {
        FileToWordsRegexp fileToWordsRegexp = new FileToWordsRegexp(&quot;D:\\IDEAProjectSpace\\ONJava8Study\\OnJavaExample\\src\\streams\\Cheese.dat&quot;);
        fileToWordsRegexp.stream()
                .limit(7)
                .map(w -&gt; w+&quot; &quot;)
                .forEach(System.out::print);
        System.out.println(&quot;\n&quot;);
        fileToWordsRegexp.stream()
                .skip(7)
                .limit(2)
                .map(w -&gt; w+&quot; &quot;)
                .forEach(System.out::print);
    }
}
/*
Output:
Not much of a cheese shop really 

is it
*/
</code></pre>
<p>构造器读取文件中的所有行，转到了一个单独的String中。现在我们可以多次调用stream()来得到一个流。但是这里也有不足，整个文件都要存储在内存中。在大部分去情况下，这可能不是问题，但是会导致我们无法利用流的以下优势：</p>
<ol>
<li>不需要存储，虽然需要一部分内部存储。</li>
<li>惰性求值。</li>
</ol>
<p>后面将解决这个问题。</p>
<p>（需要对比一下之前几次的操作，看看有什么不一样的地方）</p>
<h2 id="143中间操作">14.3	中间操作</h2>
<p>这些操作从一个流中接收对象 ，并将对象作为另一个流送出后端，以连接到其他操作。</p>
<h3 id="1431跟踪与测试">14.3.1	跟踪与测试</h3>
<p>peek()操作就是用来辅助调试的。它允许我们查看流对象而不修改它们：</p>
<pre><code class="language-java">package streams;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/19
 * @description:
 */
public class Peeking {
    public static void main(String[] args) throws Exception {
        FileToWords.stream(&quot;D:\\IDEAProjectSpace\\ONJava8Study\\OnJavaExample\\src\\streams\\Cheese.dat&quot;)
                .skip(21)
                .limit(4)
                .map(w -&gt; w + &quot; &quot;)
                //peek()接受一个遵循Consumer函数式接口的函数，这样的函数没有返回值，也就不可能用不同的对象替换掉流中的对象。我们只能看看这些对象。
                .peek(System.out::print)
                .map(String::toLowerCase)
                .forEach(System.out::print);
    }
}
//Well well it it s s so so
</code></pre>
<h3 id="1432对流元素进行排序">14.3.2	对流元素进行排序</h3>
<p>我们在Randoms.java中看到过以默认的比较方式使用sorted()进行排序的情况。还有一种接受Comparator参数的sorted()形式：</p>
<pre><code class="language-java">package streams;

import java.util.Comparator;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/19
 * @description:
 */
public class SortedComparator {
    public static void main(String[] args) throws Exception {
        FileToWords.stream(&quot;D:\\IDEAProjectSpace\\ONJava8Study\\OnJavaExample\\src\\streams\\Cheese.dat&quot;)
                .skip(10)
                .limit(10)
                .sorted(Comparator.reverseOrder())
                .map(w -&gt; w + &quot; &quot;)
                .forEach(System.out::print);
    }
}
//Output:you what to the that sir leads in district And 
</code></pre>
<h3 id="1433移除元素">14.3.3	移除元素</h3>
<ul>
<li>distinct()：在Randoms.java中，distinct()移除了流中的重复元素。与创建一个Set来消除重复元素来讲，使用distinct()要省力得多。</li>
<li>fileter(Predicate)：过滤操作只保留符合特定条件的元素，也就是传给参数，结果为true的那些元素。</li>
</ul>
<p>在以下示例中，过滤函数isPrime()会检测素数：</p>
<pre><code class="language-java">package streams;

import java.util.stream.LongStream;

import static java.util.stream.LongStream.iterate;
import static java.util.stream.LongStream.rangeClosed;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/19
 * @description:
 */
public class Prime {
    public static boolean isPrime(long n) {
        //rangeClosed()包含了上界值。会遍历从2到上界值之间的所有整数。
        return rangeClosed(2,(long)Math.sqrt(n))
        //如果没有任何一个取余操作结果为0，则noneMatch()操作返回true。如果有任何一个计算结果等于0，则返回false。noneMatch()会在第一次失败之后推出，而不会吧后面的所有计算都尝试一遍。
                .noneMatch(i -&gt; n%i ==0);
    }
    public LongStream numbers() {
        //生成2到无穷个整数，然后留下素数
        return iterate(2,i -&gt; i + 1)
                .filter(Prime::isPrime);
    }

    public static void main(String[] args) {
        new Prime().numbers()
                .limit(10)
                .forEach(n -&gt; System.out.format(&quot;%d &quot;,n));
        System.out.println();
        new Prime().numbers()
                .skip(90)
                .limit(10)
                .forEach(n -&gt; System.out.format(&quot;%d &quot;,n));
    }
}
/*
Output:
2 3 5 7 11 13 17 19 23 29
467 479 487 491 499 503 509 521 523 541
*/
</code></pre>
<h3 id="1434将函数应用于每个流元素">14.3.4	将函数应用于每个流元素</h3>
<ul>
<li>map(Function)：将Function应用于输入流中的每个对象，结果作为输出流继续传递。</li>
<li>mapToInt(ToIntFunction)：同上，不过结果放在一个IntStream中。</li>
<li>mapToLong……</li>
<li>mapToDouble……</li>
</ul>
<p>这里我们将不同的Function映射（map()，map本身就是映射的意思）到了一个由String组成的流中。</p>
<pre><code class="language-java">package streams;

import java.util.Arrays;
import java.util.function.Function;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/19
 * @description:
 */
public class FunctionMap {
    static String[] elements = {
            &quot;12&quot; , &quot; &quot; , &quot;23&quot; , &quot;45&quot;
    };
    static Stream&lt;String&gt; testStream() {
        return Arrays.stream(elements);
    }
    static void test(String descr , Function&lt;String,String&gt; function) {
        System.out.println(&quot;---( &quot;+descr + &quot; )---&quot;);
        testStream()
                .map(function)
                .forEach(System.out::println);
    }

    public static void main(String[] args) {
        test(&quot;add brackets&quot;,s -&gt; &quot;[&quot; + s + &quot;]&quot;);

        test(&quot;Increment&quot;,s-&gt;{
            //如果这个字符串不能不能被表示为Integer，则会抛出NumberFormatException，然后将原始的数据放入输出流中
            try {
                return Integer.parseInt(s) + 1+&quot; &quot;;
            } catch (NumberFormatException e) {
                return s;
            }
        });

        test(&quot;Replace&quot;,s -&gt; s.replace(&quot;2&quot;,&quot;9&quot;));

        test(&quot;Take last digit&quot;,s-&gt; s.length() &gt; 0 ?
                s.charAt(s.length() -1) + &quot; &quot; : s);

    }
}
/*
Output:---( add brackets )---
[12]
[ ]
[23]
[45]
---( Increment )---
13

24
46
---( Replace )---
19

93
45
---( Take last digit )---
2

3
5
*/
</code></pre>
<p>在上面的例子中，map()将一个String映射到了另一个String上，但是没有理由要求生成的类型必须与输入的类型相同，所以可以在这里改变这个映射的规则：</p>
<pre><code class="language-java">package streams;

import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/19
 * @description:
 */
class Numbered {
    final int n;
    Numbered(int n) { this.n = n; }

    @Override
    public String toString() {
        return &quot;Numbered(&quot; + n + &quot;)&quot;;
    }
}
public class FunctionMap2 {
    public static void main(String[] args) {
        Stream.of(1,5,7,9,11,13)
                //接受的是int，然后使用构造器Numbered::new将其转变为Numbered
                //签名匹配上就行，其他不用关心。I匹配int，O匹配Numbered
                .map(Numbered::new)
                .forEach(System.out::println);
    }
}
/*
Output:
Numbered(1)
Numbered(5)
Numbered(7)
Numbered(9)
Numbered(11)
Numbered(13)
*/

</code></pre>
<p>如果Function生成的结果是某种数值类型，就必须使用相应的mapTo操作来代替。这一点令人感到遗憾，Java的设计者们没有在这门语言设计之初就努力消除基本类型。</p>
<p>有自动装箱和拆箱以及包装类型感觉还好吧。</p>
<h3 id="1435在应用map期间组合流">14.3.5	在应用map()期间组合流</h3>
<p>假设有一个由传入元素组成的流，我们在其上应用一个map()函数，这个函数有一些功能能上的独特优势，但是存在一个问题：它生成的是一个流。我们想要的是一个由<strong>元素</strong>组成的流，但是生成了一个由<strong>元素流</strong>组成的流。他将流经自己的元素输出为了一个流，所以需要一个方法来把它拉回去，变成元素。</p>
<p>flatMap会做两件事：接受生成流的函数，并将其应用于传入元素，然后将每个流扁平化处理，将其展开为元素。所以传出来的就是元素了。</p>
<ul>
<li>flaMap(Function)：当Function生成的是一个流时使用。</li>
<li>flaMapToInt(Funcation)：当Function生成的是一个IntStream时使用。</li>
<li>flaMapToFloat(Funcation)……</li>
<li>flaMapToDouble(Funcation)……</li>
</ul>
<pre><code class="language-java">package streams;

import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/19
 * @description:
 */
public class StreamOfStreams {
    public static void main(String[] args) {
        Stream.of(1,2,3)
                .map(i -&gt; Stream.of(&quot;Gonzo&quot;,&quot;Kermit&quot;,&quot;Beaker&quot;))
                .map(e -&gt; e.getClass().getName())
                .forEach(System.out::println);
    }
}
/*
Output:
java.util.stream.ReferencePipeline$Head
java.util.stream.ReferencePipeline$Head
java.util.stream.ReferencePipeline$Head
*/
</code></pre>
<pre><code class="language-java">package streams;

import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/19
 * @description:
 */
public class FlatMap {
    public static void main(String[] args) {
        Stream.of(1,2,3)
                .flatMap(i-&gt;Stream.of(&quot;Gonzo&quot;,&quot;Kermit&quot;,&quot;Beaker\n&quot;))
                .forEach(System.out::print);
    }
}
/*
Output:
GonzoKermitBeaker
GonzoKermitBeaker
GonzoKermitBeaker
*/
</code></pre>
<p>从这个映射返回的每个流都会被自动扁平化处理，展开为组成这个流的String元素。</p>
<p>下面是另一个示例。我们从一个整数值组成的流开始，然后使用其中的每一个来创建很多随机数：</p>
<pre><code class="language-java">package streams;

import java.util.Random;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/19
 * @description:
 */
public class StreamOfRandoms {
    static Random random = new Random(34);

    public static void main(String[] args) {
        Stream.of(1,2,3,4,5)
                .flatMapToInt(i -&gt;
                        IntStream.concat(
                        random.ints(0,100).limit(i),
                        IntStream.of(-1)
                ))
                .forEach(n -&gt;System.out.format(&quot;%d &quot;,n));
    }
}
//Output:26 -1 3 47 -1 9 13 72 -1 66 49 85 47 -1 5 89 67 97 43 -1
</code></pre>
<p>再来看一下将一个文件分解为单词流的人物。我们曾经写过的FileToWordsRegexp.java存在一个问题，就是需要将整个文件都读入到一个由文本行组成的List中，这也需要对应的存储空间。而我们想创建的是一个不需要中间存储的单词流。这正是flatMap()所要解决的问题：</p>
<pre><code class="language-java">package streams;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.regex.Pattern;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/19
 * @description:
 */
public class FileToWords {

    public static Stream&lt;String&gt; stream(String filePath)
            throws Exception {
        return Files.lines(Paths.get(filePath))
                .skip(1) // First (comment) line
                .flatMap(line -&gt;
                        //这里的正则表达式模式使用的是\\W。\\W意味着一个“非单词字符”，而+意味着“一个或者多个”。小写的\\w指的是单词字符
                        Pattern.compile(&quot;\\W+&quot;).splitAsStream(line));
    }
}

</code></pre>
<p>我们之前遇到的问题是，Pattern.compile().splitAsStream()生成的结果是一个流，这意味着在由文本行组成的输入流上调用map()，会生成一个由单词流组成的流，而我们需要的只是一个单词流而已。幸运的是，flatMap()可以将元素组成的流扁平化，将其变为由元素组成的一个简单的流。或者，我们可以使用String.split()，它会生成一个数组，然后使用Arrays.stream()将其转为流:</p>
<pre><code class="language-java">.flatMap(line -&gt; Arrays.stream(line.split(&quot;\\W+&quot;)))
</code></pre>
<p>因为现在得到的是一个真正的流，所以每当我们想要一个新的流时，都必须从头创建，因为它无法复用。</p>
<h2 id="144optional类型">14.4	Optional类型</h2>
<p>在研究终结操作之前，我们必须考虑一个问题：如果我们向流中请求对象，但是流中什么都没有，这时会发生什么呢？我们喜欢把流连接成“快乐通道”（happy path，指的是没有异常或者错误发生的默认场景），并假设没有什么会中断它。然而在流中放入一个null就能轻松破坏掉它。有没有某种我们可以使用的对象，既可以作为流元素来占位，也可以在我们要找的元素不存在时有好地告知我们（也就是说，不会抛出异常）。</p>
<p>这个想法被实现为OPtional类型。某些标准的流操作会返回Optional对象，因为它们不能确保所要的结果一定存在。这些流操作列举如下</p>
<ul>
<li>findFirst()返回包含第一个元素的OPtional。如果这个流为空，则返回Optional.empty。</li>
<li>findAny()返回包含任何元素的Optional()，如果这个流为空，则返回Optional.empty。</li>
<li>max()和min()分别返回包含流中最大值或者最小值Optional。如果这个流为空，则返回Optional.empty。</li>
<li>reduce()的一个版本，它并不以一个“Identity”对象作为其第一个参数（在reduce()的其他版本中，“Identity”对象会成为默认结果，所以不会有结果为空的风险），它会将返回值包含在一个Optional中。</li>
<li>对于数值化的流IntStream、LongStream和DoubleStream()，average()操作将其结果包在一个Optional中，以防流为空的情况。</li>
</ul>
<p>下面是所有这些操作在空流上的简单测试：</p>
<pre><code class="language-java">package streams;

import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/22
 * @description:
 */
public class OptionalsFromEmptyStreams {
    public static void main(String[] args) {
        //不是很理解&lt;String&gt;empty()这种写法，静态方法用泛型，后续到泛型再说。
        //空流可以通过Stream.&lt;String&gt;empty()创建，如果只使用了Stream.empty()而没有任何上下文信息，那么Java不知道它应该是什么类型的，而这种语法解决了这个问题。
        //如果编译器有足够的上下文信息那么它就能推断出empty()调用的类型：
        Stream&lt;String&gt; stream = Stream.empty();
        
        System.out.println(Stream.&lt;String&gt;empty().findFirst());
        System.out.println(Stream.&lt;String&gt;empty().findAny());
        System.out.println(Stream.&lt;String&gt;empty().max(String.CASE_INSENSITIVE_ORDER));
        System.out.println(Stream.&lt;String&gt;empty().min(String.CASE_INSENSITIVE_ORDER));
        System.out.println(Stream.&lt;String&gt;empty().reduce((s1, s2) -&gt; s1+s2));
        System.out.println(IntStream.empty().average());
    }
}
/*
Output:
Optional.empty
Optional.empty
Optional.empty
Optional.empty
Optional.empty
OptionalDouble.empty
*/

</code></pre>
<p>这时不会因为流是空的而抛出异常，而是会得到一个Optional.empty()对象。Optional有一个toString()方法，可以显示有用信息。</p>
<p>下面的示例演示了Optional的两个基本动作。我们接收到一个Optional时，首先要调用isPresent(),看看里面是不是有东西，如果有再使用get()来获取。</p>
<pre><code class="language-java">package streams;

import java.util.Optional;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/22
 * @description:
 */
public class OptionalBasics {
    static void test(Optional&lt;String&gt; optionalString) {
        if (optionalString.isPresent())
            System.out.println(optionalString.get());
        else
            System.out.println(&quot;Nothing inside!&quot;);
    }

    public static void main(String[] args) {
        test(Stream.of(&quot;Epithets&quot;).findFirst());
        test(Stream.&lt;String&gt;empty().findFirst());
    }
}
/*
Output:
Epithets
Nothing inside!
*/
</code></pre>
<h3 id="1441便捷函数">14.4.1	便捷函数</h3>
<p>有很多便捷函数，可用于获取Optional中的数据，他们简化了上面“先检查再处理所包含对象”的过程。</p>
<ul>
<li>ifPresent(Consumer)：如果值存在，则用这个值来调用Consumer，否则什么都不做。</li>
<li>orElse(OtherObject)：如果对象存在，则返回这个对象，否则返回OtherObject。</li>
<li>orElseGet(Supplier)：如果对象存在，则返回这个对象，否则返回使用Supplier函数创建的替代对象。</li>
<li>orElseThrow(Supplier)：如果对象存在，则返回这个对象，否则抛出一个使用Supplier函数创建的异常。</li>
</ul>
<p>下面演示一下这些便捷函数：</p>
<pre><code class="language-java">package streams;

import java.util.Optional;
import java.util.function.Consumer;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/22
 * @description:
 */
public class Optionals {
    static void basics(Optional&lt;String&gt; optionalString) {
        if(optionalString.isPresent())
            System.out.println(optionalString.get());
        else
            System.out.println(&quot;Nothing inside!&quot;);
    }

    static void ifPresent(Optional&lt;String&gt; optionalString) {
        optionalString.ifPresent(System.out::println);
    }
    static void orElse(Optional&lt;String&gt; optionalString) {
        System.out.println(optionalString.orElse(&quot;Nada&quot;));
    }
    static void orElseGet(Optional&lt;String&gt; optionalString) {
        System.out.println(optionalString.orElseGet(() -&gt; &quot;Generated&quot;));
    }
    static void orElseThrow(Optional&lt;String&gt; optionalString) {
        try {
            System.out.println(optionalString.orElseThrow(
                    () -&gt;new Exception(&quot;Supplied&quot;)
            ));
        } catch (Exception e) {
            System.out.println(&quot;Caught&quot; + e);
        }
    }
    //test()方法接受一个匹配所有示例方法的Consumer，可以避免代码重复。
    static void test(String testName,
                     Consumer&lt;Optional&lt;String&gt;&gt; consumerOptional) {
        System.out.println(&quot; === &quot; + testName + &quot; === &quot;);
        //通过accept()方法调用绑定的方法。
        consumerOptional.accept(Stream.of(&quot;Epithets&quot;).findFirst());
        consumerOptional.accept(Stream.&lt;String&gt;empty().findFirst());
    }

    public static void main(String[] args) {
        test(&quot;basics&quot;,Optionals::basics);
        test(&quot;ifPresent&quot;,Optionals::ifPresent);
        test(&quot;orElse&quot;,Optionals::orElse);
        test(&quot;orElseGet&quot;,Optionals::orElseGet);
        test(&quot;orElseThrow&quot;,Optionals::orElseThrow);
    }
}
/*
Output:
=== basics === 
Epithets
Nothing inside!
 === ifPresent === 
Epithets
 === orElse === 
Epithets
Nada
 === orElseGet === 
Epithets
Generated
 === orElseThrow === 
Epithets
Caughtjava.lang.Exception: Supplied

*/
</code></pre>
<h3 id="1442创建optional">14.4.2	创建Optional</h3>
<p>当需要自己编写生成Optional代码时，有如下三种可以使用的静态方法。</p>
<ul>
<li>empty()：返回一个空的Optional。</li>
<li>of(value)：如果已经知道这个value不是null，可以使用该方法将其包在一个Optional中。</li>
<li>ofNullable(value)：如果不知道这个value是不是null，使用这个方法。如果value为null，它会自动返回Optional.empty，否则会将这个value包在一个Optional中。</li>
</ul>
<p>在以下示例中可以看到这些方法是如何工作的：</p>
<pre><code class="language-java">package streams;

import java.util.Optional;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/22
 * @description:
 */
public class CreatingOptionals {
    static void test(String testName, Optional&lt;String&gt; optionalString) {
        System.out.println(&quot; === &quot; + testName + &quot; === &quot;);
        //通过accept()方法调用绑定的方法。
        System.out.println(optionalString.orElse(&quot;Null&quot;));
    }

    public static void main(String[] args) {
        test(&quot;empty&quot;,Optional.empty());
        test(&quot;of&quot;,Optional.of(&quot;Howdy&quot;));
        try {
            test(&quot;of&quot;,Optional.of(&quot;Howdy&quot;));
        } catch (Exception e) {
            System.out.println(e);
        }
        //ofNullable()可以优雅地处理null，所以它看起来是最安全的一个。
        test(&quot;ofNullable&quot;,Optional.ofNullable(&quot;Hi&quot;));
        test(&quot;ofNullable&quot;,Optional.ofNullable(null));
    }
}
/*
Output:
 === empty ===
Null
 === of ===
Howdy
 === of ===
Howdy
 === ofNullable ===
Hi
 === ofNullable ===
Null
*/
</code></pre>
<h3 id="1443optional对象上的操作">14.4.3	Optional对象上的操作</h3>
<p>有三种方法支持对Optional进行事后处理，如果你的流管线生成了一个Optional，你可以在最后再做一项处理。</p>
<ul>
<li>filter(Predicate)：将Predicate应用于Optional的内容，并返回其结果。如果Optional与Predicate的内容不匹配，则将其转换为empty。如果Optional本身已经是empty，则直接返回。</li>
<li><code>map(Function)</code>：如果<code>Optional</code>不为<code>empty</code>，则将<code>Function</code>应用于<code>Optional</code>中包含的对象，并返回结果。否则传回<code>Optional.empty</code>。</li>
<li><code>flatMap(Function)</code>：和 <code>map()</code>类似，但是所提供的映射函数会将结果包在<code>Optional</code>中，这样<code>flatMap()</code>最后就不会再做任何包装了。</li>
</ul>
<p>数值化的Optional上没有提供这些操作。</p>
<p>对于普通的流filter()而言，如果Predicate返回false，它会将元素从流中删除。但是对于Optional.filter()而言，如果Predicate返回false，它不会删除元素，但是会将其转化为empty。下面这个示例探索了filter()的用法：</p>
<pre><code class="language-java">package streams;

import java.util.Arrays;
import java.util.function.Predicate;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/22
 * @description:
 */
public class OptionalFilter {
    static String[] elements = {
            &quot;Foo&quot;,&quot;&quot;,&quot;Bar&quot;,&quot;Baz&quot;,&quot;Bingo&quot;
    };
    static Stream&lt;String&gt; testStream() {
        return Arrays.stream(elements);
    }
    static void test(String descr, Predicate&lt;String&gt; predicate) {
        System.out.println(&quot; ---( &quot; + descr + &quot; )---&quot;);
        //注意这里用了等号，所以最后一个元素在实际上会超出这个流，但是它会自动变成Optional.empty。
        for(int i = 0; i &lt;= elements.length; i++) {
            System.out.println(
                    testStream()
                            .skip(i)
                            //获得剩余元素种地第一个，然后将其包裹在Optional中返回
                            .findFirst()
                            .filter(predicate));
        }

    }
    public static void main(String[] args) {
        test(&quot;true&quot;, str -&gt; true);
        test(&quot;false&quot;, str -&gt; false);
        test(&quot;str != \&quot;\&quot;&quot;, str -&gt; str != &quot;&quot;);
        test(&quot;str.length() == 3&quot;, str -&gt; str.length() == 3);
        test(&quot;startsWith(\&quot;B\&quot;)&quot;,
                str -&gt; str.startsWith(&quot;B&quot;));
    }
}
/*
Output:
 ---( true )---
Optional[Foo]
Optional[]
Optional[Bar]
Optional[Baz]
Optional[Bingo]
Optional.empty
 ---( false )---
Optional.empty
Optional.empty
Optional.empty
Optional.empty
Optional.empty
Optional.empty
 ---( str != &quot;&quot; )---
Optional[Foo]
Optional.empty
Optional[Bar]
Optional[Baz]
Optional[Bingo]
Optional.empty
 ---( str.length() == 3 )---
Optional[Foo]
Optional.empty
Optional[Bar]
Optional[Baz]
Optional.empty
Optional.empty
 ---( startsWith(&quot;B&quot;) )---
Optional.empty
Optional.empty
Optional[Bar]
Optional[Baz]
Optional[Bingo]
Optional.empty
*/

</code></pre>
<p>类似于<code>map()</code>，<code>Optional.map()</code>会应用一个函数，但是在<code>Optional</code>的情况下，只有当<code>Optional</code>不为<code>empty</code>时，它才会应用这个映射函数。它也会提取<code>Optional</code>所包含的对象，并将其交给映射函数：</p>
<pre><code class="language-java">package streams;

import java.util.Arrays;
import java.util.function.Function;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/22
 * @description:
 */
public class OptionalMap {
    static String[] elements = { &quot;12&quot;, &quot;&quot;, &quot;23&quot;, &quot;45&quot; };
    static Stream&lt;String&gt; testStream() {
        return Arrays.stream(elements);
    }
    static void test(String describe, Function&lt;String, String&gt; function) {
        System.out.println(&quot; ---( &quot; + describe + &quot; )---&quot;);
        for(int i = 0; i &lt;= elements.length; i++) {
            System.out.println(
                    testStream()
                            .skip(i)
                            .findFirst() 
                            .map(function));
        }
    }
    public static void main(String[] args) {

        test(&quot;Add brackets&quot;, s -&gt; &quot;[&quot; + s + &quot;]&quot;);

        test(&quot;Increment&quot;, s -&gt; {
            try {
                return Integer.parseInt(s) + 1 + &quot;&quot;;
            } catch(NumberFormatException e) {
                return s;
            }
        });

        test(&quot;Replace&quot;, s -&gt; s.replace(&quot;2&quot;, &quot;9&quot;));

        test(&quot;Take last digit&quot;, s -&gt; s.length() &gt; 0 ?
                s.charAt(s.length() - 1) + &quot;&quot; : s);
    }
}
/*
Output:
 ---( Add brackets )---
Optional[[12]]
Optional[[]]
Optional[[23]]
Optional[[45]]
Optional.empty
 ---( Increment )---
Optional[13]
Optional[]
Optional[24]
Optional[46]
Optional.empty
 ---( Replace )---
Optional[19]
Optional[]
Optional[93]
Optional[45]
Optional.empty
 ---( Take last digit )---
Optional[2]
Optional[]
Optional[3]
Optional[5]
Optional.empty
*/
</code></pre>
<p>映射函数的结果会被自动地包在一个<code>Optional</code>中。正如我们所看到的，遇到<code>Optional.empty</code>会直接通过，不在其上应用映射函数。</p>
<p><code>Optional</code>的<code>flatMap()</code>被应用于已经会生成<code>Optional</code>的映射函数，所以<code>flatMap()</code>不会像<code>map()</code>那样把结果包在<code>Optional</code>中：</p>
<pre><code class="language-java">package streams;

import java.util.Arrays;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/22
 * @description:
 */
public class OptionalFlatMap {
    static String[] elements = { &quot;12&quot;, &quot;&quot;, &quot;23&quot;, &quot;45&quot; };
    static Stream&lt;String&gt; testStream() {
        return Arrays.stream(elements);
    }
    //参数太长的时候分层写或许会更清晰一点。
    static void test(String descr,
                     Function&lt;String, Optional&lt;String&gt;&gt; func) {
        System.out.println(&quot; ---( &quot; + descr + &quot; )---&quot;);
        for(int i = 0; i &lt;= elements.length; i++) {
            System.out.println(
                    testStream()
                            .skip(i)
                            .findFirst()
                            .flatMap(func));
        }
    }
    public static void main(String[] args) {

        test(&quot;Add brackets&quot;,
                //如果已经知道这个value不是null，可以使用Optional.of(value)将其包在一个Optional中。
                s -&gt; Optional.of(&quot;[&quot; + s + &quot;]&quot;));

        test(&quot;Increment&quot;, s -&gt; {
            try {
                return Optional.of(
                        Integer.parseInt(s) + 1 + &quot;&quot;);
            } catch(NumberFormatException e) {
                return Optional.of(s);
            }
        });

        test(&quot;Replace&quot;,
                s -&gt; Optional.of(s.replace(&quot;2&quot;, &quot;9&quot;)));

        test(&quot;Take last digit&quot;,
                s -&gt; Optional.of(s.length() &gt; 0 ?
                        s.charAt(s.length() - 1) + &quot;&quot;
                        : s));
    }
}
/*
Output:
---( Add brackets )---
Optional[[12]]
Optional[[]]
Optional[[23]]
Optional[[45]]
Optional.empty
 ---( Increment )---
Optional[13]
Optional[]
Optional[24]
Optional[46]
Optional.empty
 ---( Replace )---
Optional[19]
Optional[]
Optional[93]
Optional[45]
Optional.empty
 ---( Take last digit )---
Optional[2]
Optional[]
Optional[3]
Optional[5]
Optional.empty
*/
</code></pre>
<p>和<code>map()</code>类似，<code>flatMap()</code>会获得非<code>empty</code>的<code>Optional</code>中的对象，并将其交给映射函数。它们唯一的区别是，<code>flatMap()</code>不会将结果包在<code>Optional</code>中，因为这个事映射函数已经做了。在上面的示例中，我已经明确地在每个映射函数内做了包装，但显然<code>Optional.flatMap()</code>是为已经能够自己生成<code>Optional</code>的函数设计的。</p>
<h3 id="1444由optional组成的流">14.4.4	由Optional组成的流</h3>
<p>假设有一个可能会生成<code>null</code>值的生成器。如果使用这个生成器创建了一个流，我们自然想将这些元素包在<code>Optional</code>中。它看上去应该是这样的：</p>
<pre><code class="language-java">package streams;

import java.util.Optional;
import java.util.Random;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/22
 * @description:
 */
public class Signal {
    private final String msg;
    public Signal(String msg) { this.msg = msg; }
    public String getMsg() {return msg;}

    @Override
    public String toString() {
        return &quot;Signal(&quot; + msg + &quot;)&quot;;
    }
    static Random rand = new Random(34);
    public static Signal morse() {
        switch(rand.nextInt(4)) {
            case 1: return new Signal(&quot;dot&quot;);
            case 2: return new Signal(&quot;dash&quot;);
            default: return null;
        }
    }
    public static Stream&lt;Optional&lt;Signal&gt;&gt; stream() {
        //Stream.gengerate()方法用于生成一系列相同类型的对象。
        return Stream.generate(Signal::morse)
                .map(signal -&gt; Optional.ofNullable(signal));
    }
}
</code></pre>
<p>当使用这个流时，我们必须弄清楚如何获得<code>Optional</code>中的对象：</p>
<pre><code class="language-java">package streams;

import java.util.Optional;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/23
 * @description:
 */
public class StreamOfOptionals {
    public static void main(String[] args) {
        Signal.stream()
                .limit(10)
                .forEach(System.out::println);
        System.out.println(&quot; ---&quot;);
        Signal.stream()
                .limit(10)
                .filter(Optional::isPresent)
                .map(Optional::get)
                .forEach(System.out::println);
    }
}
/*
Output:
Optional[Signal(dash)]
Optional.empty
Optional[Signal(dot)]
Optional[Signal(dash)]
Optional[Signal(dash)]
Optional.empty
Optional.empty
Optional[Signal(dot)]
Optional[Signal(dash)]
Optional[Signal(dash)]
 ---
Signal(dash)
Signal(dot)
Signal(dash)
Signal(dash)
Signal(dash)
Signal(dash)
*/
</code></pre>
<p>这里我使用了<code>filter()</code>，只保留非<code>empty</code>的<code>Optional</code>，然后通过<code>map()</code>调用<code>get()</code>来获得包在其中的对象。因为每种情况都需要我们来决定“没有值”的含义，所以我们通常需要针对每种应用采取不同的方法。</p>
<h2 id="145终结操作">14.5	终结操作</h2>
<p>这些操作接受一个流，并生成一个最终结果。它们不会再把任何东西发给某个后端的流。因此，终结操作总是我们在一个管线内可以做的最后一件事。</p>
<ul>
<li><code>toArray()</code>：将流元素转换到适当类型的数组中。</li>
<li><code>toArray(generator)</code>：<code>generator</code>用于在特定情况下分配自己的数组存储。</li>
</ul>
<p>如果流操作生成的内容必须以数组形式使用，这就很有用了。例如，假设我们想获得随机数，同时希望以流的形式复用它们，这样我们每次得到的都是相同的流。我们可以将其保存在一个数组中，来实现这个目的。</p>
<pre><code class="language-java">package streams;

import java.util.Arrays;
import java.util.Random;
import java.util.stream.IntStream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/23
 * @description:
 */
public class RandInts {
    private static int[] rints = new Random(34)
            .ints(0,1000)
            .limit(100)
            .toArray();
    public static IntStream rands() {
        return Arrays.stream(rints);
    }
}
</code></pre>
<p>由100个0~1000范围内的<code>int</code>类型随机数组成的流，被转换成了一个数组，并存储在<code>rints</code>中，这样每次调用<code>rands()</code>就能重复获得相同的流了。</p>
<h3 id="1452在每个流元素上应用某个终结操作">14.5.2	在每个流元素上应用某个终结操作</h3>
<ul>
<li><code>forEach(Consumer)</code>：这种用法我们已经看到过很多次了——以<code>System.out::println</code>作为<code>Consumer</code>函数。</li>
<li><code>forEachOrdered(Consumer)</code>：这个版本确保<code>forEach</code>对元素的操作顺序是原始的流的顺序。</li>
</ul>
<p>（我认为这里深刻体现了函数是行为的抽象这一本质，传入每个元素需要做的事情）</p>
<p>第一种形式被明确地设计为可以以任何顺序操作元素，这只有在引入<code>parallel()</code>操作时才有意义。我们在进入进阶卷第5章之前不会深入研究这个问题，不过可以先简单介绍一下：<code>parallel()</code>让Java尝试在多个处理器上执行操作。它可以做到这一点，正是因为使用了流——它可以将流分割为多个流（通常情况是，每个处理器一个流），并在不同的处理器上运行每个流。因为我们使用的是内部迭代，而不是外部迭代，所以这种情况是可能的。</p>
<p>在你对看似简单的<code>parallel()</code>感到跃跃欲试之前，我要先提醒一下，它使用起来是相当复杂的，所以在进入进阶卷第5章之前，先不要着急。</p>
<p>可以通过在一个示例中引入<code>parallel()</code>来了解<code>forEachOrdered(Consumer)</code>的作用和必要性：</p>
<pre><code class="language-java">package streams;

import static streams.RandInts.rands;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/23
 * @description:
 */
public class ForEach {
    static final int SIZE = 14;
    public static void main(String[] args) {
        rands().limit(SIZE)
                .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
        System.out.println();
        rands().limit(SIZE)
                .parallel()
                .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
        System.out.println();
        rands().limit(SIZE)
                .parallel()
                .forEachOrdered(n -&gt; System.out.format(&quot;%d &quot;, n));
    }
}
/*Output:
126 403 347 309 113 772 666 749 385 947 305 489 767 697
767 697 749 385 666 309 403 947 772 347 489 113 305 126
126 403 347 309 113 772 666 749 385 947 305 489 767 697
第二次运行:
126 403 347 309 113 772 666 749 385 947 305 489 767 697 
767 697 749 385 403 309 947 666 113 347 126 772 489 305 
126 403 347 309 113 772 666 749 385 947 305 489 767 697
*/
</code></pre>
<p>这里将<code>sz</code>（这里博主用了Size）分离出来，以便尝试不同的大小。然而，即使<code>sz</code>为<code>14</code>这个值，也已经产生有意思的结果了。在第一个流中，我们没有使用<code>parallel()</code>，所以结果的显示顺序就是它们从<code>rands()</code>中出现的顺序。第二个流引入了<code>parallel()</code>，即便是这么小的一个流，我们也可以看到输出的顺序和之前不一样了。这是因为有多个处理器在处理这个问题，而且如果多次运行这个程序，你会发现每一次的输出还会有所不同，原因在于多个处理器同时处理这个问题所带来的不确定性因素。</p>
<p>最后一个流仍然使用了<code>parallel()</code>，但是又使用<code>forEachOrdered()</code>来强制结果回到原始的顺序。因此，对于非<code>parallel()</code>的流，使用<code>forEachOrdered()</code>不会有任何影响。</p>
<h3 id="1453收集操作">14.5.3	收集操作</h3>
<ul>
<li><code>collect(Collector)</code>：使用这个<code>Collector</code>将流元素累加到一个结果集合中。</li>
<li><code>collect(Supplier, BiConsumer, BiConsumer)</code>：和上面类似，但是<code>Supplier</code>会创建一个新的结果集合，第一个<code>BiConsumer</code>是用来将下一个元素包含到结果中的函数，第二个<code>BiConsumer</code>用于将两个值组合起来。</li>
</ul>
<p>我们仅仅看到了<code>Collectors</code>对象的几个示例。如果看一下<code>java.util.stream.Collectors</code>的文档，你会发现其中的一些对象相当复杂。例如，我们可以将流元素收集到任何特定种类的集合中。假设想把我们的条目最终放到一个<code>TreeSet</code>中，由此使它们总是有序的。在<code>Collectors</code>中没有特定的<code>toTreeSet()</code>方法，但是可以使用<code>Collectors.toCollection()</code>，并将任何类型的<code>Collection</code>的构造器引用传给它。下面的程序提取文件中的单词放到<code>TreeSet</code>中：</p>
<pre><code class="language-java">package streams;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/23
 * @description:
 */
public class TreeSetOfWords {
    public static void main(String[] args) throws IOException {
        Set&lt;String&gt; words2 =
                Files.lines(Paths.get(&quot;D:\\IDEAProjectSpace\\ONJava8Study\\OnJavaExample\\src\\streams\\TreeSetOfWords.java&quot;))
                        .flatMap(s -&gt; Arrays.stream(s.split(&quot;\\W+&quot;)))
                        //去掉所有的数字
                        .filter(s -&gt; !s.matches(&quot;\\d+&quot;))
                        //去除周围可能存在的任何空白
                        .map(String::trim)
                        //去除所有长度小于3的单词
                        .filter(s -&gt; s.length() &gt; 2)
                        .limit(100)
                        .collect(Collectors.toCollection(TreeSet::new));
        System.out.println(words2);

    }
}
/*
Output:
[Arrays, Caldarius, Collectors, Created, Files, IDEA, IDEAProjectSpace, IOException, IntelliJ, ONJava8Study, OnJavaExample, Paths, Set, String, System, TreeSet, TreeSetOfWords, args, author, class, collect, date, description, file, filter, flatMap, get, import, java, length, limit, lines, main, map, matches, new, nio, out, package, println, public, split, src, static, stream, streams, throws, toCollection, trim, util, void, with, words2]
*/
</code></pre>
<p>可以从某个流生成一个<code>Map</code>：</p>
<pre><code class="language-java">package streams;

import java.util.Iterator;
import java.util.Map;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/23
 * @description:
 */

//Pair
class Pair {
    //Pair是一个基本数据对象，保存着c和i的值
    public final Character c;
    public final Integer i;
    Pair(Character c, Integer i) {
        this.c = c;
        this.i = i;
    }
    public Character getC() { return c; }
    public Integer getI() { return i; }
    @Override public String toString() {
        return &quot;Pair(&quot; + c + &quot;, &quot; + i + &quot;)&quot;;
    }
}

class RandomPair {
    Random rand = new Random(34);
    // 一个无限大的迭代器，指向随机生成的大写字母：
    Iterator&lt;Character&gt; capChars = rand.ints(65,91)
            .mapToObj(i -&gt; (char)i)
            .iterator();
    public Stream&lt;Pair&gt; stream() {
        return rand.ints(100, 1000).distinct()
                //生成一个Pair流，其中的Pair对象是由随机生成的大写字母与随机生成的100~1000的整数组成的
                .mapToObj(i -&gt; new Pair(capChars.next(), i));
    }
}
public class MapCollector {
    public static void main(String[] args) {
        Map&lt;Integer, Character&gt; map =
                new RandomPair().stream()
                        .limit(8)
                        .collect(
                                Collectors.toMap(Pair::getI, Pair::getC));
        System.out.println(map);
    }

}
//Output:{626=F, 643=O, 885=R, 247=H, 666=D, 667=V, 813=G, 605=F}
</code></pre>
<p>大多数情况下，如果看一下<code>java.util.stream.Collectors</code>，就能找到一个满足我们要求的预定义<code>Collector</code>。找不到的情况只是极少数，这时候可以使用<code>collect()</code>的第二种形式。下面的示例演示了第二种形式的基本情况：</p>
<pre><code class="language-java">package streams;

import java.util.ArrayList;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/23
 * @description:
 */
public class SpecialCollector {
    public static void main(String[] args) throws Exception {
        ArrayList&lt;String&gt; words =
                FileToWords.stream(&quot;D:\\IDEAProjectSpace\\ONJava8Study\\OnJavaExample\\src\\streams\\Cheese.dat&quot;)
                        //第一个参数表示收集的结果应该放在一个ArrayList中
                        //第二个参数表示用add()方法将结果折叠到一个容器中
                        /*
                        compatible with the accumulator function. The combiner function must fold the elements from the second result container into the first result container.
                        * combiner - 一个关联的、非干扰的、无状态的函数，接受两个部分结果容器并将它们合并，它必须与 accumulator 函数兼容。组合器函数必须将第二个结果容器中的元素折叠到第一个结果容器中。
                        * 在事实上完成了第一个容器和第二个容器和合并。
                        */
                        .collect(ArrayList::new,
                                ArrayList::add,
                                ArrayList::addAll);
        words.stream()
                .filter(s -&gt; s.equals(&quot;cheese&quot;))
                .forEach(System.out::println);
    }
}
/*
Output:
cheese
cheese
*/
</code></pre>
<h3 id="1454组合所有的流元素">14.5.4	组合所有的流元素</h3>
<ul>
<li><code>reduce(BinaryOperator)</code>：使用<code>BinaryOperator</code>来组合所有的流元素。因为这个流可能为空，所以返回的是一个<code>Optional</code>。</li>
<li><code>reduce(identity, BinaryOperator)</code>：和上面一样，但是将<code>identity</code>用作这个组合的初始值。因此，即使这个流是空的，我们仍然能得到<code>identity</code>作为结果。</li>
<li><code>reduce(identity, BiFunction, BinaryOperator)</code>：这个更复杂（所以我们不会介绍），但是之所以把它列在这里，是因为它可能更高效。可以通过组合显式的<code>map()</code>和<code>reduce()</code>操作来更简单地表达这样的需求。</li>
</ul>
<p>下面是一个有意设计的示例，用以演示<code>reduce()</code>：</p>
<pre><code class="language-java">package streams;

import java.util.Random;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/23
 * @description:
 */
//frobnitz有“小零件”的意思
class Frobnitz {
    int size;
    Frobnitz(int size) { this.size = size; }
    @Override
    public String toString() {
        return &quot;Frobnitz(&quot; + size + &quot;)&quot;;
    }
    // 生成器：
    static Random rand = new Random(34);
    static final int BOUND = 100;
    static Frobnitz supply() {
        return new Frobnitz(rand.nextInt(BOUND));
    }
}
public class Reduce {
    public static void main(String[] args) {
        //我们可以把一个方法引用传给Stream.generate()，因为它与Supplier&lt;Frobnitz&gt;是签名兼容的（这种签名兼容叫作结构一致性）。
        Stream.generate(Frobnitz::supply)
                .limit(10)
                .peek(System.out::println)
                //没有提供作为初始值的第一个参数，意味着我们调用的是一个会生成Optional的版本。lambda表达式中的第一个参数fr0是上次调用这个reduce()时带回的结果，第二个参数fr1是来自流中的新值。所有的流元素被这样一个个地拼接起来。
                .reduce((fr0, fr1) -&gt; fr0.size &lt; 50 ? fr0 : fr1)
                .ifPresent(System.out::println);
    }
}
/*
Output:
Frobnitz(26)
Frobnitz(3)
Frobnitz(47)
Frobnitz(9)
Frobnitz(13)
Frobnitz(72)
Frobnitz(66)
Frobnitz(49)
Frobnitz(85)
Frobnitz(47)
//下面就是我们得到的第一个size小于50地Fronitz
Frobnitz(26)
*/
</code></pre>
<p>作为结果，我们得到的是流中<strong>第一个</strong><code>size</code>小于50的<code>Frobnitz</code>——一旦找到了一个这样的对象，它就会抓住不放，哪怕还会出现其他候选。尽管这个约束相当奇怪，但它确实让我们对<code>reduce()</code>有了更多的了解。</p>
<h3 id="1455匹配">14.5.5	匹配</h3>
<ul>
<li><code>allMatch(Predicate)</code>：当使用所提供的<code>Predicate</code>检测流中的元素时，如果<strong>每一个</strong>元素都得到<code>true</code>，则返回<code>true</code>。在遇到第一个<code>false</code>时，会短路计算。也就是说，在找到一个<code>false</code>之后，它不会继续计算。</li>
<li><code>anyMatch(Predicate)</code>：当使用所提供的<code>Predicate</code>检测流中的元素时，如果有<strong>任何一个</strong>元素能得到<code>true</code>，则返回<code>true</code>。在遇到第一个 <code>true</code>时，会短路计算。</li>
<li><code>noneMatch(Predicate)</code>：当使用所提供的<code>Predicate</code>检测流中的元素时，如果<strong>没有</strong>元素得到<code>true</code>，则返回<code>true</code>。在遇到第一个<code>true</code>时，会短路计算。</li>
</ul>
<p>我们已经在Prime.java中看到过<code>noneMatch()</code>的一个示例，<code>allMatch()</code>和<code>anyMatch()</code>的用法几乎一样。</p>
<p>让我们探讨一下短路计算行为。为了创建一个消除了重复代码的<code>show()</code>方法，我们必须先找到一般化地描述所有这三种匹配操作的办法，然后将其变为一个叫作<code>Matcher</code>的接口：</p>
<pre><code class="language-java">package streams;

import java.util.function.BiPredicate;
import java.util.function.Predicate;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/23
 * @description:
 */
//BiPredicate是一个二元谓词，这只是说，它会接受两个参数，并返回 true或false。第一个参数是我们要测试的数值的流，第二个参数是谓词Predicate本身。
interface Matcher extends BiPredicate&lt;Stream&lt;Integer&gt;, Predicate&lt;Integer&gt;&gt; {}




public class Maching {
    static void show(Matcher match, int val) {
        System.out.println(
                match.test(
                        IntStream.rangeClosed(1, 9)
                                .boxed()
                                //peek()表明在短路发生之前测试已经走了多远。从输出中可以看到短路计算行为。
                                .peek(n -&gt; System.out.format(&quot;%d &quot;, n)),
                        n -&gt; n &lt; val));
    }
    public static void main(String[] args) {
        show(Stream::allMatch, 10);
        show(Stream::allMatch, 4);
        show(Stream::anyMatch, 2);
        show(Stream::anyMatch, 0);
        show(Stream::noneMatch, 5);
        show(Stream::noneMatch, 0);
    }
}
/*
Output:1 2 3 4 5 6 7 8 9 true
1 2 3 4 false
1 true
1 2 3 4 5 6 7 8 9 false
1 false
1 2 3 4 5 6 7 8 9 true
*/
</code></pre>
<h3 id="1456选择一个元素">14.5.6	选择一个元素</h3>
<ul>
<li><code>findFirst()</code>：返回一个包含流中第一个元素的<code>Optional</code>，如果流中没有元素，则返回<code>Optional.empty</code>。</li>
<li><code>findAny()</code>：返回一个包含流中某个元素的<code>Optional</code>，如果流中没有元素，则返回<code>Optional.empty</code>。</li>
</ul>
<p>之前演示过了，不谈。</p>
<p><code>findFirst()</code>总是会选择流中的第一个元素，不管该流是否为并行的（即通过<code>parallel()</code>获得的流）。对于非并行的流，<code>findAny()</code>会选择第一个元素（尽管从定义来看，它可以选择任何一个元素）。在这个例子中，当这个流是并行流时，<code>findAny()</code>有可能选择第一个元素之外的其他元素。</p>
<p>如果必须选择某个流的最后一个元素，请使用<code>reduce()</code>：</p>
<pre><code class="language-java">package streams;

import java.util.Optional;
import java.util.OptionalInt;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/23
 * @description:
 */
public class LastElement {
    public static void main(String[] args) {
        //注意使用适当的数值化Optional类型
        OptionalInt last = IntStream.range(10, 20)
                //传入n1，n2，返回n2
                .reduce((n1, n2) -&gt; n2);
        System.out.println(last.orElse(-1));
        // 非数值对象：
        //这里使用了一个类型化的Optional
        Optional&lt;String&gt; lastobj =
                Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)
                        .reduce((n1, n2) -&gt; n2);
        System.out.println(
                lastobj.orElse(&quot;Nothing there!&quot;));
    }
}
/*
Output:19
three
*/
</code></pre>
<h3 id="1457获取流相关的信息">14.5.7	获取流相关的信息</h3>
<ul>
<li><code>count()</code>：获得流中元素的数量。</li>
<li><code>max(Comparator)</code>：通过<code>Comparator</code>确定这个流中的“最大”元素。</li>
<li><code>min(Comparator)</code>：通过<code>Comparator</code>确定这个流中的“最小”元素。</li>
</ul>
<p><code>String</code>有一个预定义的<code>Comparator</code>，可以简化我们的示例：</p>
<pre><code class="language-java">package streams;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/23
 * @description:
 */
public class Informational {
    public static void
    main(String[] args) throws Exception {
        System.out.println(
                FileToWords.stream(&quot;D:\\IDEAProjectSpace\\ONJava8Study\\OnJavaExample\\src\\streams\\Cheese.dat&quot;).count());
        System.out.println(
                FileToWords.stream(&quot;D:\\IDEAProjectSpace\\ONJava8Study\\OnJavaExample\\src\\streams\\Cheese.dat&quot;)
                        .min(String.CASE_INSENSITIVE_ORDER)
                        .orElse(&quot;NONE&quot;));
        System.out.println(
                FileToWords.stream(&quot;D:\\IDEAProjectSpace\\ONJava8Study\\OnJavaExample\\src\\streams\\Cheese.dat&quot;)
                        .max(String.CASE_INSENSITIVE_ORDER)
                        .orElse(&quot;NONE&quot;));
    }
}
/*
Output:
32
a
you
*/
</code></pre>
<h4 id="获得数值化流相关的信息">获得数值化流相关的信息</h4>
<ul>
<li><code>average()</code>：就是通常的意义，获得平均值。</li>
<li><code>max()</code>与<code>min()</code>：这些操作不需要一个<code>Comparator</code>，因为它们处理的是数值化流。</li>
<li><code>sum()</code>：将流中的数值累加起来。</li>
<li><code>summaryStatistics()</code>：返回可能有用的摘要数据。不太清楚为什么Java库的设计者觉得需要这个，因为我们自己可以用直接方法获得所有这些数据。</li>
</ul>
<pre><code class="language-java">package streams;

import static streams.RandInts.rands;

/**
 * Created with IntelliJ IDEA.
 *
 * @author: Caldarius
 * @date: 2023/1/23
 * @description:
 */
public class NumericStreamInfo {
    public static void main(String[] args) {
        System.out.println(rands().average().getAsDouble());
        System.out.println(rands().max().getAsInt());
        System.out.println(rands().min().getAsInt());
        System.out.println(rands().sum());
        System.out.println(rands().summaryStatistics());
    }
}
/*
Output:
527.17
997
1
52717
IntSummaryStatistics{count=100, sum=52717, min=1, average=527.170000, max=997}
*/
</code></pre>
<p>感觉有点累，小麻。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[19反射]]></title>
        <id>https://caldarius.github.io/post/19-reflection/</id>
        <link href="https://caldarius.github.io/post/19-reflection/">
        </link>
        <updated>2024-10-23T04:23:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>反射可以在程序运行时发现并使用对象的类型信息。</p>
</blockquote>
<p>反射使我们摆脱了只能在编译时执行面向类型操作的限制，并且让我们能够编写一些非常强大的程序。对反射的需要，揭示了面向对象设计中大量有趣（且复杂）的问题，并引发了我们对一些基本问题的思考，例如程序如何构建。</p>
<p>本章将讨论Java是如何在运行时发现对象和类的信息的。这通常有两种形式：简单反射，它假定你在编译时就已经知道了所有可用的类型；以及更复杂的反射，它允许我们在运行时发现和使用类的信息。</p>
<h2 id="191-为什么需要反射">19.1　为什么需要反射</h2>
<p>这里我们使用一个已经很熟悉的示例，它使用了多态并展示了类的层次结构。它的泛化类型是基类<code>Shape</code>，具体的子类型包括<code>Circle</code>、<code>Square</code>和<code>Triangle</code>（见图19-1）。<br>
<img src="https://caldarius.github.io//post-images/1729664938031.png" alt="" loading="lazy"><br>
这是一个典型的类层次结构图，基类在顶部，子类向下扩展。面向对象编程的一个基本目标就是，让编写的代码只操纵基类（本例中为<code>Shape</code>）的引用，因此如果你决定添加新类（例如继承了<code>Shape</code>的<code>Rhomboid</code>），大部分的代码不会受到影响。在这个例子中，<code>Shape</code>接口中的方法<code>draw()</code>是可以动态绑定的，因此客户程序员可以通过泛化的<code>Shape</code>引用来调用具体的<code>draw()</code>方法。在所有子类中，<code>draw()</code>都被重写，并且因为它是一个动态绑定的方法，即使通过泛化的<code>Shape</code>引用来调用它，也会产生正确的行为。这就是多态。</p>
<p>因此，通常来说你会创建一个特定的对象（<code>Circle</code>、<code>Square</code>或<code>Triangle</code>），将其向上转型为<code>Shape</code>（忽略对象的特定类型），这样就可以在后续的程序里一直使用这个<code>Shape</code>引用，而不需要知道其具体类型。</p>
<p>你可以像下面这样，对<code>Shape</code>的层次结构进行编程：</p>
<pre><code class="language-java">package reflection;

import java.util.stream.Stream;

/**
 * @author: Caldarius
 * @date: 2023/2/10
 * @description:
 */
abstract class Shape {
    void draw() {
        //这里看到 this + string，直接调this.toString()
        System.out.println(this + &quot;.draw()&quot;);
    }
    @Override
    public abstract String toString();
}
class Circle extends Shape {
    @Override public String toString() {
        return &quot;Circle&quot;;
    }
}
class Square extends Shape {
    @Override public String toString() {
        return &quot;Square&quot;;
    }
}

class Triangle extends Shape {
    @Override public String toString() {
        return &quot;Triangle&quot;;
    }
}





public class Shapes {
    public static void main(String[] args) {
        Stream.of(
                        new Circle(),
                        new Square(),
                        new Triangle())
                .forEach(Shape::draw);
    }
}
/*Output:
Circle.draw()
Square.draw()
Triangle.draw()
*/
</code></pre>
<p>基类里包含一个<code>draw()</code>方法，它通过将<code>this</code>传递给<code>System.out.println()</code>，间接地使用了<code>toString()</code>方法来显示类的标识符**（<code>toString()</code>方法被声明为<code>abstract</code>的，这样就可以强制子类重写该方法，并防止没什么内容的<code>Shape</code>类被实例化）。**如果一个对象出现在字符串拼接表达式中（该表达式需要包含<code>+</code>和<code>String</code>对象），这个对象的<code>toString()</code>方法就会被自动调用，来生成一个代表它自身的字符串。每个子类都重写了<code>toString()</code>方法（从<code>Object</code>继承而来），所以<code>draw()</code>最终（多态地）在不同的情况下打印出了不同的内容。</p>
<p>在此示例中，将一个<code>Shape</code>的子类对象放入<code>Stream&lt;Shape&gt;</code>时，会发生隐式的向上转型。在向上转型为<code>Shape</code>时，这个对象的<strong>确切类型信息</strong>就丢失了。对于流来说，它们只是<code>Shape</code>类的对象。</p>
<p>从技术上讲，<code>Stream&lt;Shape&gt;</code>实际上将所有内容都当作<code>Object</code>保存。<strong>当一个元素被取出时，它会自动转回<code>Shape</code>。这是反射最基本的形式，在运行时检查了所有的类型转换是否正确。这就是反射的意思：在运行时，确定对象的类型。</strong></p>
<p>在这里，反射类型转换并不彻底：<code>Object</code>只是被转换成了<code>Shape</code>，而没有转换为最终的<code>Circle</code>、<code>Square</code>或<code>Triangle</code>。这是因为我们所能得到的信息就是，<code>Stream&lt;Shape&gt;</code>里保存的都是<code>Shape</code>。在编译时，这是由<code>Stream</code>和Java泛型系统强制保证的，而在运行时，类型转换操作会确保这一点。</p>
<p>接下来就该多态上场了，<code>Shape</code>对象实际上执行的代码，取决于引用是属于<code>Circle</code>、<code>Square</code>还是<code>Triangle</code>。一般来说，这是合理的：**你希望自己的代码尽可能少地知道对象的确切类型信息，而只和这类对象的通用表示（在本例中为<code>Shape</code>）打交道。**这样的话，我们的代码就更易于编写、阅读和维护，并且设计也更易于实现、理解和更改。所以多态是面向对象编程的一个基本目标。</p>
<p>但是，假设你遇到了一个特殊的编程问题，只要知道这个泛化引用的确切类型，就可以很容易地解决，这样的话你又该怎么办呢？例如，假设我们允许用户可以将某种特定类型的所有形状都标记为一种特殊的颜色，以突出显示它们。这样，用户就可以找到屏幕上所有突出显示的三角形。或者，你的方法需要“旋转”一系列的形状，但旋转圆形是没有意义的，因此你想跳过圆形。<strong>通过反射，你可以查询到某个<code>Shape</code>引用所指的确切类型，从而选择并隔离特殊情况。</strong></p>
<h2 id="192-class对象">19.2　<code>Class</code>对象</h2>
<p>要想了解Java中的反射是如何工作的，就必须先了解类型信息在运行时是如何表示的。这项工作是通过叫作**<code>Class</code>对象**的特殊对象来完成的，它包含了与类相关的信息。事实上，<code>Class</code>对象被用来创建类的所有“常规”对象。Java使用<code>Class</code>对象执行反射，即使是类型转换这样的操作也一样。<code>Class</code>类还有许多其他使用反射的方式。</p>
<p>程序中的每个类都有一个<code>Class</code>对象。也就是说，每次编写并编译一个新类时，都会生成一个<code>Class</code>对象（并被相应地存储在同名的.class文件中）。为了生成这个对象，Java虚拟机（JVM）使用被称为<strong>类加载器</strong>（class loader）的子系统。</p>
<p>类加载器子系统实际上可以包含一条类加载器链，但里面只会有一个原始类加载器(即启动类加载器)，它是JVM实现的一部分。原始类加载器通常从本地磁盘加载所谓的<strong>可信类</strong>，包括Java API类。通常来说我们不需要加载器链中的额外加载器，但对于特殊需要（例如以某种方式加载类以支持Web服务器应用程序，或通过网络来下载类），你可以引入额外的类加载器来实现。</p>
<p>类在首次使用时才会被动态加载到JVM中。当程序第一次引用该类的静态成员时，就会触发这个类的加载。构造器是类的一个静态方法，尽管没有明确使用<code>static</code>关键字。因此，使用<code>new</code>操作符创建类的新对象也算作对该类静态成员的引用，构造器的初次使用会导致该类的加载。</p>
<p>所以，Java程序在运行前并不会被完全加载，而是在必要时加载对应的部分。这与许多传统语言不同。这种动态加载能力使得Java可以支持很多行为，而它们在静态加载语言（如 C++）中很难复制，或根本不可能复制。</p>
<p>类加载器首先检查是否加载了该类型的<code>Class</code>对象。如果没有，默认的类加载器会定位到具有该名称的.class文件（例如，某个附加类加载器可能会在数据库中查找对应的字节码）。当该类的字节数据被加载时，它们会被<strong>验证</strong>，以确保没有被损坏，并且不包含恶意的Java代码（这是Java的众多安全防线里的一条）。</p>
<p>一旦该类型的<code>Class</code>对象加载到内存中，它就会用于创建该类型的所有对象。下面这个程序可以证明这一点：</p>
<pre><code class="language-java">package reflection;


/**
 * @author: Caldarius
 * @date: 2023/2/10
 * @description:
 */
class Cookie {
    static { System.out.println(&quot;Loading Cookie&quot;); }
}

class Gum {
    static { System.out.println(&quot;Loading Gum&quot;); }
}

class Candy {
    static { System.out.println(&quot;Loading Candy&quot;); }
}

public class SweetShop {
    public static void main(String[] args) {
        System.out.println(&quot;inside main&quot;);
        new Candy();
        System.out.println(&quot;After creating Candy&quot;);
        try {
            Class.forName(&quot;Gum&quot;);
        } catch(ClassNotFoundException e) {
            System.out.println(&quot;Couldn't find Gum&quot;);
        }
        System.out.println(&quot;After Class.forName(\&quot;Gum\&quot;)&quot;);
        new Cookie();
        System.out.println(&quot;After creating Cookie&quot;);
    }
}
/*
Output:
inside main
Loading Candy
After creating Candy
Couldn't find Gum
After Class.forName(&quot;Gum&quot;)
Loading Cookie
After creating Cookie
*/
</code></pre>
<p><code>Candy</code>、<code>Gum</code>和<code>Cookie</code>这三个类都有一个静态代码块，该静态代码块在类第一次加载时执行。输出的信息会告诉我们这个类是什么时候加载的。在<code>main()</code>方法中，对象的创建被置于打印语句之间，以方便我们判断类加载的时间。</p>
<p>输出结果显示了<code>Class</code>对象仅在需要时才加载，并且静态代码块的初始化是在类加载时执行的。</p>
<p>下面这一行代码特别有趣：</p>
<pre><code class="language-java">Class.forName(&quot;Gum&quot;);
</code></pre>
<p>所有的<code>Class</code>对象都属于<code>Class</code>类。<code>Class</code>对象和其他对象一样，因此你可以获取并操作它的引用（这也是加载器所做的）。静态的<code>forName()</code>方法可以获得<code>Class</code>对象的引用，该方法接收了一个包含所需类的文本名称（注意拼写和大小写！）的字符串，并返回了一个<code>Class</code>引用，上面示例中的返回值被忽略；**我们对<code>forName()</code>的调用只是为了它的副作用：如果类<code>Gum</code>尚未加载，则加载它。**在加载过程中，会执行<code>Gum</code>的静态代码块。</p>
<p>在前面的例子中，如果<code>Class.forName()</code>因为找不到试图加载的类而失败，它会抛出一个<code>ClassNotFoundException</code>。在这里，我们只是简单地报告了问题并继续执行，但在更复杂的程序中，你可能会尝试在异常处理流程中修复这个问题（在进阶卷第8章中有个示例）。</p>
<p><strong>注意，传递给forName()的字符串参数必须是类的完全限定名称（包括包名称）。</strong></p>
<p>**不管什么时候，只要在运行时用到类型信息，就必须首先获得相应的<code>Class</code>对象的引用。**这时<code>Class.forName()</code>方法用起来就很方便了，因为不需要对应类型的对象就能获取<code>Class</code>引用。但是，如果已经有了一个你想要的类型的对象，就可以通过<code>getClass()</code>方法来获取<code>Class</code>引用，这个方法属于<code>Object</code>根类。它返回的<code>Class</code>引用表示了这个对象的实际类型。<code>Class</code>类有很多方法，下面是其中的一部分：</p>
<pre><code class="language-java">package reflection.toys;

/**
 * @author: Caldarius
 * @date: 2023/2/10
 * @description:
 */
interface HasBatteries {}
interface Waterproof {}
interface Shoots {}

class Toy {
    // 可以将下面这个无参构造器注释掉来看一下NoSuchMethodError
    public Toy() {}
    public Toy(int i) {}
}
//FancyToy继承了类Toy并实现了接口HasBatteries、Waterproof和Shoots。
class FancyToy extends Toy
        implements HasBatteries, Waterproof, Shoots {
    public FancyToy() { super(1); }
}

public class ToyTest {
    //printInfo()方法使用getName()来生成完全限定的类名
    static void printInfo(Class cc) {
        //isInterface()可以告诉你这个Class对象是否表示一个接口
        System.out.println(&quot;Class name: &quot; + cc.getName() +
                &quot; is interface? [&quot; + cc.isInterface() + &quot;]&quot;);
        //使用getSimpleName()和getCanonicalName()分别生成不带包的名称和完全限定的名称。
        System.out.println(
                &quot;Simple name: &quot; + cc.getSimpleName());
        System.out.println(
                &quot;Canonical name : &quot; + cc.getCanonicalName());
    }
    @SuppressWarnings(&quot;deprecation&quot;)
    public static void main(String[] args) {
        Class c = null;
        try {
            //注意，传递给forName()的字符串参数必须是类的完全限定名称（包括包名称）。
            c = Class.forName(&quot;reflection.toys.FancyToy&quot;);
        } catch(ClassNotFoundException e) {
            System.out.println(&quot;Can't find FancyToy&quot;);
            System.exit(1);
        }
        printInfo(c);
        //在main()中调用的Class.getInterfaces()方法返回了一个Class对象数组，它们表示你感兴趣的这个Class对象的所有接口。
        for(Class face : c.getInterfaces())
            printInfo(face);
        //还可以使用getSuperclass()来查询Class对象的直接基类。它将返回一个Class引用，而你可以对它做进一步查询。这样你就可以在运行时获取一个对象的完整类层次结构。
        Class up = c.getSuperclass();
        Object obj = null;
        try {
            //Class的newInstance()方法是实现“虚拟构造器”的一种途径，这相当于声明“我不知道你的确切类型，但无论如何你都要正确地创建自己”。在前面的例子中，up只是一个Class引用，它在编译时没有更多的类型信息。当创建一个新实例时，你会得到一个Object引用。但该引用指向了一个Toy对象。你可以给它发送Object能接收的消息，但如果想要发送除此之外的其他消息，就必须进一步了解它，并进行某种类型转换。此外，使用Class.newInstance()创建的类必须有一个public的无参构造器。在本章后面，你将看到如何通过Java反射API，使用任意构造器来动态创建类的对象。
            //注意，此示例中的newInstance()在Java 8中还是正常的，但在更高版本中已被弃用，Java推荐使用Constructor.newInstance()来代替。示例中我们使用了@SuppressWarnings(&quot;deprecation&quot;)来抑制那些更高版本的弃用警告。
            obj = up.newInstance();
        } catch(Exception e) {
            throw new
                    RuntimeException(&quot;Cannot instantiate&quot;);
        }
        printInfo(obj.getClass());
    }
}
/*
Output:
Class name: reflection.toys.FancyToy is interface? [false]
Simple name: FancyToy
Canonical name : reflection.toys.FancyToy
Class name: reflection.toys.HasBatteries is interface? [true]
Simple name: HasBatteries
Canonical name : reflection.toys.HasBatteries
Class name: reflection.toys.Waterproof is interface? [true]
Simple name: Waterproof
Canonical name : reflection.toys.Waterproof
Class name: reflection.toys.Shoots is interface? [true]
Simple name: Shoots
Canonical name : reflection.toys.Shoots
Class name: reflection.toys.Toy is interface? [false]
Simple name: Toy
Canonical name : reflection.toys.Toy
*/
</code></pre>
<h3 id="1921-类字面量">19.2.1　类字面量</h3>
<p>Java还提供了另一种方式来生成<code>Class</code>对象的引用：<strong>类字面量</strong>（class literal）。对前面的程序而言，它看起来像这样：</p>
<pre><code class="language-java">FancyToy.class;
</code></pre>
<p>这更简单也更安全，因为它会进行编译时检查（因此不必放在<code>try</code>块中）。另外它还消除了对<code>forName()</code>方法的调用，所以效率也更高。</p>
<blockquote>
<p>类字面量适用于常规类以及接口、数组和基本类型。</p>
<p>此外，每个基本包装类都有一个名为<code>TYPE</code>的标准字段。<code>TYPE</code>字段表示一个指向和基本类型对应的<code>Class</code>对象的引用。</p>
</blockquote>
<p>上面的意思并不是说包装类不能用 <code>.class</code>，而是说包装类<code>.TYPE</code>会获取到一个指向基本类型的<code>Class</code>对象的引用。简单的例子：</p>
<pre><code class="language-java">package reflection;

/**
 * @author: Caldarius
 * @date: 2023/2/13
 * @description:
 */
public class BasicPackingClass {
    public static void main(String[] args) {
        System.out.println(Integer.class.getSimpleName());
        System.out.println(Integer.TYPE);
    }
}
/*
Output:
Integer
int
*/
</code></pre>
<p>如表19-1所示。</p>
<p><strong>表19-1</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">类字面量</th>
<th style="text-align:left">等价于</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>boolean.class</code></td>
<td style="text-align:left"><code>Boolean.TYPE</code></td>
</tr>
<tr>
<td style="text-align:left"><code>char.class</code></td>
<td style="text-align:left"><code>Character.TYPE</code></td>
</tr>
<tr>
<td style="text-align:left"><code>byte.class</code></td>
<td style="text-align:left"><code>Byte.TYPE</code></td>
</tr>
<tr>
<td style="text-align:left"><code>short.class</code></td>
<td style="text-align:left"><code>Short.TYPE</code></td>
</tr>
<tr>
<td style="text-align:left"><code>int.class</code></td>
<td style="text-align:left"><code>Integer.TYPE</code></td>
</tr>
<tr>
<td style="text-align:left"><code>long.class</code></td>
<td style="text-align:left"><code>Long.TYPE</code></td>
</tr>
<tr>
<td style="text-align:left"><code>float.class</code></td>
<td style="text-align:left"><code>Float.TYPE</code></td>
</tr>
<tr>
<td style="text-align:left"><code>double.class</code></td>
<td style="text-align:left"><code>Double.TYPE</code></td>
</tr>
<tr>
<td style="text-align:left"><code>void.class</code></td>
<td style="text-align:left"><code>Void.TYPE</code></td>
</tr>
</tbody>
</table>
<p>我建议尽可能用“<code>.class</code>”的形式，因为它与常规类更一致。</p>
<p>请注意，使用“<code>.class</code>”的形式创建<code>Class</code>对象的引用时，该<code>Class</code>对象不会自动初始化。实际上，在使用一个类之前，需要先执行以下3个步骤。</p>
<ol>
<li><strong>加载</strong>。这是由类加载器执行的。该步骤会先找到字节码（通常在类路径中的磁盘上，但也不一定），然后从这些字节码中创建一个<code>Class</code>对象。</li>
<li><strong>链接</strong>。链接阶段会验证类中的字节码，为静态字段分配存储空间，并在必要时解析该类对其他类的所有引用。</li>
<li><strong>初始化</strong>。如果有基类的话，会先初始化基类，执行静态初始化器和静态初始化块。</li>
</ol>
<p>初始化被延迟到首次引用静态方法（构造器是隐式静态的）或非常量静态字段时：</p>
<pre><code class="language-java">package reflection;

import java.util.Random;

/**
 * @author: Caldarius
 * @date: 2023/2/10
 * @description:
 */
class Initable {
    static final int STATIC_FINAL = 47;
    static final int STATIC_FINAL2 =
            ClassInitialization.rand.nextInt(1000);
    static {
        System.out.println(&quot;Initializing Initable&quot;);
    }
}

class Initable2 {
    static int staticNonFinal = 147;
    static {
        System.out.println(&quot;Initializing Initable2&quot;);
    }
}

class Initable3 {
    static int staticNonFinal = 74;
    static {
        System.out.println(&quot;Initializing Initable3&quot;);
    }
}
public class ClassInitialization {

    public static Random rand = new Random(47);
    public static void
    main(String[] args) throws Exception {
        // 不会触发初始化
        Class initable = Initable.class;
        System.out.println(&quot;After creating Initable ref&quot;);
        // 不会触发初始化。如果一个static final字段的值是“编译时常量”，比如Initable.staticFinal，那么这个值不需要初始化Initable类就能读取。
        System.out.println(Initable.STATIC_FINAL);
        // 触发初始化。但是把一个字段设置为static和final并不能保证这种行为：对Initable.staticFinal2的访问会强制执行类的初始化，因为它不是编译时常量。
        System.out.println(Initable.STATIC_FINAL2);
        // 触发初始化
        System.out.println(Initable2.staticNonFinal);
        Class initable3 = Class.forName(&quot;reflection.Initable3&quot;);
        System.out.println(&quot;After creating Initable3 ref&quot;);
        System.out.println(Initable3.staticNonFinal);
    }
}
/*
Output:
After creating Initable ref
47
Initializing Initable
258
Initializing Initable2
147
Initializing Initable3
After creating Initable3 ref
74
*/
</code></pre>
<p>实际上，初始化会“尽可能懒惰”。从<code>initable</code>引用的创建过程中可以看出，仅使用<code>.class</code>语法来获取对类的引用不会导致初始化。而<code>Class.forName()</code>会立即初始化类以产生<code>Class</code>引用，如<code>initable3</code>的创建所示。</p>
<p>如果一个<code>static final</code>字段的值是“编译时常量”，比如<code>Initable.staticFinal</code>，那么这个值不需要初始化<code>Initable</code>类就能读取。但是把一个字段设置为<code>static</code>和<code>final</code>并不能保证这种行为：对<code>Initable.staticFinal2</code>的访问会强制执行类的初始化，因为它不是编译时常量。</p>
<p>如果<code>static</code>字段不是<code>final</code>的，那么访问它时，如果想要正常读取，总是需要先进行链接（为字段分配存储）和初始化（初始化该存储），正如在对<code>Initable2.staticNonFinal</code>的访问中看到的那样。</p>
<h3 id="1922-泛型类的引用">19.2.2　泛型类的引用</h3>
<p><code>Class</code>引用指向的是一个<code>Class</code>对象，该对象可以生成类的实例，并包含了这些实例所有方法的代码。它还包含该类的静态字段和静态方法。所以一个<code>Class</code>引用表示的就是它所指向的确切类型：<code>Class</code>类的一个对象。</p>
<p>你可以使用泛型语法来限制<code>Class</code>引用的类型。在下面的示例中，这两种语法都是正确的：</p>
<pre><code class="language-java">Class intClass = int.class;
intClass = double.class;

Class&lt;Integer&gt; genericIntClass = int.class;
genericIntClass = Integer.class; // 一样
// genericIntClass = double.class; // 不合法
</code></pre>
<p><code>intClass</code>可以重新赋值为任何其他的<code>Class</code>对象，例如<code>double.class</code>，而不会产生警告。泛化的类引用<code>genericIntClass</code>只能分配给其声明的类型。通过使用泛型语法，可以让编译器强制执行额外的类型检查。</p>
<p>如果你想稍微放松一下这种限制，那该怎么办？乍一看，好像可以执行下面这样的操作：</p>
<pre><code class="language-java">Class&lt;Number&gt; genericNumberClass = int.class;
</code></pre>
<p>这似乎是有道理的，因为<code>Integer</code>继承了<code>Number</code>。但实际上这段代码无法运行，因为<code>Integer</code>的<code>Class</code>对象不是<code>Number</code>的<code>Class</code>对象的子类（这里的区别看起来好像很微妙，我们将在第20章对此进行深入讨论）。</p>
<p>要想放松使用泛化的<code>Class</code>引用时的限制，请使用通配符<code>?</code>，它是Java泛型的一部分，表示“任何事物”。所以我们可以在上面的例子中为普通的<code>Class</code>引用加上通配符，这样就可以产生相同的结果：</p>
<pre><code class="language-java">Class&lt;?&gt; intClass = int.class;
    intClass = double.class;
</code></pre>
<p>尽管如我们看到的那样，普通的<code>Class</code>并不会产生编译器警告，但是和普通的<code>Class</code>相比，我们还是倾向于<code>Class&lt;?&gt;</code>，即使它们是等价的。<code>Class&lt;?&gt;</code>的好处在于，它表明了你不是偶然或无意识地使用了非具体的类引用。你就是选择了这个非具体的版本。</p>
<p>如果想创建一个<code>Class</code>引用，并将其限制为某个类型或<strong>任意子类型</strong>，可以将通配符与<code>extends</code>关键字组合来创建一个<strong>界限</strong>（bound）。因此，与其使用<code>Class&lt;Number&gt;</code>，不如像下面这样做：</p>
<pre><code class="language-java">Class&lt;? extends Number&gt; bounded = int.class;
    bounded = double.class;
    bounded = Number.class;
    // 或者任何继承了Number的类
</code></pre>
<p>将泛型语法添加到<code>Class</code>引用的一个原因是提供编译时的类型检查。这样的话，如果你做错了什么，那么很快就能发现。使用普通的<code>Class</code>引用时，你可能确实不会误入歧途，但是如果你犯了一个错误，直到运行时才发现，那就可能会给你带来不便，甚至导致问题。</p>
<p>下面是一个使用了泛型类语法的示例。它存储了一个类引用，然后使用<code>newInstance()</code>来生成对象：</p>
<pre><code class="language-java">package reflection;

import java.util.function.Supplier;
import java.util.stream.Stream;

/**
 * @author: Caldarius
 * @date: 2023/2/10
 * @description:
 */
class ID {
    //这个字段用于计数；
    private static long counter;
    //用于标记this是第几个id；
    private final long id = counter++;
    @Override public String toString() {
        return &quot;ID&quot; + Long.toString(id);
    }
    // 如果想要调用getConstructor().newInstance()，就需要提供一个public的无参构造器：ID自动生成的无参构造器不是public的，因为ID类不是public的，所以我们必须显式定义它。
    public ID() {}
}
public class DynamicSupplier&lt;T&gt; implements Supplier&lt;T&gt; {
    //标记这个DynamicSupplier对象实际上会生成什么类型的对象组，实际上是final，因为没有提供set方法；
    private Class&lt;T&gt; type;
    public DynamicSupplier(Class&lt;T&gt; type) {
        this.type = type;
    }
    @Override
    public T get() {
        try {
            //调用newInstance()方法创建对应类型的对象；
            return type.getConstructor().newInstance();
        } catch(Exception e) {
            throw new RuntimeException(e);
        }
    }
    public static void main(String[] args) {
        Stream.generate(
                //传入需要生成的对象的类型
                        new DynamicSupplier&lt;&gt;(ID.class))
                .skip(10)
                .limit(5)
                .forEach(System.out::println);
    }
}
/*
Output:
10
11
12
13
14
*/
</code></pre>
<p>对<code>Class</code>对象使用泛型语法时，<code>newInstance()</code>会返回对象的确切类型，而不仅仅是简单的<code>Object</code>，就像在ToyTest.java示例中看到的那样。但它也会受到一些限制：</p>
<pre><code class="language-java">//class FancyToy extends Toy
Class&lt;FancyToy&gt; ftc = FancyToy.class;
// 生成确切的类型：
FancyToy fancyToy =
  ftc.getConstructor().newInstance();
//up可以是FancyToy及其任意父类型
Class&lt;? super FancyToy&gt; up = ftc.getSuperclass();
// 下面的代码无法通过编译：
// Class&lt;Toy&gt; up2 = ftc.getSuperclass();
// 只能生成Object
Object obj = up.getConstructor().newInstance();
</code></pre>
<blockquote>
<p>如果你得到了基类，那么编译器只允许你声明这个基类引用是“<code>FancyToy</code>的某个基类”，就像表达式<code>Class&lt;? super FancyToy&gt;</code>所声明的那样。它不能被声明为<code>Class&lt;Toy&gt;</code>。这看起来有点儿奇怪，因为<code>getSuperclass()</code>返回了<strong>基类</strong>（不是接口），而编译器在编译时就知道这个基类是什么——在这里就是<code>Toy.class</code>，而不仅仅是“<code>FancyToy</code>的某个基类”。不管怎么样，因为存在这种模糊性，所以<code>up.getConstructor().newInstance()</code>的返回值不是一个确切的类型，而只是一个<code>Object</code>。</p>
</blockquote>
<p>也就是说，虽然我知道这个基类是Toy，但是返回的类型只能是“某个基类”，而不能是确定的某个类。所以<code>getConstructor().newInstance()</code>的返回值不是一个确切的类型，而只是一个<code>Object</code>。</p>
<h3 id="1923-cast方法">19.2.3　<code>cast()</code>方法</h3>
<p>还有一个用于<code>Class</code>引用的类型转换语法，即<code>cast()</code>方法：</p>
<pre><code class="language-java">class Building {}
class House extends Building {}

public class ClassCasts {
  public static void main(String[] args) {
    Building b = new House();
    Class&lt;House&gt; houseType = House.class;
    //在这里将Building转换为了House
    House h = houseType.cast(b);
    // 或者直接这样进行转型
    h = (House)b; 
  }
}
</code></pre>
<p><code>cast()</code>方法接收参数对象并将其转换为<code>Class</code>引用的类型。但是，如果观察上面的代码，你会发现，与完成了相同工作的<code>main()</code>的最后一行相比，这种方式似乎做了很多额外的工作。</p>
<p><code>cast()</code>在你不能使用普通类型转换的情况下很有用。如果你正在编写泛型代码（你将在第20章中学习），并且存储了一个用于转型的<code>Class</code>引用，就可能会遇到这种情况。不过这很罕见——我发现在整个Java库中只有一个地方使用了<code>cast()</code>（也就是在<code>com.sun.mirror.util.DeclarationFilter</code>中）。</p>
<p>另一个在Java库中没有使用到的特性是<code>Class.asSubclass()</code>。它会将类对象转换为更具体的类型。</p>
<h2 id="193-转型前检查">19.3　转型前检查</h2>
<p>到目前为止，你已经学习了以下内容。</p>
<ol>
<li>传统的类型转换。比如“<code>(Shape)</code>”，它使用反射来确保转型是正确的。如果你执行了错误的转型，它会抛出一个<code>ClassCastException</code>。</li>
<li>代表对象类型的<code>Class</code>对象。你可以查询<code>Class</code>对象来获取有用的运行时信息。</li>
</ol>
<p>在C++中，传统的类型转换“<code>(Shape)</code>”并<strong>不</strong>执行反射[在C++中，这称为<strong>运行时类型识别</strong>（RTTI）]。它只是告诉编译器将对象视为新类型。在Java中，它的确会执行类型检查，这种转型通常称为“类型安全向下转型”（type-safe downcast）。之所以会有术语“向下转型”，是因为类层次结构图从来就是这么排列的。如果将<code>Circle</code>转型为<code>Shape</code>是向上转型，那么将<code>Shape</code>转型为<code>Circle</code>就是向下转型。不过，编译器知道一个<code>Circle</code>也是一个<code>Shape</code>，所以它允许自由地做向上转型的赋值操作，而不需要任何额外的语法。但编译器<strong>无法知道</strong>一个给定的<code>Shape</code>实际上是什么——它可能就是一个<code>Shape</code>，也可能是<code>Shape</code>的子类型，例如<code>Circle</code>、<code>Square</code>、<code>Triangle</code>或其他类型。在编译时，编译器只知道这是一个<code>Shape</code>。<strong>因此，如果不使用显式的类型转换来告诉编译器这是一个特定的类型，编译器就不会允许执行向下转型赋值操作（编译器会检查该向下转型操作是否合理，因此它不会让你向下转型为实际上不是其子类的类型）。</strong></p>
<p>Java中还有第三种形式的反射。这就是关键字<code>instanceof</code>，它返回一个<code>boolean</code>值，表明一个对象是否是特定类型的实例。因此你可以像下面这样，以问题的形式来使用它：</p>
<pre><code class="language-java">if(x instanceof Dog)
  ((Dog)x).bark();
</code></pre>
<p>在将<code>x</code>转换为<code>Dog</code><strong>之前</strong>，你可以用<code>if</code>语句检查一下对象<code>x</code>是否属于类<code>Dog</code>。当没有其他信息可以告诉你对象类型的时候，在向下转型之前使用<code>instanceof</code>很重要。否则，你会得到一个<code>ClassCastException</code>。</p>
<p>通常，即使只想寻找确切的类型（例如可以变成紫色的三角形），你也可以使用<code>instanceof</code>来轻松识别<strong>所有</strong>的对象。例如，假设有一系列描述<code>Pet</code>的类（以及它们的主人，这个特性在后面的例子中会派上用场）。层次结构中的每个<code>Individual</code>都有一个<code>id</code>和一个可选的名称。虽然以下类都继承自<code>Individual</code>，但<code>Individual</code>类比较复杂，因此在进阶卷附录C中进行了说明和解释。</p>
<p>这里其实没必要看<code>Individual</code>的代码——只需要知道你可以创建它的具名或不具名的对象就可以了，而且每个<code>Individual</code>都有一个<code>id()</code>方法来返回其唯一标识符（通过计算生成对象的个数获得）。还有一个<code>toString()</code>方法——如果你没有为<code>Individual</code>提供一个名字，<code>toString()</code>就会生成简单的类型名称。</p>
<p>下面是继承自<code>Individual</code>的类层次结构：</p>
<p>接下来，我们需要一种方法来随机地创建<code>Pet</code>对象。为了使这个工具有不同的实现，我们将它定义为一个抽象类：</p>
<pre><code class="language-java">package reflection.pets;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * @author: Caldarius
 * @date: 2023/2/13
 * @description:
 */
public abstract class Creator implements Supplier&lt;Pet&gt; {
    private Random rand = new Random(34);
    //创建不同类型的Pet；
    //抽象的types()方法需要在Creator的子类里实现，以生成一个包含了Class对象的List。这是模板方法（Template Method）设计模式的一个例子。注意，List的泛型参数被指定为“继承了Pet的任意子类”，因此newInstance()无须类型转换即可生成一个Pet。
    public abstract List&lt;Class&lt;? extends Pet&gt;&gt; types();

    //get()会查找List的索引来生成一个Class对象。getConstructor()会生成一个Constructor对象，而newInstance()使用该Constructor来创建一个对象。
    @Override
    public Pet get() {
        int n = rand.nextInt(types().size());
        try {
            return types().get(n)
                    .getConstructor().newInstance();
        //调用newInstance()时可能会得到四种异常。你可以在try块后面的catch子句里看到对它们的处理。这些异常的名称本身很好地解释了它们所代表的错误内容（IllegalAccessException表示违反了Java的安全机制，在本例中，如果无参构造器是private的，就会抛出这种异常）。
        } catch(InstantiationException |
                NoSuchMethodException |
                InvocationTargetException |
                IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }
    public Stream&lt;Pet&gt; stream() {
        return Stream.generate(this);
    }
    public Pet[] array(int size) {
        return stream().limit(size).toArray(Pet[]::new);
    }
    public List&lt;Pet&gt; list(int size) {
        return stream().limit(size)
                .collect(Collectors.toCollection(ArrayList::new));
    }
}
</code></pre>
<p>在实现<code>Creator</code>的子类时，必须提供一个<code>Pet</code>类型的<code>List</code>，这样才可以调用<code>get()</code>方法来获取<code>Pet</code>对象。<code>types()</code>方法一般来说只需要返回一个静态<code>List</code>的引用就可以了。下面是一个使用<code>forName()</code>实现的示例：</p>
<pre><code class="language-java">package reflection.pets;

import java.util.ArrayList;
import java.util.List;

/**
 * @author: Caldarius
 * @date: 2023/2/13
 * @description:
 */
public class ForNamePetCreator extends Creator{
    private static List&lt;Class&lt;? extends Pet&gt;&gt; types =
            new ArrayList&lt;&gt;();
    // 你想随机生成的类型：
    private static String[] typeNames = {
            &quot;reflection.pets.Mutt&quot;,
            &quot;reflection.pets.Pug&quot;,
            &quot;reflection.pets.EgyptianMau&quot;,
            &quot;reflection.pets.Manx&quot;,
            &quot;reflection.pets.Cymric&quot;,
            &quot;reflection.pets.Rat&quot;,
            &quot;reflection.pets.Mouse&quot;,
            &quot;reflection.pets.Hamster&quot;
    };
    //loader()方法使用Class.forName()来创建一个Class对象的列表，可能会抛出ClassNotFoundException。这是合理的，因为你传递给它的是一个在编译时无法验证的字符串。Pet对象在reflection包中，所以必须使用包名来引用这些类。
    @SuppressWarnings(&quot;unchecked&quot;)
    private static void loader() {
        try {
            for(String name : typeNames)
                types.add(
                        //这里经行了强制类型转换，会产生编译时警告
                        (Class&lt;? extends Pet&gt;)Class.forName(name));
        } catch(ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
    }
    //要生成具有实际类型的Class对象的列表，就需要进行强制类型转换，这会产生编译时警告。我们单独定义了loader()方法，然后在静态初始化块中调用了它，这是因为@SuppressWarnings(&quot;unchecked&quot;)注解不能直接用于静态初始化块。
    static { loader(); }
    @Override public List&lt;Class&lt;? extends Pet&gt;&gt; types() {
        return types;
    }
}
</code></pre>
<p>如果想要知道<code>Pet</code>有多少，我们需要一个工具来跟踪各种不同类型的<code>Pet</code>的数量。此时采用<code>Map</code>就非常适合：键可以是<code>Pet</code>类型的名称，而值则是保存了<code>Pet</code>数量的<code>Integer</code>。这样，你可以查询“有多少个<code>Hamster</code>对象”，使用<code>instanceof</code>来获得对应<code>Pet</code>的数量：</p>
<pre><code class="language-java">package reflection.pets;

import java.util.HashMap;

/**
 * @author: Caldarius
 * @date: 2023/2/13
 * @description:
 */
public class PetCounter {
    //这个计数器通过继承完成了对HashMap的功能拓展。
    static class Counter extends HashMap&lt;String,Integer&gt; {
        public void count(String type) {
            Integer quantity = get(type);
            if(quantity == null)
                put(type, 1);
            else
                put(type, quantity + 1);
        }
    }
    private Counter counter = new Counter();
    private void countPet(Pet pet) {
        System.out.print(
                pet.getClass().getSimpleName() + &quot; &quot;);
        if(pet instanceof Pet)
            counter.count(&quot;Pet&quot;);
        if(pet instanceof Dog)
            counter.count(&quot;Dog&quot;);
        if(pet instanceof Mutt)
            counter.count(&quot;Mutt&quot;);
        if(pet instanceof Pug)
            counter.count(&quot;Pug&quot;);
        if(pet instanceof Cat)
            counter.count(&quot;Cat&quot;);
        if(pet instanceof EgyptianMau)
            counter.count(&quot;EgyptianMau&quot;);
        if(pet instanceof Manx)
            counter.count(&quot;Manx&quot;);
        if(pet instanceof Cymric)
            counter.count(&quot;Cymric&quot;);
        if(pet instanceof Rodent)
            counter.count(&quot;Rodent&quot;);
        if(pet instanceof Rat)
            counter.count(&quot;Rat&quot;);
        if(pet instanceof Mouse)
            counter.count(&quot;Mouse&quot;);
        if(pet instanceof Hamster)
            counter.count(&quot;Hamster&quot;);
    }
    public void count(Creator creator) {
        creator.stream().limit(20)
                .forEach(pet -&gt; countPet(pet));
        System.out.println();
        System.out.println(counter);
    }
    public static void main(String[] args) {
        new PetCounter().count(new ForNamePetCreator());
    }
}
/*
Output:
Rat Hamster EgyptianMau Rat Rat Mutt Mutt EgyptianMau Rat Rat Cymric EgyptianMau Rat Mutt Rat Mutt Hamster Rat Mouse Cymric
{EgyptianMau=3, Rat=8, Cymric=2, Mouse=1, Cat=5, Manx=2, Rodent=11, Mutt=4, Dog=4, Pet=20, Hamster=2}
*/
</code></pre>
<p>在<code>countPet()</code>中，我们使用<code>instanceof</code>来对数组里的每个<code>Pet</code>进行测试和计数。</p>
<p><code>instanceof</code>有一个相当严格的限制：只能将其与命名类型进行比较，而不能与一个<code>Class</code>对象进行比较。在前面的例子中，你可能认为像这样写一大堆的<code>instanceof</code>表达式很乏味，的确是这样的。但是如果你想创建一个<code>Class</code>对象数组，并将其与那些对象进行比较，从而将<code>instanceof</code>巧妙地自动化，这是不可能的（不过稍后你会看到另一个替代方案）。这个限制其实并不像你想象的那么严重，因为最终你会明白，如果代码里有许多的<code>instanceof</code>表达式，那么这个设计可能是存在缺陷的。</p>
<h3 id="1931-使用类字面量">19.3.1　使用类字面量</h3>
<p>如果我们使用类字面量重新实现<code>Creator</code>，那么最终结果在许多方面都会显得更清晰：</p>
<pre><code class="language-java">package reflection.pets;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * @author: Caldarius
 * @date: 2023/2/13
 * @description:
 */
public class PetCreator extends Creator{
    //这一次，types的创建代码并不需要放在try块里，因为它在编译时被检查，所以不会抛出任何异常，这和Class.forName()不一样。
    public static final List&lt;Class&lt;? extends Pet&gt;&gt; ALL_TYPES =
        Collections.unmodifiableList(Arrays.asList(
                Pet.class, Dog.class, Cat.class, Rodent.class,
                Mutt.class, Pug.class, EgyptianMau.class,
                Manx.class, Cymric.class, Rat.class,
                Mouse.class, Hamster.class));
    // 这里的types列表是ALL_TYPES（使用List.subList()创建）的一部分，它包含了确切的宠物类型，因此可以用来生成随机的Pet。
    //在即将出现的PetCounter3.java示例中，我们会预先加载一个包含所有Pet类型（不仅仅是那些随机生成的）的Map，因此这个ALL_TYPES的List是必要的
    private static final List&lt;Class&lt;? extends Pet&gt;&gt; TYPES =
            ALL_TYPES.subList(
                    ALL_TYPES.indexOf(Mutt.class),
                    ALL_TYPES.size());
    @Override
    public List&lt;Class&lt;? extends Pet&gt;&gt; types() {
        return TYPES;
    }
    public static void main(String[] args) {
        System.out.println(TYPES);
        List&lt;Pet&gt; pets = new PetCreator().list(7);
        System.out.println(pets);
        //测试PetCreator
        System.out.println(&quot;测试PetCreator&quot;);
        new PetCounter().count(new PetCreator());
    }
}
/*
Output:
[class reflection.pets.Mutt, class reflection.pets.Pug, class reflection.pets.EgyptianMau, class reflection.pets.Manx, class reflection.pets.Cymric, class reflection.pets.Rat, class reflection.pets.Mouse, class reflection.pets.Hamster]
[Rat, Hamster, EgyptianMau, Rat, Rat, Mutt, Mutt]
测试PetCreator
Rat Hamster EgyptianMau Rat Rat Mutt Mutt EgyptianMau Rat Rat Cymric EgyptianMau Rat Mutt Rat Mutt Hamster Rat Mouse Cymric 
{EgyptianMau=3, Rat=8, Cymric=2, Mouse=1, Cat=5, Manx=2, Rodent=11, Mutt=4, Dog=4, Pet=20, Hamster=2}
*/
</code></pre>
<h3 id="1932-动态的instanceof">19.3.2　动态的<code>instanceof</code></h3>
<p><code>Class.isInstance()</code>方法提供了一种动态验证对象类型的方式。因此，那些乏味的<code>instanceof</code>语句就都可以从PetCounter.java中删除了：</p>
<pre><code class="language-java">package reflection.pets;

import onjava.Pair;

import java.util.*;
import java.util.stream.*;

/**
 * @author: Caldarius
 * @date: 2023/2/13
 * @description:
 */
public class PetCounter3 {
    static class Counter extends
            HashMap&lt;Class&lt;? extends Pet&gt;, Integer&gt; {
        Counter() {
            super(PetCreator.ALL_TYPES.stream()
                    .map(type -&gt; Pair.make(type, 0))
                    .collect(
                            Collectors.toMap(Pair::key, Pair::value)));
        }
        public void count(Pet pet) {
            // Class.isInstance()消除了大量的instanceof：
            entrySet().stream()
                    .filter(pair -&gt; pair.getKey().isInstance(pet))
                    .forEach(pair -&gt;
                            put(pair.getKey(), pair.getValue() + 1));
        }
        @Override public String toString() {
            String result = entrySet().stream()
                    .map(pair -&gt; String.format(&quot;%s=%s&quot;,
                            pair.getKey().getSimpleName(),
                            pair.getValue()))
                    .collect(Collectors.joining(&quot;, &quot;));
            return &quot;{&quot; + result + &quot;}&quot;;
        }
    }
    public static void main(String[] args) {
        Counter petCount = new Counter();
        new PetCreator().stream()
                .limit(20)
                .peek(petCount::count)
                .forEach(p -&gt; System.out.print(
                        p.getClass().getSimpleName() + &quot; &quot;));
        System.out.println(&quot;\n&quot; + petCount);
    }
}
/*
Output:Rat Hamster EgyptianMau Rat Rat Mutt Mutt EgyptianMau Rat Rat Cymric EgyptianMau Rat Mutt Rat Mutt Hamster Rat Mouse Cymric
{Mutt=4, Manx=2, Dog=4, Rat=8, Cat=5, EgyptianMau=3, Rodent=11, Cymric=2, Hamster=2, Pet=20, Pug=0, Mouse=1}
*/
</code></pre>
<p>为了对所有不同类型的<code>Pet</code>进行计数，<code>Counter</code>继承了<code>HashMap</code>并预加载了<code>PetCreator.ALL_TYPES</code>里的类型。如果不预加载<code>Map</code>里的数据，你最终就只能对随机生成的类型进行计数，而不能包括诸如<code>Pet</code>和<code>Cat</code>这样的基类型。</p>
<p><code>isInstance()</code>方法使我们不再需要<code>instanceof</code>表达式。此外，这还意味着，如果想添加新的<code>Pet</code>类型，只需要更改<code>PetCreator.types</code>数组就可以，程序的其余部分不需要修改（但在使用<code>instanceof</code>表达式时就不可以）。</p>
<p>我们重写了<code>toString()</code>方法来提供更易于阅读的输出，该输出与打印<code>Map</code>时看到的典型输出相似。</p>
<h3 id="1933-递归计数">19.3.3　递归计数</h3>
<p><code>PetCounter3.Counter</code>中的<code>Map</code>预先加载了所有不同的<code>Pet</code>类。我们还可以使用<code>Class.isAssignableFrom()</code>方法代替<code>Map</code>的预加载，来创建一个并不仅限于对<code>Pet</code>进行计数的通用工具：</p>
<pre><code class="language-java">package onjava;

import java.util.HashMap;
import java.util.stream.Collectors;

/**
 * @author: Caldarius
 * @date: 2023/2/13
 * @description:
 */
public class TypeCounter extends HashMap&lt;Class&lt;?&gt;, Integer&gt; {
    private Class&lt;?&gt; baseType;
    public TypeCounter(Class&lt;?&gt; baseType) {
        this.baseType = baseType;
    }
    public void count(Object obj) {
        Class&lt;?&gt; type = obj.getClass();
        // isAssignableFrom()在运行时验证传递的对象实际上在不在我们希望的层次结构里。
        if(!baseType.isAssignableFrom(type))
            throw new RuntimeException(
                    obj + &quot; incorrect type: &quot; + type +
                            &quot;, should be type or subtype of &quot; + baseType);
        countClass(type);
    }
    //countClass()首先对这个确切的类型进行计数。然后，如果其基类可以赋值给baseType，则对基类进行递归调用countClass()。
    private void countClass(Class&lt;?&gt; type) {
        Integer quantity = get(type);
        put(type, quantity == null ? 1 : quantity + 1);
        Class&lt;?&gt; superClass = type.getSuperclass();
        if(superClass != null &amp;&amp;
                baseType.isAssignableFrom(superClass)) {
            countClass(superClass);
        }
    }
    @Override
    public String toString() {
        String result = entrySet().stream()
                .map(pair -&gt; String.format(&quot;%s=%s&quot;,
                        pair.getKey().getSimpleName(),
                        pair.getValue()))
                .collect(Collectors.joining(&quot;, &quot;));
        return &quot;{&quot; + result + &quot;}&quot;;
    }
}

</code></pre>
<p><code>count()</code>方法获取其参数的<code>Class</code>，并使用<code>isAssignableFrom()</code>在运行时验证传递的对象实际上在不在我们希望的层次结构里。<code>countClass()</code>首先对这个确切的类型进行计数。然后，如果其基类可以赋值给<code>baseType</code>，则对基类进行递归调用<code>countClass()</code>。</p>
<pre><code class="language-java">package reflection;

import onjava.TypeCounter;
import reflection.pets.Pet;
import reflection.pets.PetCreator;

/**
 * @author: Caldarius
 * @date: 2023/2/13
 * @description:
 */
public class PetCounter4 {
    public static void main(String[] args) {
        TypeCounter counter = new TypeCounter(Pet.class);
        new PetCreator().stream()
                .limit(20)
                .peek(counter::count)
                .forEach(p -&gt; System.out.print(
                        p.getClass().getSimpleName() + &quot; &quot;));
        System.out.println(&quot;\n&quot; + counter);
    }
}
/*
Output:
Rat Hamster EgyptianMau Rat Rat Mutt Mutt EgyptianMau Rat Rat Cymric EgyptianMau Rat Mutt Rat Mutt Hamster Rat Mouse Cymric 
{Mutt=4, Rat=8, Manx=2, Dog=4, Mouse=1, EgyptianMau=3, Hamster=2, Cat=5, Rodent=11, Pet=20, Cymric=2}
*/
</code></pre>
<h2 id="194-注册工厂">19.4　注册工厂</h2>
<p>通过<code>Pet</code>层次结构来生成对象存在一个问题，即每次向层次结构中添加新类型的<code>Pet</code>时，都必须记住将其添加到PetCreator.java的列表里。在一个要经常添加类的系统中，这可能会成为问题。</p>
<p>你可能会考虑为每个子类添加一个静态初始化器，这样初始化程序就可以将它的类添加到某个列表中。遗憾的是，静态初始化器只在类第一次加载时调用，所以你就碰上了一个“先有鸡还是先有蛋”的问题：生成器在它的列表中没有这个类，它永远不能创建这个类的对象，所以类不会被加载并放置在列表中。</p>
<p>基本上，你必须自己手动创建这个列表（除非你编写一个工具来搜索并分析源代码，然后创建和编译这个列表）。所以最佳的做法就是把这个列表放在一个靠近中心的、位置明显的地方。我们感兴趣的这个层次结构的基类可能就是最好的地方。</p>
<p>我们要做的另一处变更是使用<strong>工厂方法</strong>（Factory Method）设计模式来推迟对象的创建，将其交给类自己去完成。工厂方法可以被多态地调用，来创建恰当类型的对象。实际上，<code>java.util.function.Supplier</code>通过它的<code>T get()</code>方法提供了一个工厂方法的原型。<code>get()</code>方法可以通过协变返回类型为<code>Supplier</code>的不同子类返回对应的类型。</p>
<p>在此示例中，基类<code>Part</code>包含了一个工厂对象（<code>Supplier&lt;Part&gt;</code>）的静态<code>List</code>。对于本应该由<code>get()</code>方法生成的类型，它们的工厂类都被添加到了列表<code>prototypes</code>里，从而“注册”到了基类中。比较特别的一点是，这些工厂是对象本身的实例。这个列表中的每个对象都是用于创建其他对象的<strong>原型</strong>：</p>
<pre><code class="language-java">package reflection;

import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.function.Supplier;
import java.util.stream.Stream;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
class Part implements Supplier&lt;Part&gt; {
    @Override
    public String toString() {
        return getClass().getSimpleName();
    }
    static List&lt;Supplier&lt;? extends Part&gt;&gt; prototypes =
            Arrays.asList(
                    new FuelFilter(),
                    new AirFilter(),
                    new CabinAirFilter(),
                    new OilFilter(),
                    new FanBelt(),
                    new PowerSteeringBelt(),
                    new GeneratorBelt()
            );
    private static Random rand = new Random(47);
    @Override public Part get() {
        int n = rand.nextInt(prototypes.size());
        return prototypes.get(n).get();
    }
}
class Filter extends Part {}

class FuelFilter extends Filter {
    @Override
    public FuelFilter get() { return new FuelFilter(); }
}

class AirFilter extends Filter {
    @Override
    public AirFilter get() { return new AirFilter(); }
}

class CabinAirFilter extends Filter {
    @Override
    public CabinAirFilter get() {
        return new CabinAirFilter();
    }
}

class OilFilter extends Filter {
    @Override
    public OilFilter get() { return new OilFilter(); }
}

class Belt extends Part {}

class FanBelt extends Belt {
    @Override
    public FanBelt get() { return new FanBelt(); }
}

class GeneratorBelt extends Belt {
    @Override public GeneratorBelt get() {
        return new GeneratorBelt();
    }
}

class PowerSteeringBelt extends Belt {
    @Override public PowerSteeringBelt get() {
        return new PowerSteeringBelt();
    }
}
public class RegisteredFactories{
    public static void main(String[] args) {
        Stream.generate(new Part())
                .limit(10)
                .forEach(System.out::println);
    }
}
/*
Output:
GeneratorBelt
CabinAirFilter
GeneratorBelt
AirFilter
PowerSteeringBelt
CabinAirFilter
FuelFilter
PowerSteeringBelt
PowerSteeringBelt
FuelFilter
*/
</code></pre>
<p>并不是层次结构中的所有类都应该被实例化。以上示例中的<code>Filter</code>和<code>Belt</code>只是分类器，所以你不应该创建它们的实例，而只需要创建它们子类的实例（如果你尝试创建，只会得到基类<code>Part</code>的行为）。</p>
<p><code>Part</code>实现了<code>Supplier&lt;Part&gt;</code>，所以它可以通过自己的<code>get()</code>提供其他的<code>Part</code>对象。如果调用了基类<code>Part</code>的<code>get()</code>方法（或者通过<code>generate()</code>调用<code>get()</code>），它会随机创建特定的<code>Part</code>子类型，每个子类型最终都继承自<code>Part</code>，并重写了<code>get()</code>方法来生成自身的对象。</p>
<h2 id="195-instanceof与class的等价性">19.5　<code>Instanceof</code>与<code>Class</code>的等价性</h2>
<p>当查询类型信息时，<code>instanceof</code>和<code>isInstance()</code>的效果是一样的，而它们与<code>Class</code>对象的直接比较有着重要的区别。下面这个示例演示了它们的不同之处：</p>
<pre><code class="language-java">package reflection;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
class Base {}
class Derived extends Base {}

public class FamilyVsExactType {
    static void test(Object x) {
        System.out.println(
                &quot;Testing x of type &quot; + x.getClass());
        System.out.println(
                &quot;x instanceof Base &quot; + (x instanceof Base));
        System.out.println(
                &quot;x instanceof Derived &quot; + (x instanceof Derived));
        System.out.println(
                &quot;Base.isInstance(x) &quot; + Base.class.isInstance(x));
        System.out.println(
                &quot;Derived.isInstance(x) &quot; +
                        Derived.class.isInstance(x));
        System.out.println(
                &quot;x.getClass() == Base.class &quot; +
                        (x.getClass() == Base.class));
        System.out.println(
                &quot;x.getClass() == Derived.class &quot; +
                        (x.getClass() == Derived.class));
        System.out.println(
                &quot;x.getClass().equals(Base.class)) &quot;+
                        (x.getClass().equals(Base.class)));
        System.out.println(
                &quot;x.getClass().equals(Derived.class)) &quot; +
                        (x.getClass().equals(Derived.class)));
    }
    public static void main(String[] args) {
        test(new Base());
        test(new Derived());
    }
}
/*
Output:
Testing x of type class reflection.Base
x instanceof Base true
x instanceof Derived false
Base.isInstance(x) true
Derived.isInstance(x) false
x.getClass() == Base.class true
x.getClass() == Derived.class false
x.getClass().equals(Base.class)) true
x.getClass().equals(Derived.class)) false
Testing x of type class reflection.Derived
x instanceof Base true
x instanceof Derived true
Base.isInstance(x) true
Derived.isInstance(x) true
x.getClass() == Base.class false
x.getClass() == Derived.class true
x.getClass().equals(Base.class)) false
x.getClass().equals(Derived.class)) true
*/
</code></pre>
<p><code>test()</code>方法使用两种形式的<code>instanceof</code>来对其参数进行类型检查。然后获取<code>Class</code>引用，并使用<code>==</code>和<code>equals()</code>来测试<code>Class</code>对象的相等性。令人欣慰的是，<code>instanceof</code>和<code>isInstance()</code>产生了完全相同的结果，而<code>equals()</code>和<code>==</code>也一样。但从两组测试本身，我们可以得出不同的结论。<code>instanceof</code>与类型的概念保持了一致，它相当于表示“你是这个类，还是这个类的子类”。另一方面，如果你使用<code>==</code>比较实际的<code>Class</code>对象，则不需要考虑继承——它要么是确切的类型，要么不是。</p>
<h2 id="196-运行时的类信息">19.6　运行时的类信息</h2>
<p>如果不知道某个对象的确切类型，<code>instanceof</code>可以告诉你。但是，这里有一个限制：只有在编译时就知道的类型才能使用<code>instanceof</code>来检测，然后用获得的信息做一些有用的事情。换句话说，编译器必须知道你使用的所有类。</p>
<p>乍一看，这似乎并不是一个多大的限制，但假设你获取了一个不在你的程序空间的对象引用——事实上，在编译时你的程序甚至无法获知这个对象所属的类。也许你只是从磁盘文件或网络连接中获得了一堆字节，然后被告知这些字节代表一个类。这个类在编译器为你的程序生成代码之后很久才出现，那你怎么才能使用这样的类呢？</p>
<p>在传统的编程环境中不太可能会出现这种情况。但当我们进入一个更大的编程世界时，在一些重要场景下就会发生这种事情。首先就是基于组件的编程，在这种编程方式中，我们在构建应用程序的<strong>集成开发环境</strong>（IDE）中，通过<strong>快速应用程序开发</strong>（RAD） 模式来构建项目。这是一种可视化编程方法，它通过将代表不同组件的图标拖拽到表单中来创建程序，然后在程序里通过设置组件的属性值来配置它们。这种设计时的配置，要求组件都是可实例化的，并且要公开其部分信息，以允许程序员读取和修改组件的属性。此外，处理<strong>图形用户界面</strong>（GUI）事件的组件还必须公开相关方法的信息，以便IDE能够帮助程序员重写这些处理事件的方法。反射提供了一种检测可用方法并生成方法名称的机制。</p>
<p>在运行时获取类信息的另一个吸引人的动机就是，希望提供通过网络在远程平台上创建和运行对象的能力。这称为<strong>远程方法调用</strong>（RMI），它允许Java程序将对象分布到多台机器上。需要这种分布能力的原因有许多，例如，你可能有一个计算密集型的任务，为了提高运算速度，可以将其分解为多个部分，分布到空闲的机器上。或者你可能希望将处理特定类型任务（例如客户-服务器体系结构中的“业务规则”）的代码置于特定的机器上，这样一来，这台机器就成了描述这些操作的公共场所，可以通过对它进行简单的修改来影响系统中的所有人。分布式计算还支持擅长特定任务的专用硬件——例如矩阵求逆——而这对通用程序来说就显得不太合适或者过于昂贵。</p>
<p><code>Class</code>类和<code>java.lang.reflect</code>库一起支持了反射，这个库里包含<code>Field</code>、<code>Method</code>以及<code>Constructor</code>类（每个都实现了<code>Member</code>接口）。这些类型的对象是由JVM在运行时创建的，用来表示未知类中对应的成员。这样你就可以使用<code>Constructor</code>来创建新的对象，使用<code>get()</code>和<code>set()</code>方法来读取和修改与<code>Field</code>对象关联的字段，使用<code>invoke()</code>方法调用与<code>Method</code>对象关联的方法。另外，你还可以很便捷地调用<code>getFields()</code>、<code>getMethods()</code>和<code>getConstructors()</code>等方法，以返回表示字段、方法和构造器的对象数组（你可以在JDK文档中查找<code>Class</code>类来了解更多信息）。这样，匿名对象的类信息可以在运行时才完全确定下来，而在编译时就不需要知道任何信息。</p>
<p>重要的是，要意识到反射机制并没有什么神奇之处。当使用反射与未知类型的对象打交道时，JVM会查看这个对象，确定它属于哪个特定的类。在用它做任何事情之前，必须先加载对应的<code>Class</code>对象。因此对于JVM来说，该特定类型的.class文件必须是可用的：要么在本地机器上，要么可以通过网络获得。通过反射，在编译时不可用的.class文件就可以在运行时被打开和检查了。</p>
<h3 id="类方法提取器">类方法提取器</h3>
<p>通常来说，你不会直接用到反射工具，但它有助于创建更动态的代码。反射在Java中可以用来支持其他特性，比如对象序列化（请参阅进阶卷附录E）。而且有时候动态提取有关类的信息也是很有用的。</p>
<p>请考虑一个类方法提取器。如果我们查看一个类定义的源代码或其JDK文档，只能找到在<strong>这个类中</strong>被定义或被重写的方法。但对我们来说，可能还有更多继承自基类的可用方法。要找出这些方法既乏味又费时<strong>2</strong>。幸运的是，反射提供了一种方式，让我们能够编写简单的工具来自动展示完整的接口：</p>
<blockquote>
<p><strong>2</strong>在过去尤其是这样。不过现在Java的HTML文档有了重大改进，使得查看基类方法变得更加容易。</p>
</blockquote>
<pre><code class="language-java">package reflection;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.regex.Pattern;

/**
 * 使用反射来显示一个类的所有方法，
 * 即使这个方法是在基类中定义的
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 *
 */
//CLI argument: reflection.ShowMethods
public class ShowMethods {
    private static String usage =
            &quot;usage:\n&quot; +
                    &quot;ShowMethods qualified.class.name\n&quot; +
                    &quot;To show all methods in class or:\n&quot; +
                    &quot;ShowMethods qualified.class.name word\n&quot; +
                    &quot;To search for methods involving 'word'&quot;;
    private static Pattern p = Pattern.compile(&quot;\\w+\\.&quot;);
    public static void main(String[] args) {
        if(args.length &lt; 1) {
            System.out.println(usage);
            System.exit(0);
        }
        int lines = 0;
        try {
            Class&lt;?&gt; c = Class.forName(args[0]);
            Method[] methods = c.getMethods();
            Constructor[] ctors = c.getConstructors();
            if(args.length == 1) {
                for(Method method : methods)
                    System.out.println(
                            p.matcher(
                                    method.toString())
                                    .replaceAll(&quot;&quot;));
                for(Constructor ctor : ctors)
                    System.out.println(
                            p.matcher(ctor.toString()).replaceAll(&quot;&quot;));
                lines = methods.length + ctors.length;
            } else {
                for(Method method : methods)
                    if(method.toString().contains(args[1])) {
                        System.out.println(p.matcher(
                                method.toString()).replaceAll(&quot;&quot;));
                        lines++;
                    }
                for(Constructor ctor : ctors)
                    if(ctor.toString().contains(args[1])) {
                        System.out.println(p.matcher(
                                ctor.toString()).replaceAll(&quot;&quot;));
                        lines++;
                    }
            }
        } catch(ClassNotFoundException e) {
            System.out.println(&quot;No such class: &quot; + e);
        }
    }
}
/*
Output:
public static void main(String[])
public final void wait(long,int) throws InterruptedException
public final void wait() throws InterruptedException
public final native void wait(long) throws InterruptedException
public boolean equals(Object)
public String toString()
public native int hashCode()
public final native Class getClass()
public final native void notify()
public final native void notifyAll()
public ShowMethods()

*/
</code></pre>
<p><code>Class</code>类里的方法<code>getMethods()</code>和<code>getConstructors()</code>分别返回了<code>Method</code>对象的数组和<code>Constructor</code>对象的数组。这两个类都提供了对应的方法，来进一步解析它们所代表的方法，并获取其名称、参数和返回值的相关信息。但你也可以像上面的示例那样，只使用<code>toString()</code>方法来生成一个含有完整的方法签名的字符串。其他部分的代码提取了命令行信息，判断某个特定的方法签名是否与我们的目标字符串相匹配（使用<code>contains()</code>），并使用正则表达式去掉了名称限定符（在第18章中介绍过）。</p>
<p><code>Class.forName()</code>生成的结果在编译时是未知的，因此所有的方法签名信息都是在运行时提取的。如果研究一下JDK文档中关于反射的部分，你就会发现，反射提供了足够的支持，来创建一个在编译时完全未知的对象，并调用此对象的方法（本书后面有这样的例子）。虽然一开始你可能认为自己永远不会用到这些功能，但是反射的价值可能会令你惊讶。上面的输出是从下面的命令行产生的：</p>
<pre><code class="language-java">java ShowMethods ShowMethods
</code></pre>
<p>输出里包含了一个<code>public</code>的无参构造器，即使代码中没有定义任何构造器。你看到的这个构造器是由编译器自动合成的。如果将<code>ShowMethods</code>设为非<code>public</code>类（即包访问权限），那么这个自动合成的无参构造器就不会在输出中显示了。合成的无参构造器会自动获得与类相同的访问权限。</p>
<p>你可以尝试运行带有<code>char</code>、<code>int</code>、<code>String</code>等额外参数的<code>java ShowMethods java.lang.String</code>。</p>
<p>在编写程序时，如果你不记得一个类是否有某个特定的方法，并且也不想在JDK文档中查找索引或类层次结构，或者你不知道这个类是否可以对某个对象（比如<code>Color</code>对象）做些什么，那么这个工具可以替你节省很多时间。</p>
<h2 id="197-动态代理">19.7　动态代理</h2>
<p><strong>代理</strong>（proxy）是基本的设计模式之一。它是为了代替“实际”对象而插入的一个对象，从而提供额外的或不同的操作。这些操作通常涉及与“实际”对象的通信，因此代理通常充当中间人的角色。下面是一个用来展示代理结构的简单示例：</p>
<pre><code class="language-java">package reflection;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
//代理对象和真实对象均实现的接口
interface Interface {
    void doSomething();
    void somethingElse(String arg);
}
//真实对象
class RealObject implements Interface {
    @Override
    public void doSomething() {
        System.out.println(&quot;doSomething&quot;);
    }
    @Override
    public void somethingElse(String arg) {
        System.out.println(&quot;somethingElse &quot; + arg);
    }
}
//代理对象
class SimpleProxy implements Interface {
    //传入的真实对象
    private Interface proxied;
    //完成真实对象的初始化
    SimpleProxy(Interface proxied) {
        this.proxied = proxied;
    }
    @Override
    public void doSomething() {
        //代理对象完成的额外操作
        System.out.println(&quot;SimpleProxy doSomething&quot;);
        //真实对象完成的工作
        proxied.doSomething();
    }
    @Override
    public void somethingElse(String arg) {
        System.out.println(
                &quot;SimpleProxy somethingElse &quot; + arg);
        proxied.somethingElse(arg);
    }
}

class SimpleProxyDemo {
    public static void consumer(Interface iface) {
        iface.doSomething();
        iface.somethingElse(&quot;bonobo&quot;);
    }
    public static void main(String[] args) {
        consumer(new RealObject());
        System.out.println(&quot;-------这里划分真实和代理-------&quot;);
        consumer(new SimpleProxy(new RealObject()));
    }
}
/*
Output:
doSomething
somethingElse bonobo
SimpleProxy doSomething
doSomething
SimpleProxy somethingElse bonobo
somethingElse bonobo
*/
</code></pre>
<p><code>consumer()</code>方法接受一个<code>Interface</code>参数，所以它不知道自己得到的是一个<code>RealObject</code>还是一个<code>SimpleProxy</code>，两者都实现了<code>Interface</code>接口。<code>SimpleProxy</code>被插入到客户端和<code>RealObject</code>之间来执行操作，然后调用<code>RealObject</code>的相同方法。</p>
<p>在任何时候，如果你想要将额外的操作从“实际”对象中分离出来，特别是当你没有使用这些额外操作，但希望很轻松地就能改成使用，或反过来，这时代理就很有用了（设计模式的关注点就是封装修改——因此你需要做对应的修改来适应模式）。例如，如果你希望跟踪对<code>RealObject</code>中方法的调用，或者测量此类调用的开销，该怎么办？你肯定不希望在应用程序中包含这些代码，而代理可以让你很容易地添加或删除它们。</p>
<p>Java的<strong>动态代理</strong>（dynamic proxy）比代理更进一步，它可以动态地创建代理，并动态地处理对所代理方法的调用。在动态代理上进行的所有调用都会被重定向到一个<strong>调用处理器</strong>（invocation handler）上，这个调用处理器的工作就是发现这是什么调用，然后决定如何处理它。下面是用动态代理重写的SimpIeProxyDemo.java：</p>
<pre><code class="language-java">package reflection;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;


/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */

//动态调用处理器，实现了Java自身的调用处理器接口
class DynamicProxyHandler implements InvocationHandler {
    private Object proxied;
    DynamicProxyHandler(Object proxied) {
        this.proxied = proxied;
    }
    @Override
    //每个被代理的方法都会到这里来，决定自己应该干什么。后两个参数可以构成方法签名。
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        System.out.println(
                &quot;**** proxy: &quot; + proxy.getClass() +
                        &quot;, method: &quot; + method + &quot;, args: &quot; + args);
        if(args != null)
            for(Object arg : args)
                System.out.println(&quot;  &quot; + arg);
        return method.invoke(proxied, args);
    }
}

class SimpleDynamicProxy {
    public static void consumer(Interface iface) {
        iface.doSomething();
        iface.somethingElse(&quot;bonobo&quot;);
    }
    public static void main(String[] args) {
        RealObject real = new RealObject();
        consumer(real);
        // 插入一个代理
        //我们通过调用静态方法Proxy.newProxyInstance()来创建动态代理，它需要三个参数：一个类加载器（通常可以从一个已经加载的对象里获取其类加载器，然后传递给它就可以了），一个希望代理实现的接口列表（不是类或抽象类），以及InvocationHandler接口的一个实现。动态代理会将所有调用重定向到调用处理器，因此调用处理器的构造器通常会获得“实际”对象的引用，以便它在执行完自己的中间任务后可以转发请求。
        Interface proxy = (Interface) Proxy.newProxyInstance(
                Interface.class.getClassLoader(),
                new Class[]{ Interface.class },
                new DynamicProxyHandler(real));
        //再次调用
        consumer(proxy);
    }
}
/*
Output:
doSomething
somethingElse bonobo
**** proxy: class reflection.$Proxy0, method: public abstract void reflection.Interface.doSomething(), args: null
doSomething
**** proxy: class reflection.$Proxy0, method: public abstract void reflection.Interface.somethingElse(java.lang.String), args: [Ljava.lang.Object;@1f17ae12
  bonobo
somethingElse bonobo
*/
</code></pre>
<p>我们通过调用静态方法<code>Proxy.newProxyInstance()</code>来创建动态代理，它需要三个参数：一个类加载器（通常可以从一个已经加载的对象里获取其类加载器，然后传递给它就可以了），一个希望代理实现的接口列表（不是类或抽象类），以及<code>InvocationHandler</code>接口的一个实现。动态代理会将所有调用重定向到调用处理器，因此调用处理器的构造器通常会获得“实际”对象的引用，以便它在执行完自己的中间任务后可以转发请求。</p>
<p>代理对象传递给了<code>invoke()</code>方法来处理，以防你需要区分请求的来源，但是在许多情况下，你并不关心这一点。不过，在<code>invoke()</code>内部调用代理的方法时需要小心，因为对接口的调用是通过代理进行重定向的。</p>
<p>通常，你会执行被代理的操作，然后使用<code>Method.invoke()</code>方法将请求转发给被代理的对象，并传入必要的参数。乍一看这可能有些受限，就好像你只能执行通用的操作一样。但是，你可以过滤某些方法调用，同时又放行其他的方法调用：</p>
<pre><code class="language-java">package reflection;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
class MethodSelector implements InvocationHandler {
    private Object proxied;
    MethodSelector(Object proxied) {
        this.proxied = proxied;
    }
    @Override public Object
    invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        if(method.getName().equals(&quot;interesting&quot;))
            System.out.println(
                    &quot;Proxy detected the interesting method&quot;);
        return method.invoke(proxied, args);
    }
}

interface SomeMethods {
    void boring1();
    void boring2();
    void interesting(String arg);
    void boring3();
}

class Implementation implements SomeMethods {
    @Override public void boring1() {
        System.out.println(&quot;boring1&quot;);
    }
    @Override public void boring2() {
        System.out.println(&quot;boring2&quot;);
    }
    @Override public void interesting(String arg) {
        System.out.println(&quot;interesting &quot; + arg);
    }
    @Override public void boring3() {
        System.out.println(&quot;boring3&quot;);
    }
}

class SelectingMethods {
    public static void main(String[] args) {
        SomeMethods proxy =
                (SomeMethods) Proxy.newProxyInstance(
                        SomeMethods.class.getClassLoader(),
                        new Class[]{ SomeMethods.class },
                        new MethodSelector(new Implementation()));
        proxy.boring1();
        proxy.boring2();
        proxy.interesting(&quot;bonobo&quot;);
        proxy.boring3();
    }
}
/*
Output:
boring1
boring2
Proxy detected the interesting method
interesting bonobo
boring3
*/
</code></pre>
<p>在这里，我们只是查看了方法名称，但你还可以查看方法签名的其他方面，甚至可以搜索特定的参数值。</p>
<p>动态代理并不是日常使用的工具，但它可以很好地解决某些类型的问题。在Erich Gamma等人撰写的《设计模式：可复用面向对象软件的基础》一书和本书的进阶卷第8章中，你可以了解更多有关代理和其他设计模式的信息。</p>
<h2 id="198-使用optional">19.8　使用<code>Optional</code></h2>
<p>当使用内置的<code>null</code>来表示对象不存在时，为了确保安全，你必须在每次使用对象的引用时都测试一下它是否为<code>null</code>。这会变得很乏味，并产生冗长的代码。**问题在于<code>null</code>没有自己的行为，而当你尝试用它做任何事情时，都会产生一个<code>NullPointerException</code>。**我们在第13章中介绍过<code>java.util.Optional</code>，它创建了一个简单的代理来屏蔽潜在的<code>null</code>值。<code>Optional</code>对象会阻止你的代码直接抛出<code>NullPointerException</code>。</p>
<p>尽管<code>Optional</code>是在Java 8中引入来支持<code>Stream</code>的，但它是一个通用工具，可以应用于普通类就证明了这一点。这个主题之所以包含在本章中，是因为涉及运行时检查。</p>
<p>在实际应用中，到处使用<code>Optional</code>是没有意义的——有时判断一下是否为<code>null</code>没什么不好，有时你可以合理地假设自己不会遇到<code>null</code>，有时甚至通过<code>NullPointerException</code>来检测异常也是可以接受的。<code>Optional</code>看起来在“更接近数据”的地方最有用，此时对象代表问题空间中的实体。举个简单的例子，许多系统里有<code>Person</code>类，但在代码中，有些情况下你并没有获得这样一个实际的对象（或者你可能有，但还没有关于那个对象的所有信息），所以通常你会使用一个<code>null</code>引用来表示，然后对其进行检查。而现在我们就可以使用<code>Optional</code>来代替了：</p>
<pre><code class="language-java">package reflection;

import java.util.Optional;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
class Person {
    public final Optional&lt;String&gt; first;
    public final Optional&lt;String&gt; last;
    public final Optional&lt;String&gt; address;
    // 省略其余代码
    public final boolean empty;
    Person(String first, String last, String address) {
        this.first = Optional.ofNullable(first);
        this.last = Optional.ofNullable(last);
        this.address = Optional.ofNullable(address);
        empty = !this.first.isPresent()
                &amp;&amp; !this.last.isPresent()
                &amp;&amp; !this.address.isPresent();
    }
    Person(String first, String last) {
        this(first, last, null);
    }
    Person(String last) { this(null, last, null); }
    Person() { this(null, null, null); }
    @Override public String toString() {
        if(empty)
            return &quot;&lt;Empty&gt;&quot;;
        return (first.orElse(&quot;&quot;) +
                &quot; &quot; + last.orElse(&quot;&quot;) +
                &quot; &quot; + address.orElse(&quot;&quot;)).trim();
    }
    public static void main(String[] args) {
        System.out.println(new Person());
        System.out.println(new Person(&quot;Smith&quot;));
        System.out.println(new Person(&quot;Bob&quot;, &quot;Smith&quot;));
        System.out.println(new Person(&quot;Bob&quot;, &quot;Smith&quot;,
                &quot;11 Degree Lane, Frostbite Falls, MN&quot;));
    }
}
/*
Output:
&lt;Empty&gt;
Smith
Bob Smith
Bob Smith 11 Degree Lane, Frostbite Falls, MN
*/
</code></pre>
<p><code>Person</code>的设计有时被称为“数据传输对象”。注意，所有的字段都是<code>public</code>和<code>final</code>的，因此没有getter和setter方法。也就是说，<code>Person</code>是<strong>不可变</strong>的——你只能用构造器设置值，然后读取这些值，但你不能修改它们（字符串本身是不可变的，所以你不能修改字符串的内容，也不能给字段重新赋值）。要更改<code>Person</code>，你只能将其替换为新的<code>Person</code>对象。<code>empty</code>字段在构造期间赋值，以便轻松地检查这个<code>Person</code>是否代表一个空对象。</p>
<p>任何使用<code>Person</code>的人在访问这些字符串字段时都会被强制使用<code>Optional</code>接口，因此不会意外触发<code>NullPointerException</code>。</p>
<p>现在假设你已经为自己的惊人创意获得了大量风险投资，并准备好了要招聘人员。但在职位空缺时，你可以用<code>Optional</code>来为<code>Position</code>的<code>Person</code>字段提供占位符：</p>
<pre><code class="language-java">package reflection;

import java.util.Optional;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
class EmptyTitleException extends RuntimeException {}

class Position {
    private String title;
    private Person person;
    Position(String jobTitle, Person employee) {
        setTitle(jobTitle);
        setPerson(employee);
    }
    Position(String jobTitle) {
        this(jobTitle, null);
    }
    public String getTitle() { return title; }
    public void setTitle(String newTitle) {
        // 如果newTitle是null，则抛出EmptyTitleException：
        title = Optional.ofNullable(newTitle)
                .orElseThrow(EmptyTitleException::new);
    }
    public Person getPerson() { return person; }
    public void setPerson(Person newPerson) {
        // 如果newPerson是null，则使用一个空的Person：
        person = Optional.ofNullable(newPerson)
                .orElse(new Person());
    }
    @Override
    public String toString() {
        return &quot;Position: &quot; + title +
                &quot;, Employee: &quot; + person;
    }
    public static void main(String[] args) {
        System.out.println(new Position(&quot;CEO&quot;));
        System.out.println(new Position(&quot;Programmer&quot;,
                new Person(&quot;Arthur&quot;, &quot;Fonzarelli&quot;)));
        try {
            new Position(null);
        } catch(Exception e) {
            System.out.println(&quot;caught &quot; + e);
        }
    }
}
/*
Output:
Position: CEO, Employee: &lt;Empty&gt;
Position: Programmer, Employee: Arthur Fonzarelli
caught reflection.EmptyTitleException
*/
</code></pre>
<p>这个示例以不同的方式来使用<code>Optional</code>。注意，<code>title</code>和<code>person</code>都是普通字段，不受<code>Optional</code>的保护。但是，修改这些字段唯一的方法是通过<code>setTitle()</code>和<code>setPerson()</code>，而这两者都使用了<code>Optional</code>的功能来对字段加以限制。</p>
<p>我们想要保证<code>title</code>永远不会被设置为<code>null</code>。在<code>setTitle()</code>方法中，我们可以自己检查<code>newTitle</code>参数。但是函数式编程的很大一部分就是能够重用经过尝试和验证的功能，即便这些功能通常很小，这样可以减少手动编写代码时犯的各种小错误。所以我们用<code>ofNullable()</code>把<code>newTitle</code>转换成<code>Optional</code>，这意味着如果<code>newTitle</code>是<code>null</code>，它将生成一个<code>Optional.empty()</code>。然后立即获取该<code>Optional</code>结果，并调用它的<code>orElseThrow()</code>方法，此时如果<code>newTitle</code>为<code>null</code>，将得到一个异常。我们并没有将该字段存储为<code>Optional</code>，但使用了<code>Optional</code>的功能来对<code>title</code>字段施加想要的约束。</p>
<p><code>EmptyTitleException</code>是一个<code>RuntimeException</code>，因为它代表了一个程序员错误。在这个方案里你仍然得到了一个异常，但你是在错误发生的时候得到它的——也就是当<code>null</code>被传递给<code>setTitle()</code>时——而不是在程序中的其他地方，如果在其他地方的话你就不得不对程序进行调试才能发现问题所在。此外，<code>EmptyTitleException</code>的使用有助于进一步定位错误。</p>
<p><code>person</code>字段具有不同的约束：如果尝试将其设置为<code>null</code>，它会自动设置为一个空的<code>Person</code>对象。我们使用与之前相同的方法将其转换为<code>Option</code>，但在这个例子中，当提取结果时，我们使用了<code>orElse(new Person())</code>将<code>null</code>替换成空的<code>Person</code>来插入。</p>
<p>对于<code>Position</code>，我们不需要创建“空”的标记或方法，因为如果<code>person</code>字段的值是一个空的<code>Person</code>对象，这就意味着这个<code>Position</code>还是处于空缺状态。稍后，你可能会发现必须在此处添加一些明确的内容，但是根据YAGNI<strong>3</strong>（You Aren't Going to Need It，你并不需要它）原则，在初稿中只“尝试最简单且可行的事情”，直到程序的某些方面要求你添加额外的功能，而不是一开始就假设它是必要的。</p>
<p><strong>3****极限编程</strong>（Extreme Programming, XP）的一项宗旨就是“尝试最简单且可行的事情”。</p>
<p>注意<code>Staff</code>类轻松地忽略了<code>Optional</code>的存在，尽管你知道它们在那里，保护你免受<code>NullPointerException</code>的影响：</p>
<pre><code class="language-java">package reflection;

import java.util.ArrayList;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
public class Staff extends ArrayList&lt;Position&gt; {
    public void add(String title, Person person) {
        add(new Position(title, person));
    }
    public void add(String... titles) {
        for(String title : titles)
            add(new Position(title));
    }
    public Staff(String... titles) { add(titles); }
    public boolean positionAvailable(String title) {
        for(Position position : this)
            if(position.getTitle().equals(title) &amp;&amp;
                    position.getPerson().empty)
                return true;
        return false;
    }
    public void fillPosition(String title, Person hire) {
        for(Position position : this)
            if(position.getTitle().equals(title) &amp;&amp;
                    position.getPerson().empty) {
                position.setPerson(hire);
                return;
            }
        throw new RuntimeException(
                &quot;Position &quot; + title + &quot; not available&quot;);
    }
    public static void main(String[] args) {
        Staff staff = new Staff(&quot;President&quot;, &quot;CTO&quot;,
                &quot;Marketing Manager&quot;, &quot;Product Manager&quot;,
                &quot;Project Lead&quot;, &quot;Software Engineer&quot;,
                &quot;Software Engineer&quot;, &quot;Software Engineer&quot;,
                &quot;Software Engineer&quot;, &quot;Test Engineer&quot;,
                &quot;Technical Writer&quot;);
        staff.fillPosition(&quot;President&quot;,
                new Person(&quot;Me&quot;, &quot;Last&quot;, &quot;The Top, Lonely At&quot;));
        staff.fillPosition(&quot;Project Lead&quot;,
                new Person(&quot;Janet&quot;, &quot;Planner&quot;, &quot;The Burbs&quot;));
        if(staff.positionAvailable(&quot;Software Engineer&quot;))
            staff.fillPosition(&quot;Software Engineer&quot;,
                    new Person(
                            &quot;Bob&quot;, &quot;Coder&quot;, &quot;Bright Light City&quot;));
        System.out.println(staff);
    }
}
/*
Output:
[Position: President, Employee: Me Last The Top, Lonely At, Position: CTO, Employee: &lt;Empty&gt;, Position: Marketing Manager, Employee: &lt;Empty&gt;, Position: Product Manager, Employee: &lt;Empty&gt;, Position: Project Lead, Employee: Janet Planner The Burbs, Position: Software Engineer, Employee: Bob Coder Bright Light City, Position: Software Engineer, Employee: &lt;Empty&gt;, Position: Software Engineer, Employee: &lt;Empty&gt;, Position: Software Engineer, Employee: &lt;Empty&gt;, Position: Test Engineer, Employee: &lt;Empty&gt;, Position: Technical Writer, Employee: &lt;Empty&gt;]
*/
</code></pre>
<p>在某些地方可能仍然需要检查<code>Optional</code>，这与检查<code>null</code>没有什么不同，但在其他地方（例如本例中的<code>toString()</code>转换）不需要进行额外的检查，可以直接假设所有的对象引用都是有效的。</p>
<h3 id="1981-标签接口">19.8.1　标签接口</h3>
<p>有时使用<strong>标签接口</strong>（tagging interface）来表示可空性更方便。标签接口没有元素，我们只是将它的名称当作标签来使用：</p>
<pre><code class="language-java">package onjava;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
public interface Null { }
</code></pre>
<p>如果你使用的是接口而不是具体类，那么就可以使用<code>DynamicProxy</code>来自动生成<code>Null</code>。假设有一个<code>Robot</code>接口，它定义了名称、模型以及一个描述了自身功能的<code>List&lt;Operation&gt;</code>：</p>
<pre><code class="language-java">package reflection;

import onjava.Null;

import java.util.*;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
public interface Robot {
    String name();
    String model();
    List&lt;Operation&gt; operations();
    static void test(Robot r) {
        if (r instanceof Null)
            System.out.println(&quot;[Null Robot]&quot;);
        System.out.println(&quot;Robot name: &quot; + r.name());
        System.out.println(&quot;Robot model: &quot; + r.model());
        for (Operation operation : r.operations()) {
            System.out.println(operation.description.get());
            operation.command.run();
        }
    }
}
</code></pre>
<p>可以通过调用<code>operations()</code>来访问<code>Robot</code>的服务。<code>Robot</code>还包含了一个静态方法来执行测试。</p>
<p><code>Operation</code>包含一个描述和一个命令[这是一种<strong>命令模式</strong>（Command pattern）]。它们被定义为对函数式接口的引用，这样你就可以将lambda表达式或方法引用传递给<code>Operation</code>的构造器：</p>
<pre><code class="language-java">package reflection;

import java.util.function.Supplier;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
public class Operation {
    public final Supplier&lt;String&gt; description;
    public final Runnable command;
    public
    Operation(Supplier&lt;String&gt; descr, Runnable cmd) {
        description = descr;
        command = cmd;
    }
}
</code></pre>
<p>现在可以创建一个扫雪的<code>Robot</code>：</p>
<pre><code class="language-java">package reflection;

import java.util.Arrays;
import java.util.List;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
public class SnowRobot implements Robot {
    private String name;
    public SnowRobot(String name) {
        this.name = name;
    }
    @Override
    public String name() { return name; }
    @Override
    public String model() {
        return &quot;SnowBot Series 11&quot;;
    }
    private List&lt;Operation&gt; ops = Arrays.asList(
            new Operation(
                    () -&gt; name + &quot; can shovel snow&quot;,
                    () -&gt; System.out.println(
                            name + &quot; shoveling snow&quot;)),
            new Operation(
                    () -&gt; name + &quot; can chip ice&quot;,
                    () -&gt; System.out.println(name + &quot; chipping ice&quot;)),
            new Operation(
                    () -&gt; name + &quot; can clear the roof&quot;,
                    () -&gt; System.out.println(
                            name + &quot; clearing roof&quot;)));
    @Override
    public List&lt;Operation&gt; operations() { return ops; }
    public static void main(String[] args) {
        Robot.test(new SnowRobot(&quot;Slusher&quot;));
    }
}
/*
Output:
Robot name: Slusher
Robot model: SnowBot Series 11
Slusher can shovel snow
Slusher shoveling snow
Slusher can chip ice
Slusher chipping ice
Slusher can clear the roof
Slusher clearing roof

*/
</code></pre>
<p>可能会有许多不同类型的<code>Robot</code>，而且对于每种<code>Robot</code>类型，如果为<code>Null</code>，则做一些特殊操作——本例中会提供<code>Robot</code>的确切类型信息。此信息由动态代理捕获：</p>
<pre><code class="language-java">package reflection;

import onjava.Null;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Collections;
import java.util.List;
import java.util.stream.Stream;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
class NullRobotProxyHandler implements InvocationHandler {
    private String nullName;
    //在这里对代理对象进行了初始化
    private Robot proxied = new NRobot();
    NullRobotProxyHandler(Class&lt;? extends Robot&gt; type) {
        nullName = type.getSimpleName() + &quot; NullRobot&quot;;
    }
    private class NRobot implements Null, Robot {
        @Override
        public String name() { return nullName; }
        @Override
        public String model() { return nullName; }
        @Override public List&lt;Operation&gt; operations() {
            return Collections.emptyList();
        }
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        //在创建类的时候需要完成的操作已经完成了，所以代理这里也不需要做什么了，直接返回就可以
        return method.invoke(proxied, args);
    }
}

public class NullRobot {
    public static Robot
    newNullRobot(Class&lt;? extends Robot&gt; type) {
        return (Robot) Proxy.newProxyInstance(
                NullRobot.class.getClassLoader(),
                //希望实现的接口是new方法，希望返回一个满足Null以及Robot的类
                new Class[]{ Null.class, Robot.class },
                new NullRobotProxyHandler(type));
    }
    public static void main(String[] args) {
        Stream.of(
                new SnowRobot(&quot;SnowBee&quot;),
                newNullRobot(SnowRobot.class)
        ).forEach(Robot::test);
    }
}
/*
Output:
Robot name: SnowBee
Robot model: SnowBot Series 11
SnowBee can shovel snow
SnowBee shoveling snow
SnowBee can chip ice
SnowBee chipping ice
SnowBee can clear the roof
SnowBee clearing roof
[Null Robot]
Robot name: SnowRobot NullRobot
Robot model: SnowRobot NullRobot

*/
</code></pre>
<p>每当需要一个空的<code>Robot</code>对象时，调用<code>newNullRobot()</code>即可，传递给它想要的<code>Robot</code>类型，它会返回一个代理。代理会同时满足<code>Robot</code>和<code>Null</code>接口的要求，并提供它所代理的类型的特定名称。</p>
<h3 id="1982-模拟对象和桩">19.8.2　模拟对象和桩</h3>
<p><strong>模拟对象</strong>（Mock Object）和<strong>桩</strong>（Stub）是<code>Optional</code>的逻辑变体。这两个都是在最终的程序中使用的“实际”对象的代理。模拟对象和桩都假装是提供真实信息的实际对象，而不会像<code>Optional</code>那样隐藏对象，甚至包括null对象。</p>
<p>模拟对象和桩之间的区别在于程度的不同。模拟对象往往是轻量级和自测试的，通常我们创建很多模拟对象是为了处理各种不同的测试情况。桩只返回桩数据，它通常是重量级的，并且经常在测试之间重用。桩可以根据它们的调用方式，通过配置进行更改。所以桩是一个复杂的对象，它只做一件事情。如果你需要做很多事情，通常会创建很多小而简单的模拟对象。</p>
<h2 id="199-接口和类型信息">19.9　接口和类型信息</h2>
<p><code>interface</code>关键字的一个重要目标是允许程序员隔离组件，从而减少耦合。如果只和接口通信，那么就可以实现这一目标，但是通过类型信息可能会绕过它——接口并不一定保证解耦。假设我们从一个接口开始：</p>
<pre><code class="language-java">package reflection.interfacea;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
public interface A {
    void f();
}
</code></pre>
<p>下面的示例显示了如何偷偷访问实际的实现类型：</p>
<pre><code class="language-java">package reflection;

import reflection.interfacea.A;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
class B implements A {
    @Override
    public void f() {}

    public void g() {}
}

public class InterfaceViolation {
    public static void main(String[] args) {
        A a = new B();
        a.f();
        // a.g(); // 编译错误
        System.out.println(a.getClass().getName());
        if(a instanceof B) {
            B b = (B)a;
            b.g();
        }
    }
}
//Output:reflection.B
</code></pre>
<p>通过反射，可以发现<code>a</code>实际上是被当作<code>B</code>实现的。通过强制转型为<code>B</code>，我们可以调用不在<code>A</code>中的方法。</p>
<p>这是完全合法并且可接受的，但你可能不希望客户程序员这样做，因为这给了他们一个机会，让他们的代码与你的代码耦合程度超出你的期望。也就是说，你可能认为<code>interface</code>关键字正在保护着你，但事实并非如此，而且本例中使用<code>B</code>来实现<code>A</code>这一事实，实际上是公开可见的<strong>4</strong>。</p>
<p><strong>4</strong>最著名的案例是<code>Windows</code>操作系统，它有一个已发布API供你调用，还有一组未发布但可见的函数，可以让你发现并调用。为了解决问题，程序员使用了隐藏的API函数，这迫使微软公司将它们作为公共API的一部分进行维护。这成了使微软公司投入巨额成本和大量精力的无底洞。</p>
<p>一种解决方案是直接声明，如果程序员决定使用实际的类而不是接口，他们就得自己承担后果。在许多情况下这可能是合理的，但如果事实并非如此，你就需要实施更严格的控制。</p>
<p>最简单的方法是使用包访问权限来实现，这样包外的客户就看不到它了：</p>
<pre><code class="language-java">package reflection.packageaccess;

import reflection.interfacea.A;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
class C implements A {
    @Override public void f() {
        System.out.println(&quot;public C.f()&quot;);
    }
    public void g() {
        System.out.println(&quot;public C.g()&quot;);
    }
    void u() {
        System.out.println(&quot;package C.u()&quot;);
    }
    protected void v() {
        System.out.println(&quot;protected C.v()&quot;);
    }
    private void w() {
        System.out.println(&quot;private C.w()&quot;);
    }
}

public class HiddenC {
    public static A makeA() { return new C(); }
}
</code></pre>
<p>类<code>HiddenC</code>是这个包唯一的<code>public</code>部分，调用它时会生成一个<code>A</code>接口。即使<code>makeA()</code>返回了一个<code>C</code>类型，在包外仍然不能使用除<code>A</code>外的任何事物，因为你不能在包外命名<code>C</code>。</p>
<p>现在，如果尝试向下转型为<code>C</code>，你会发现无法做到，因为包外没有可用的<code>C</code>类型：</p>
<pre><code class="language-java">package reflection;

import reflection.interfacea.A;
import reflection.packageaccess.HiddenC;

import java.lang.reflect.Method;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
public class HiddenImplementation {
    public static void
    main(String[] args) throws Exception {
        A a = HiddenC.makeA();
        a.f();
        System.out.println(a.getClass().getName());
        // 编译错误：无法找到符号'C'：
    /* if(a instanceof C) {
      C c = (C)a;
      c.g();
    } */
        // 呀！反射仍然允许我们调用g()：
        callHiddenMethod(a, &quot;g&quot;);
        // 甚至访问权限更小的方法：
        callHiddenMethod(a, &quot;u&quot;);
        callHiddenMethod(a, &quot;v&quot;);
        callHiddenMethod(a, &quot;w&quot;);
    }
    static void
    callHiddenMethod(Object a, String methodName)
            throws Exception {
        Method g =
                a.getClass().getDeclaredMethod(methodName);
        g.setAccessible(true);
        g.invoke(a);
    }
}
/*
Output:public C.f()
reflection.packageaccess.C
public C.g()
package C.u()
protected C.v()
private C.w()
*/
</code></pre>
<p>你仍然可以使用反射来访问并调用<strong>所有</strong>的方法，甚至包括<code>private</code>的方法！如果你知道方法的名称，就可以通过调用<code>Method</code>对象的<code>setAccessible(true)</code>来设置，从而让这个方法可以被调用，就像<code>callHiddenMethod()</code>中所示的那样。</p>
<p>你可能认为通过仅发布已编译的代码可以防止这种情况，但这不是解决方案。只需要运行JDK自带的反编译器<code>javap</code>就能绕过它。</p>
<p>因此，任何人都可以获取你最私有的方法的名称和签名，并调用它们。</p>
<p>如果将接口实现为私有内部类会怎样？下面的示例展示了这种情况：</p>
<pre><code class="language-java">package reflection;

import reflection.interfacea.A;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
class InnerA {
    private static class C implements A {
        @Override public void f() {
            System.out.println(&quot;public C.f()&quot;);
        }
        public void g() {
            System.out.println(&quot;public C.g()&quot;);
        }
        void u() {
            System.out.println(&quot;package C.u()&quot;);
        }
        protected void v() {
            System.out.println(&quot;protected C.v()&quot;);
        }
        private void w() {
            System.out.println(&quot;private C.w()&quot;);
        }
    }
    public static A makeA() { return new C(); }
}

public class InnerImplementation {
    public static void
    main(String[] args) throws Exception {
        A a = InnerA.makeA();
        a.f();
        System.out.println(a.getClass().getName());
        // 反射仍然能访问私有类内部：
        HiddenImplementation.callHiddenMethod(a, &quot;g&quot;);
        HiddenImplementation.callHiddenMethod(a, &quot;u&quot;);
        HiddenImplementation.callHiddenMethod(a, &quot;v&quot;);
        HiddenImplementation.callHiddenMethod(a, &quot;w&quot;);
    }
}
/*
Output:
public C.f()
reflection.InnerA$C
public C.g()
package C.u()
protected C.v()
private C.w()*/
</code></pre>
<p>这里对反射仍然没有隐藏任何东西。那么匿名类呢？</p>
<pre><code class="language-java">package reflection;

import reflection.interfacea.A;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
class AnonymousA {
    public static A makeA() {
        return new A() {
            @Override public void f() {
                System.out.println(&quot;public C.f()&quot;);
            }
            public void g() {
                System.out.println(&quot;public C.g()&quot;);
            }
            void u() {
                System.out.println(&quot;package C.u()&quot;);
            }
            protected void v() {
                System.out.println(&quot;protected C.v()&quot;);
            }
            private void w() {
                System.out.println(&quot;private C.w()&quot;);
            }
        };
    }
}

public class AnonymousImplementation {
    public static void
    main(String[] args) throws Exception {
        A a = AnonymousA.makeA();
        a.f();
        System.out.println(a.getClass().getName());
        // 反射仍然能访问匿名类内部：
        HiddenImplementation.callHiddenMethod(a, &quot;g&quot;);
        HiddenImplementation.callHiddenMethod(a, &quot;u&quot;);
        HiddenImplementation.callHiddenMethod(a, &quot;v&quot;);
        HiddenImplementation.callHiddenMethod(a, &quot;w&quot;);
    }
}
/*
Output:
public C.f()
reflection.AnonymousA$1
public C.g()
package C.u()
protected C.v()
private C.w()
*/
</code></pre>
<p>看来没有任何方法可以阻止反射进入并调用非公共访问权限的方法。对于字段，甚至是<code>private</code>的字段，也是如此：</p>
<pre><code class="language-java">package reflection;

import java.lang.reflect.Field;

/**
 * @author: Caldarius
 * @date: 2023/2/14
 * @description:
 */
class WithPrivateFinalField {
    private int i = 1;
    private final String s = &quot;I'm totally safe&quot;;
    private String s2 = &quot;Am I safe?&quot;;
    @Override public String toString() {
        return &quot;i = &quot; + i + &quot;, &quot; + s + &quot;, &quot; + s2;
    }
}

public class ModifyingPrivateFields {
    public static void
    main(String[] args) throws Exception {
        WithPrivateFinalField pf =
                new WithPrivateFinalField();
        System.out.println(pf);
        Field f = pf.getClass().getDeclaredField(&quot;i&quot;);
        f.setAccessible(true);
        System.out.println(
                &quot;f.getInt(pf): &quot; + f.getInt(pf));
        f.setInt(pf, 47);
        System.out.println(pf);
        f = pf.getClass().getDeclaredField(&quot;s&quot;);
        f.setAccessible(true);
        System.out.println(&quot;f.get(pf): &quot; + f.get(pf));
        f.set(pf, &quot;No, you're not!&quot;);
        System.out.println(pf);
        f = pf.getClass().getDeclaredField(&quot;s2&quot;);
        f.setAccessible(true);
        System.out.println(&quot;f.get(pf): &quot; + f.get(pf));
        f.set(pf, &quot;No, you're not!&quot;);
        System.out.println(pf);
    }
}
/*
Output:
i = 1, I'm totally safe, Am I safe?
f.getInt(pf): 1
i = 47, I'm totally safe, Am I safe?
f.get(pf): I'm totally safe
i = 47, I'm totally safe, Am I safe?
f.get(pf): Am I safe?
i = 47, I'm totally safe, No, you're not!
*/
</code></pre>
<p>不过，<code>final</code>字段实际上是安全的，不会发生变化。运行时系统在接受任何更改尝试时并不会报错，但实际上什么也不会发生。</p>
<p>一般来说，这些访问违规并不是世界上最糟糕的事情。如果有人使用这种技术来调用你标记为<code>private</code>或包访问权限的方法（即这些方法不应该被调用），那么当你更改这些方法的某些方面时，他们就不应该抱怨。此外，Java语言提供了一个后门来访问类，这一事实可以让你能够解决某些特定类型的问题。如果没有这个后门的话，这些问题会难以解决，甚至不可能解决。反射带来的好处通常很难否认。</p>
<p>程序员经常对语言提供的访问控制过于自信，以至于相信在安全性方面，Java比其他提供了（显然）不太严格的访问控制的语言更优越<strong>5</strong>。正如你所看到的，事实并非如此。</p>
<p><strong>5</strong>例如，在Python中，你在要隐藏的元素前面放置一个双下划线<code>__</code>，如果尝试在类或包之外访问它，运行时系统就会报错。</p>
<h2 id="1910-总结">19.10　总结</h2>
<p>反射从匿名的基类引用中发现类型信息。初学者极易误用它，因为在学会使用多态方法调用之前，使用反射可能感觉很合理。对有过程化编程背景的人来说，很难不把程序组织成一系列的<code>switch</code>语句。你可以用反射实现这一点，但是这样的话，就在代码开发和维护过程中失去了多态的重要价值。面向对象编程语言的目的就是，在任何可能的地方都使用多态，而只在必要的时候使用反射。</p>
<p>但是，如果想按预期使用多态方法调用，就需要控制基类的定义，因为在扩展程序的时候，你可能会发现基类并未包含自己想要的方法。如果基类来自别人的库，一种解决方案就是反射：你可以继承一个新类，然后添加额外的方法。在代码的其他地方，你可以检查自己特定的类型，并调用这个特殊方法。这样做不会破坏程序的多态性以及可扩展性，因为只添加一个新类型的话，并不会让你在程序中到处查找<code>switch</code>语句来修改。但如果添加需要新功能的代码，就必须使用反射来检查你的特定类型。</p>
<p>将某个功能放在基类中可能意味着，为了某个特定类的利益，接口变得不那么合理。例如，考虑一个代表乐器的类层次结构。假设我们想清洁管弦乐队中某些乐器的排气阀。一个办法是在基类<code>Instrument</code>中放置一个<code>clearSpitValve()</code>方法，但这会造成混淆，因为它暗示<code>Percussion</code>、<code>Stringed</code>和<code>Electronic</code>这些乐器也有排气阀。反射可以提供一个合理的解决方案，你可以将方法放在合适的特定类中（在本例中为<code>Wind</code>）。同时，你可能会发现一个更合理的解决方案，例如在基类中提供一个<code>prepareInstrument()</code>方法。但是，当你第一次解决问题时，可能看不到这样的解决方案，而错误地认为必须使用反射。</p>
<p>最后，反射有时能解决效率问题。假设你的代码使用了多态，但是其中某个对象运行这种通用代码的效率极低。你可以使用反射来选择该类型，然后为其编写特定场景的代码来提高效率。但是，请注意不要过早为提高效率而编程。这是一个诱人的陷阱。最好让程序<strong>先</strong>运行起来，再考虑它是否运行得足够快，如果想要解决效率问题，则应该使用分析器（profiler）。</p>
<p>我们还看到，由于反射允许更加动态的编程风格，因此它开创了一个包含各种可能性的编程新世界。对某些人来说，反射的这种动态特性令人不安。你可以执行一些操作，这些操作只能在运行时检查，并且用异常来报告检查结果，而对于已经习惯了静态类型检查安全性的人来说，这看起来好像是一个错误的方向。有些人甚至声称引入运行时异常本身就是一个明确的表示，这说明应该避免这种代码。我发现这种安全感是一种幻觉，因为总有一些事情可能在运行时发生并抛出异常，即使在一个不包含<code>try</code>块或异常说明的程序中也是如此。与之前那种意见相反，我认为一致的错误报告模型的存在，使我们<strong>能够</strong>通过反射编写动态代码。当然，尽力编写能够进行静态检查的代码是值得的，如果可以的话就应该这么做。但是我相信动态代码是将Java与C++等语言区分开来的重要工具之一。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[代理模式的三种实现]]></title>
        <id>https://caldarius.github.io/post/dai-li-mo-shi-de-san-chong-shi-xian/</id>
        <link href="https://caldarius.github.io/post/dai-li-mo-shi-de-san-chong-shi-xian/">
        </link>
        <updated>2024-10-23T02:05:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="proxy">Proxy</h1>
<blockquote>
<p>本文对《onJava8基础卷》第十九章反射中提到的静态代理和基于反射技术的动态代理，也就是通常说的JDK代理的方式进行分享。同时摘录了CGLib实现动态代理的方式。并对代码实现中的一些细节进行进行了注释。</p>
</blockquote>
<p>首先是一个简单的例子，展示了代理模式的基本结构：</p>
<ul>
<li>通用接口，或者说需要被代理的一组方法。</li>
<li>被代理对象。</li>
<li>代理对象。</li>
</ul>
<p>被代理对象和代理对象均实现了通用接口。从代理模式的原理触出发，通用接口起到了一个统一的效果，利用了多态这个面向对象的特性。让调用方不需要关注实现，只需要关注功能。体现了封装和扩展。实现接口相较于继承父类我认为是更加灵活的方式。从语义上来讲，继承表示，is-a，接口表示can。同时考虑JDK实现动态代理的方式，我认为使用接口是更合适的。</p>
<p>但是如果初始类没有提供接口，那么可以考虑重构，提供一组接口或者使用继承的方式完成代理。或者在没有接口，无法继承的情况下也可以使用CGLIB，通过字节码增强完成代理。</p>
<pre><code class="language-java">package com.caldarius.reflection;
/**
 * @Date: 2024/10/10
 * @Author: Caldarius
 * @Description:
 **/

//被代理类和代理类均实现的通用接口，调用方实际上依赖于这个接口，这里体现了依赖倒置的思想。
//上层不直接依赖于下层，双方都依赖于抽象的接口/抽象类
interface Interface {
    void doSomething();
    void somethingElse(String arg);
}
//被代理的对象
class RealObject implements Interface {
    @Override public void doSomething() {
        System.out.println(&quot;doSomething&quot;);
    }
    @Override public void somethingElse(String arg) {
        System.out.println(&quot;somethingElse &quot; + arg);
    }
}
//代理对象
class SimpleProxy implements Interface {
    //代理对象持有被代理对象
    private Interface proxied;
    SimpleProxy(Interface proxied) {
        this.proxied = proxied;
    }

    @Override public void doSomething() {
        //代理对象在调用被代理对象对应方法之前的操作
        System.out.println(&quot;SimpleProxy doSomething before proxied doSomething&quot;);
        //被代理对象调用本身的方法
        proxied.doSomething();
        //代理对象在调用被代理对象对应方法之后的操作
        System.out.println(&quot;SimpleProxy doSomething after proxied doSomething&quot;);
    }
    @Override public void somethingElse(String arg) {
        System.out.println(
                &quot;SimpleProxy somethingElse &quot; + arg+&quot; before proxied somethingElse&quot;);
        proxied.somethingElse(arg);
        System.out.println(
                &quot;SimpleProxy somethingElse &quot; + arg+&quot; after proxied somethingElse&quot;);
    }
}

class SimpleProxyDemo {
    public static void consumer(Interface iface) {
        iface.doSomething();
        iface.somethingElse(&quot;bonobo&quot;);
    }
    public static void main(String[] args) {
        System.out.println(&quot;real done:&quot;);
        consumer(new RealObject());

        System.out.println(&quot;proxy done:&quot;);
        consumer(new SimpleProxy(new RealObject()));
    }
}
/* 
Output：
real done:
doSomething
somethingElse bonobo
proxy done:
SimpleProxy doSomething before proxied doSomething
doSomething
SimpleProxy doSomething after proxied doSomething
SimpleProxy somethingElse bonobo before proxied somethingElse
somethingElse bonobo
SimpleProxy somethingElse bonobo after proxied somethingElse
*/

</code></pre>
<h2 id="反射实现动态代理">反射实现动态代理</h2>
<p>动态代理是一种更加灵活的方式，省去了手动创建代理类的过程，在运行中创建代理类。缺点是需要在<code>invoke()</code>方法中根据传入参数锁定需要代理的方法，操作起来比较复杂。</p>
<pre><code class="language-java">package com.caldarius.reflection;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * @Date: 2024/10/10
 * @Author: Caldarius
 * @Description:
 **/
//调用处理器接口的实现类，判断是什么方法调用，然后决定如何处理
class DynamicProxyHandler implements InvocationHandler {
    private Object proxied;

    DynamicProxyHandler(Object proxied) {
        this.proxied = proxied;
    }
    //三个参数分别是：被代理的对象，当前方法，方法的参数
    @Override public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        System.out.println(
                &quot;**** proxy: &quot; + proxy.getClass() +
                        &quot;, method: &quot; + method + &quot;, args: &quot; + args);
        if(args != null)
            for(Object arg : args)
                System.out.println(&quot;  &quot; + arg);
        return method.invoke(proxied, args);
    }
}

class SimpleDynamicProxy {
    public static void consumer(Interface iface) {
        iface.doSomething();
        iface.somethingElse(&quot;bonobo&quot;);
    }

    public static void main(String[] args) {
        //使用普通对象调用consumer
        RealObject real = new RealObject();
        consumer(real);
        
        //构建代理对象，再次调用consumer
        //三个参数分别是：
        //1.一个类加载器
        //2.希望代理对象实现的接口列表
        //3.InvocationHandler对象的一个实现类 -&gt; 这个类将负责处理代理的主要逻辑
        Interface proxy = (Interface) Proxy.newProxyInstance(
                Interface.class.getClassLoader(),
                new Class[]{ Interface.class },
                new DynamicProxyHandler(real));
        consumer(proxy);
    }
}
/*
 Output:
doSomething
somethingElse bonobo
**** proxy: class com.caldarius.reflection.$Proxy0, method: public abstract void com.caldarius.reflection.Interface.doSomething(), args: null
doSomething
**** proxy: class com.caldarius.reflection.$Proxy0, method: public abstract void com.caldarius.reflection.Interface.somethingElse(java.lang.String), args: [Ljava.lang.Object;@1e80bfe8
  bonobo
somethingElse bonobo
*/

</code></pre>
<h3 id="在invoke中筛选方法的示例">在invoke中筛选方法的示例</h3>
<pre><code class="language-java">@Override 
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    if(method.getName().equals(&quot;interesting&quot;))
        System.out.println(
                &quot;Proxy detected the interesting method&quot;);
    return method.invoke(proxied, args);
    }
}
</code></pre>
<h2 id="cglib">CGLIB</h2>
<p>使用CGLib完成动态代理</p>
<pre><code class="language-java">package com.caldarius.reflection;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class CglibProxy implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println(
                &quot;**** proxy: &quot; +
                        &quot;, method: &quot; + method + &quot;, args: &quot; + objects);
        if(objects != null)
            for(Object arg : objects)
                System.out.println(&quot;  &quot; + arg);
        Object res = methodProxy.invokeSuper(o, objects);
        System.out.println(&quot;END&quot;);
        return res;
    }
}

class EnhancerHandlerFactory{
    public Object getProxy() {
        Enhancer enhancer = new Enhancer();
        //设置被代理的对象
        enhancer.setSuperclass(RealObject.class);
        //设置动态代理处理器
        enhancer.setCallback(new CglibProxy());
        return enhancer.create();
    }

}

class TestProxy{
    public static void main(String[] args) {
        RealObject realObject = (RealObject) new EnhancerHandlerFactory().getProxy();
        realObject.doSomething();
        realObject.somethingElse(&quot;CGLIB Proxy&quot;);
    }
}
/*
output:
**** proxy: , method: public void com.caldarius.reflection.RealObject.doSomething(), args: [Ljava.lang.Object;@46f5f779
doSomething
END
**** proxy: , method: public void com.caldarius.reflection.RealObject.somethingElse(java.lang.String), args: [Ljava.lang.Object;@71e7a66b
  CGLIB Proxy
somethingElse CGLIB Proxy
END
 */
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WMS相关术语中英对照]]></title>
        <id>https://caldarius.github.io/post/wms-xiang-guan-zhu-yu-zhong-ying-dui-zhao/</id>
        <link href="https://caldarius.github.io/post/wms-xiang-guan-zhu-yu-zhong-ying-dui-zhao/">
        </link>
        <updated>2024-10-23T01:54:59.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>列举了WMS系统中常用的专业术语以及其英文对照。</p>
</blockquote>
<p>tips: 不建议在顶级实体中使用类似SC(stock checking)的缩写，建议在其相关的子类中使用。</p>
<p>缩写查询网站：<a href="https://www.abbreviations.com/">Abbreviations.com</a></p>
<h1 id="术语对照">术语对照</h1>
<p>不建议在顶级实体中使用类似SC(stock checking)的缩写，建议在其相关的子类中使用。</p>
<h2 id="设备equipment">设备	equipment</h2>
<ul>
<li>成套的设备</li>
<li>equip</li>
</ul>
<h2 id="维护maintenance">维护	maintenance</h2>
<ul>
<li>维护、保养</li>
<li>maint</li>
</ul>
<h2 id="内容content">内容	content</h2>
<ul>
<li>目录，主要内容</li>
<li>cnt</li>
</ul>
<h2 id="入库inbound">入库	inbound</h2>
<ul>
<li>货物入库</li>
<li>ib</li>
</ul>
<h2 id="出库outbound">出库	outbound</h2>
<ul>
<li>货物出库</li>
<li>ob</li>
</ul>
<h2 id="盘点stock-checking">盘点	stock checking</h2>
<ul>
<li>对储存物品进行清点和账务核对的活动</li>
<li>sc</li>
</ul>
<h2 id="库存inventory">库存	inventory</h2>
<ul>
<li>储存作为今后按预定的目的使用而处于备用或非生产状态的物品。注:广义的库存还包括处于制造加工状态和运输状态的物品。</li>
<li>inv</li>
</ul>
<h2 id="货架rack">货架	rack</h2>
<ul>
<li>用立柱、隔板和横梁等组成的立体存储货物的设施。</li>
<li>rack</li>
</ul>
<h2 id="货位location">货位	location</h2>
<ul>
<li>货架上存储一个单元货物的单位空间。注意这里和货格(cell)是不一样的，一个货格可能会包含多个货位。书架上一个格子是一个cell，但是一个cell可能包含多本书的位置，一本书的位置就是location。</li>
<li>loc</li>
</ul>
<h2 id="存储区rack-zoning">存储区	rack zoning</h2>
<ul>
<li>货架的存储位置区分为若干存储区域。</li>
<li>RZ</li>
</ul>
<h2 id="排row">排	row</h2>
<ul>
<li>垂直于堆垛机行走方向货位数的单位</li>
</ul>
<h2 id="列bay">列	bay</h2>
<ul>
<li>平行于堆垛机行走方向货位数的单位</li>
</ul>
<h2 id="层level">层	level</h2>
<ul>
<li>货架高度方向货位数的单位</li>
</ul>
<h2 id="物料material">物料	material</h2>
<ul>
<li>可以指用于制造产品的原材料或半成品。</li>
<li>matl</li>
</ul>
<h3 id="原料component-or-rawmaterial">原料	Component or RawMaterial</h3>
<ul>
<li>comp</li>
<li>RM</li>
</ul>
<h3 id="物料计划material-planning">物料计划	Material Planning</h3>
<ul>
<li>一般指制造型企业的周期性的物料到厂计划</li>
<li>MP</li>
</ul>
<h3 id="主要生产计划master-production-schedule">主要生产计划	Master Production Schedule</h3>
<ul>
<li>较为粗略的生产计划，是MP产生的根据</li>
<li>MPS</li>
</ul>
<h3 id="物料计划bill-of-material">物料计划	Bill of Material</h3>
<ul>
<li>MPS在生产方面的属性</li>
<li>BOM</li>
</ul>
<h2 id="货物goods">货物	goods</h2>
<ul>
<li>经济与社会活动中实体流动的物质资料。</li>
<li>goods</li>
</ul>
<p>补充几种goods类型</p>
<h3 id="成品finished-goods">成品	Finished Goods</h3>
<ul>
<li>成品</li>
<li>FG</li>
</ul>
<h3 id="半成品semi-finished-goods">半成品Semi-Finished Goods</h3>
<ul>
<li>半成品</li>
<li>SFG</li>
</ul>
<h2 id="订单order">订单	order</h2>
<ul>
<li>目前来看主要指对接仓库的单据。</li>
<li>order</li>
</ul>
<h2 id="入库单inbound-order">入库单	inbound order</h2>
<ul>
<li>人员/系统提交的入库单</li>
<li>IBO, ib_order</li>
</ul>
<h2 id="出库单outbound-order">出库单	outbound order</h2>
<ul>
<li>同上</li>
<li>OBO, ob_order</li>
</ul>
<h2 id="收据receipt">收据	receipt</h2>
<ul>
<li>a piece of paper that proves that money, goods, or information have been received.</li>
<li>receipt</li>
</ul>
<h2 id="托盘pallet">托盘	pallet</h2>
<ul>
<li>在运输,搬运和存储过程中,将物品规整为货物单元时,作为承载面并包括承载面上辅助结构件的装置。</li>
<li>pallet</li>
</ul>
<h2 id="仓库warehouse">仓库	warehouse</h2>
<ul>
<li>用于储存﹑保管物品的建筑物和场所的总称。</li>
<li>wh</li>
</ul>
<h1 id="辨析">辨析</h1>
<h2 id="goods-和material">goods 和material</h2>
<table>
<thead>
<tr>
<th>特征</th>
<th>material</th>
<th>goods</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>含义</strong></td>
<td>指用于生产或制造商品的原材料或组件。</td>
<td>指可供出售或交易的有形、可移动的物品。</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>用于生产其他商品。</td>
<td>用于满足消费者的需求。</td>
</tr>
<tr>
<td><strong>来源</strong></td>
<td>可以是天然的或人造的。</td>
<td>总是人造的。</td>
</tr>
<tr>
<td><strong>形式</strong></td>
<td>可以是固体、液体或气体。</td>
<td>通常是固体或液体。</td>
</tr>
<tr>
<td><strong>价值</strong></td>
<td>通常比制成品的价值低。</td>
<td>通常比原材料的价值高。</td>
</tr>
<tr>
<td><strong>市场</strong></td>
<td>原材料市场。</td>
<td>商品市场。</td>
</tr>
<tr>
<td><strong>例子</strong></td>
<td>木材、金属、塑料、石油等。</td>
<td>汽车、衣服、食品、电子产品等。</td>
</tr>
</tbody>
</table>
<p>总体而言，material和goods的区别在于，前者是用于生产或制造商品的原材料或组件，而后者是可供出售或交易的有形、可移动的物品。在《物流术语》中，使用goods代表货物。</p>
<h2 id="stock和inventory">stock和inventory</h2>
<ul>
<li>
<p><strong>stock</strong></p>
<ul>
<li>库存商品</li>
<li>供应的商品</li>
<li>商店出售的商品</li>
<li>储备商品</li>
</ul>
</li>
<li>
<p><strong>inventory</strong></p>
<ul>
<li>清单</li>
<li>盘点</li>
<li>库存</li>
<li>盘查</li>
</ul>
</li>
</ul>
<p><strong>词义区别</strong></p>
<ul>
<li>
<p><strong>stock</strong> 通常用于指代可以出售的商品，而 <strong>inventory</strong> 通常用于指代存储在仓库或其他地方的商品。</p>
</li>
<li>
<p><strong>stock</strong> 通常用于指代成品或可立即出售的商品，而 <strong>inventory</strong> 可以包括所有类型的商品，包括原材料、半成品和成品。</p>
</li>
<li>
<p><strong>stock</strong> 通常用于指代数量相对较少、而且流动性较高的商品，而 <strong>inventory</strong> 可以包括数量相对较大、流动性较低的商品。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>特征</th>
<th>stock</th>
<th>inventory</th>
</tr>
</thead>
<tbody>
<tr>
<td>涵盖范围</td>
<td>库存的原材料、半成品、成品、备件等</td>
<td>库存的原材料、半成品、成品、备件、在制品等</td>
</tr>
<tr>
<td>状态</td>
<td>通常用于表示库存中已完成的产品或商品，通常是准备出售的</td>
<td>通常用于表示库存中所有类型的物品，包括原材料、半成品、成品、备件等</td>
</tr>
<tr>
<td>目的</td>
<td>库存管理的主要目的是为了满足客户的需求</td>
<td>库存管理的主要目的是为了优化生产和销售，并减少持有库存的成本</td>
</tr>
<tr>
<td>价值</td>
<td>通常被认为是资产，因为它可以出售以产生收入</td>
<td>通常被认为是成本，因为它需要资金来购买和维护</td>
</tr>
</tbody>
</table>
<h2 id="receipt-和inbound-order">receipt 和inbound order</h2>
<table>
<thead>
<tr>
<th>特征</th>
<th>receipt</th>
<th>inbound order</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义</td>
<td>收据</td>
<td>入库单</td>
</tr>
<tr>
<td>目的</td>
<td>记录商品或服务的接收</td>
<td>下达将商品或服务运送至仓库的指令</td>
</tr>
<tr>
<td>发行者</td>
<td>供应商或收货人</td>
<td>采购部门或仓库</td>
</tr>
<tr>
<td>收件人</td>
<td>收货人</td>
<td>仓库</td>
</tr>
<tr>
<td>内容</td>
<td>商品或服务的描述、数量、价格、日期</td>
<td>商品或服务的描述、数量、收货地址、交货日期</td>
</tr>
<tr>
<td>目标</td>
<td>提供商品或服务的接收证明</td>
<td>跟踪入库货物并确保其准确性</td>
</tr>
<tr>
<td>流程</td>
<td>收货后签发</td>
<td>在收货之前签发</td>
</tr>
<tr>
<td>时机</td>
<td>在商品或服务接收后签发</td>
<td>在商品或服务运送至仓库之前签发</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
</feed>